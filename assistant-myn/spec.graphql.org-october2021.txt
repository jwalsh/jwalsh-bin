                                    GraphQL

   October 2021 Edition

        [1]Introduction

   This is the specification for GraphQL, a query language and execution
   engine originally created at Facebook in 2012 for describing the
   capabilities and requirements of data models for client-server
   applications. The development of this open standard started in 2015.
   This specification was licensed under OWFa 1.0 in 2017. The [2]GraphQL
   Foundation was formed in 2019 as a neutral focal point for
   organizations who support the GraphQL ecosystem, and the [3]GraphQL
   Specification Project was established also in 2019 as the Joint
   Development Foundation Projects, LLC, GraphQL Series.

   If your organization benefits from GraphQL, please consider [4]becoming
   a member and helping us to sustain the activities that support the
   health of our neutral ecosystem.

   The GraphQL Specification Project has evolved and may continue to
   evolve in future editions of this specification. Previous editions of
   the GraphQL specification can be found at permalinks that match their
   [5]release tag. The latest working draft release can be found at
   [6]https://spec.graphql.org/draft.

        [7]Copyright notice

   Copyright © 2015-2018, Facebook, Inc.

   Copyright © 2019-present, GraphQL contributors

   THESE MATERIALS ARE PROVIDED "AS IS." The parties expressly disclaim
   any warranties (express, implied, or otherwise), including implied
   warranties of merchantability, non-infringement, fitness for a
   particular purpose, or title, related to the materials. The entire risk
   as to implementing or otherwise using the materials is assumed by the
   implementer and user. IN NO EVENT WILL THE PARTIES BE LIABLE TO ANY
   OTHER PARTY FOR LOST PROFITS OR ANY FORM OF INDIRECT, SPECIAL,
   INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER FROM ANY CAUSES
   OF ACTION OF ANY KIND WITH RESPECT TO THIS DELIVERABLE OR ITS GOVERNING
   AGREEMENT, WHETHER BASED ON BREACH OF CONTRACT, TORT (INCLUDING
   NEGLIGENCE), OR OTHERWISE, AND WHETHER OR NOT THE OTHER MEMBER HAS BEEN
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

        [8]Licensing

   The GraphQL Specification Project is made available by the [9]Joint
   Development Foundation. The current [10]Working Group charter, which
   includes the IP policy governing all working group deliverables
   (including specifications, source code, and datasets) may be found at
   [11]https://technical-charter.graphql.org.

   Currently, the licenses governing GraphQL Specification Project
   deliverables are:

   Deliverable License
   Specifications [12]Open Web Foundation Agreement 1.0 Mode (Patent and
   Copyright)
   Source code [13]MIT License
   Data sets [14]CC0 1.0

        [15]Conformance

   A conforming implementation of GraphQL must fulfill all normative
   requirements. Conformance requirements are described in this document
   via both descriptive assertions and key words with clearly defined
   meanings.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the
   normative portions of this document are to be interpreted as described
   in [16]IETF RFC 2119. These key words may appear in lowercase and still
   retain their meaning unless explicitly declared as non-normative.

   A conforming implementation of GraphQL may provide additional
   functionality, but must not where explicitly disallowed or would
   otherwise result in non-conformance.

        [17]Conforming Algorithms

   Algorithm steps phrased in imperative grammar (e.g. "Return the result
   of calling resolver") are to be interpreted with the same level of
   requirement as the algorithm it is contained within. Any algorithm
   referenced within an algorithm step (e.g. "Let completedResult be the
   result of calling CompleteValue()") is to be interpreted as having at
   least the same level of requirement as the algorithm containing that
   step.

   Conformance requirements expressed as algorithms can be fulfilled by an
   implementation of this specification in any way as long as the
   perceived result is equivalent. Algorithms described in this document
   are written to be easy to understand. Implementers are encouraged to
   include equivalent but optimized implementations.

   See [18]Appendix A for more details about the definition of algorithms
   and other notational conventions used in this document.

        [19]Non-Normative Portions

   All contents of this document are normative except portions explicitly
   declared as non-normative.

   Examples in this document are non-normative, and are presented to aid
   understanding of introduced concepts and the behavior of normative
   portions of the specification. Examples are either introduced
   explicitly in prose (e.g. "for example") or are set apart in example or
   counter-example blocks, like this:
[20]Example No. 1This is an example of a non-normative example.

[21]Counter Example No. 2This is an example of a non-normative counter-example.

   Notes in this document are non-normative, and are presented to clarify
   intent, draw attention to potential edge-cases and pit-falls, and
   answer common questions that arise during implementation. Notes are
   either introduced explicitly in prose (e.g. "Note: ") or are set apart
   in a note block, like this:

   [22]Note This is an example of a non-normative note.

   Contents

    1. [23]1Overview
    2. [24]2Language
         1. [25]2.1Source Text
              1. [26]2.1.1Unicode
              2. [27]2.1.2White Space
              3. [28]2.1.3Line Terminators
              4. [29]2.1.4Comments
              5. [30]2.1.5Insignificant Commas
              6. [31]2.1.6Lexical Tokens
              7. [32]2.1.7Ignored Tokens
              8. [33]2.1.8Punctuators
              9. [34]2.1.9Names
         2. [35]2.2Document
         3. [36]2.3Operations
         4. [37]2.4Selection Sets
         5. [38]2.5Fields
         6. [39]2.6Arguments
         7. [40]2.7Field Alias
         8. [41]2.8Fragments
              1. [42]2.8.1Type Conditions
              2. [43]2.8.2Inline Fragments
         9. [44]2.9Input Values
              1. [45]2.9.1Int Value
              2. [46]2.9.2Float Value
              3. [47]2.9.3Boolean Value
              4. [48]2.9.4String Value
              5. [49]2.9.5Null Value
              6. [50]2.9.6Enum Value
              7. [51]2.9.7List Value
              8. [52]2.9.8Input Object Values
        10. [53]2.10Variables
        11. [54]2.11Type References
        12. [55]2.12Directives
    3. [56]3Type System
         1. [57]3.1Type System Extensions
         2. [58]3.2Descriptions
         3. [59]3.3Schema
              1. [60]3.3.1Root Operation Types
              2. [61]3.3.2Schema Extension
         4. [62]3.4Types
              1. [63]3.4.1Wrapping Types
              2. [64]3.4.2Input and Output Types
              3. [65]3.4.3Type Extensions
         5. [66]3.5Scalars
              1. [67]3.5.1Int
              2. [68]3.5.2Float
              3. [69]3.5.3String
              4. [70]3.5.4Boolean
              5. [71]3.5.5ID
              6. [72]3.5.6Scalar Extensions
         6. [73]3.6Objects
              1. [74]3.6.1Field Arguments
              2. [75]3.6.2Field Deprecation
              3. [76]3.6.3Object Extensions
         7. [77]3.7Interfaces
              1. [78]3.7.1Interface Extensions
         8. [79]3.8Unions
              1. [80]3.8.1Union Extensions
         9. [81]3.9Enums
              1. [82]3.9.1Enum Extensions
        10. [83]3.10Input Objects
              1. [84]3.10.1Input Object Extensions
        11. [85]3.11List
        12. [86]3.12Non-Null
              1. [87]3.12.1Combining List and Non-Null
        13. [88]3.13Directives
              1. [89]3.13.1@skip
              2. [90]3.13.2@include
              3. [91]3.13.3@deprecated
              4. [92]3.13.4@specifiedBy
    4. [93]4Introspection
         1. [94]4.1Type Name Introspection
         2. [95]4.2Schema Introspection
              1. [96]4.2.1The __Schema Type
              2. [97]4.2.2The __Type Type
              3. [98]4.2.3The __Field Type
              4. [99]4.2.4The __InputValue Type
              5. [100]4.2.5The __EnumValue Type
              6. [101]4.2.6The __Directive Type
    5. [102]5Validation
         1. [103]5.1Documents
              1. [104]5.1.1Executable Definitions
         2. [105]5.2Operations
              1. [106]5.2.1Named Operation Definitions
                   1. [107]5.2.1.1Operation Name Uniqueness
              2. [108]5.2.2Anonymous Operation Definitions
                   1. [109]5.2.2.1Lone Anonymous Operation
              3. [110]5.2.3Subscription Operation Definitions
                   1. [111]5.2.3.1Single root field
         3. [112]5.3Fields
              1. [113]5.3.1Field Selections
              2. [114]5.3.2Field Selection Merging
              3. [115]5.3.3Leaf Field Selections
         4. [116]5.4Arguments
              1. [117]5.4.1Argument Names
              2. [118]5.4.2Argument Uniqueness
                   1. [119]5.4.2.1Required Arguments
         5. [120]5.5Fragments
              1. [121]5.5.1Fragment Declarations
                   1. [122]5.5.1.1Fragment Name Uniqueness
                   2. [123]5.5.1.2Fragment Spread Type Existence
                   3. [124]5.5.1.3Fragments On Composite Types
                   4. [125]5.5.1.4Fragments Must Be Used
              2. [126]5.5.2Fragment Spreads
                   1. [127]5.5.2.1Fragment spread target defined
                   2. [128]5.5.2.2Fragment spreads must not form cycles
                   3. [129]5.5.2.3Fragment spread is possible
                        1. [130]5.5.2.3.1Object Spreads In Object Scope
                        2. [131]5.5.2.3.2Abstract Spreads in Object Scope
                        3. [132]5.5.2.3.3Object Spreads In Abstract Scope
                        4. [133]5.5.2.3.4Abstract Spreads in Abstract
                           Scope
         6. [134]5.6Values
              1. [135]5.6.1Values of Correct Type
              2. [136]5.6.2Input Object Field Names
              3. [137]5.6.3Input Object Field Uniqueness
              4. [138]5.6.4Input Object Required Fields
         7. [139]5.7Directives
              1. [140]5.7.1Directives Are Defined
              2. [141]5.7.2Directives Are In Valid Locations
              3. [142]5.7.3Directives Are Unique Per Location
         8. [143]5.8Variables
              1. [144]5.8.1Variable Uniqueness
              2. [145]5.8.2Variables Are Input Types
              3. [146]5.8.3All Variable Uses Defined
              4. [147]5.8.4All Variables Used
              5. [148]5.8.5All Variable Usages are Allowed
    6. [149]6Execution
         1. [150]6.1Executing Requests
              1. [151]6.1.1Validating Requests
              2. [152]6.1.2Coercing Variable Values
         2. [153]6.2Executing Operations
              1. [154]6.2.1Query
              2. [155]6.2.2Mutation
              3. [156]6.2.3Subscription
                   1. [157]6.2.3.1Source Stream
                   2. [158]6.2.3.2Response Stream
                   3. [159]6.2.3.3Unsubscribe
         3. [160]6.3Executing Selection Sets
              1. [161]6.3.1Normal and Serial Execution
              2. [162]6.3.2Field Collection
         4. [163]6.4Executing Fields
              1. [164]6.4.1Coercing Field Arguments
              2. [165]6.4.2Value Resolution
              3. [166]6.4.3Value Completion
              4. [167]6.4.4Handling Field Errors
    7. [168]7Response
         1. [169]7.1Response Format
              1. [170]7.1.1Data
              2. [171]7.1.2Errors
         2. [172]7.2Serialization Format
              1. [173]7.2.1JSON Serialization
              2. [174]7.2.2Serialized Map Ordering
    8. [175]AAppendix: Notation Conventions
         1. [176]A.1Context-Free Grammar
         2. [177]A.2Lexical and Syntactical Grammar
         3. [178]A.3Grammar Notation
         4. [179]A.4Grammar Semantics
         5. [180]A.5Algorithms
    9. [181]BAppendix: Grammar Summary
         1. [182]B.1Source Text
         2. [183]B.2Ignored Tokens
         3. [184]B.3Lexical Tokens
         4. [185]B.4Document Syntax
   10. [186]§Index

                                 [187]1Overview

   GraphQL is a query language designed to build client applications by
   providing an intuitive and flexible syntax and system for describing
   their data requirements and interactions.

   For example, this GraphQL request will receive the name of the user
   with id 4 from the Facebook implementation of GraphQL.
[188]Example No. 3{
  user(id: 4) {
    name
  }
}

   Which produces the resulting data (in JSON):
[189]Example No. 4{
  "user": {
    "name": "Mark Zuckerberg"
  }
}

   GraphQL is not a programming language capable of arbitrary computation,
   but is instead a language used to make requests to application services
   that have capabilities defined in this specification. GraphQL does not
   mandate a particular programming language or storage system for
   application services that implement it. Instead, application services
   take their capabilities and map them to a uniform language, type
   system, and philosophy that GraphQL encodes. This provides a unified
   interface friendly to product development and a powerful platform for
   tool-building.

   GraphQL has a number of design principles:
     * Product-centric: GraphQL is unapologetically driven by the
       requirements of views and the front-end engineers that write them.
       GraphQL starts with their way of thinking and requirements and
       builds the language and runtime necessary to enable that.
     * Hierarchical: Most product development today involves the creation
       and manipulation of view hierarchies. To achieve congruence with
       the structure of these applications, a GraphQL request itself is
       structured hierarchically. The request is shaped just like the data
       in its response. It is a natural way for clients to describe data
       requirements.
     * Strong-typing: Every GraphQL service defines an
       application-specific type system. Requests are executed within the
       context of that type system. Given a GraphQL operation, tools can
       ensure that it is both syntactically correct and valid within that
       type system before execution, i.e. at development time, and the
       service can make certain guarantees about the shape and nature of
       the response.
     * Client-specified response: Through its type system, a GraphQL
       service publishes the capabilities that its clients are allowed to
       consume. It is the client that is responsible for specifying
       exactly how it will consume those published capabilities. These
       requests are specified at field-level granularity. In the majority
       of client-server applications written without GraphQL, the service
       determines the shape of data returned from its various endpoints. A
       GraphQL response, on the other hand, contains exactly what a client
       asks for and no more.
     * Introspective: GraphQL is introspective. A GraphQL service's type
       system can be queryable by the GraphQL language itself, as will be
       described in this specification. GraphQL introspection serves as a
       powerful platform for building common tools and client software
       libraries.

   Because of these principles, GraphQL is a powerful and productive
   environment for building client applications. Product developers and
   designers building applications against working GraphQL
   services--supported with quality tools--can quickly become productive
   without reading extensive documentation and with little or no formal
   training. To enable that experience, there must be those that build
   those services and tools.

   The following formal specification serves as a reference for those
   builders. It describes the language and its grammar, the type system
   and the introspection system used to query it, and the execution and
   validation engines with the algorithms to power them. The goal of this
   specification is to provide a foundation and framework for an ecosystem
   of GraphQL tools, client libraries, and service
   implementations--spanning both organizations and platforms--that has
   yet to be built. We look forward to working with the community in order
   to do that.

                                 [190]2Language

   Clients use the GraphQL query language to make requests to a GraphQL
   service. We refer to these request sources as documents. A document may
   contain operations (queries, mutations, and subscriptions) as well as
   fragments, a common unit of composition allowing for data requirement
   reuse.

   A GraphQL document is defined as a syntactic grammar where terminal
   symbols are tokens (indivisible lexical units). These tokens are
   defined in a lexical grammar which matches patterns of source
   characters. In this document, syntactic grammar productions are
   distinguished with a colon : while lexical grammar productions are
   distinguished with a double-colon ::.

   The source text of a GraphQL document must be a sequence of
   [191]SourceCharacter. The character sequence must be described by a
   sequence of [192]Token and [193]Ignored lexical grammars. The lexical
   token sequence, omitting [194]Ignored, must be described by a single
   [195]Document syntactic grammar.

   [196]Note See [197]Appendix A for more information about the lexical
   and syntactic grammar and other notational conventions used throughout
   this document.

        [198]Lexical Analysis & Syntactic Parse

   The source text of a GraphQL document is first converted into a
   sequence of lexical tokens, [199]Token, and ignored tokens,
   [200]Ignored. The source text is scanned from left to right, repeatedly
   taking the next possible sequence of code-points allowed by the lexical
   grammar productions as the next token. This sequence of lexical tokens
   are then scanned from left to right to produce an abstract syntax tree
   (AST) according to the [201]Document syntactical grammar.

   Lexical grammar productions in this document use lookahead restrictions
   to remove ambiguity and ensure a single valid lexical analysis. A
   lexical token is only valid if not followed by a character in its
   lookahead restriction.

   For example, an [202]IntValue has the restriction [203]Digit, so cannot
   be followed by a [204]Digit. Because of this, the sequence 123 cannot
   represent the tokens (12, 3) since 12 is followed by the [205]Digit 3
   and so must only represent a single token. Use [206]WhiteSpace or other
   [207]Ignored between characters to represent multiple tokens.

   [208]Note This typically has the same behavior as a "[209]maximal
   munch" longest possible match, however some lookahead restrictions
   include additional constraints.

[210]2.1Source Text

   [211]SourceCharacter
   U+0009
   U+000A
   U+000D
   U+0020-U+FFFF

   GraphQL documents are expressed as a sequence of [212]Unicode code
   points (informally referred to as "characters" through most of this
   specification). However, with few exceptions, most of GraphQL is
   expressed only in the original non-control ASCII range so as to be as
   widely compatible with as many existing tools, languages, and
   serialization formats as possible and avoid display issues in text
   editors and source control.

   [213]Note Non-ASCII Unicode characters may appear freely within
   [214]StringValue and [215]Comment portions of GraphQL.

  [216]2.1.1Unicode

   [217]UnicodeBOM
   Byte Order Mark (U+FEFF)

   The "Byte Order Mark" is a special Unicode character which may appear
   at the beginning of a file containing Unicode which programs may use to
   determine the fact that the text stream is Unicode, what endianness the
   text stream is in, and which of several Unicode encodings to interpret.

  [218]2.1.2White Space

   [219]WhiteSpace
   Horizontal Tab (U+0009)
   Space (U+0020)

   White space is used to improve legibility of source text and act as
   separation between tokens, and any amount of white space may appear
   before or after any token. White space between tokens is not
   significant to the semantic meaning of a GraphQL Document, however
   white space characters may appear within a String or [220]Comment
   token.

   [221]Note GraphQL intentionally does not consider Unicode "Zs" category
   characters as white-space, avoiding misinterpretation by text editors
   and source control tools.

  [222]2.1.3Line Terminators

   [223]LineTerminator
   New Line (U+000A)
   Carriage Return (U+000D)New Line (U+000A)
   Carriage Return (U+000D)New Line (U+000A)

   Like white space, line terminators are used to improve the legibility
   of source text and separate lexical tokens, any amount may appear
   before or after any other token and have no significance to the
   semantic meaning of a GraphQL Document. Line terminators are not found
   within any other token.

   [224]Note Any error reporting which provides the line number in the
   source of the offending syntax should use the preceding amount of
   [225]LineTerminator to produce the line number.

  [226]2.1.4Comments

   [227]Comment
   #[228]CommentCharlistopt[229]CommentChar

   [230]CommentChar
   [231]SourceCharacter[232]LineTerminator

   GraphQL source documents may contain single-line comments, starting
   with the # marker.

   A comment can contain any Unicode code point in [233]SourceCharacter
   except [234]LineTerminator so a comment always consists of all code
   points starting with the # character up to but not including the
   [235]LineTerminator (or end of the source).

   Comments are [236]Ignored like white space and may appear after any
   token, or before a [237]LineTerminator, and have no significance to the
   semantic meaning of a GraphQL Document.

  [238]2.1.5Insignificant Commas

   [239]Comma
   ,

   Similar to white space and line terminators, commas (,) are used to
   improve the legibility of source text and separate lexical tokens but
   are otherwise syntactically and semantically insignificant within
   GraphQL Documents.

   Non-significant comma characters ensure that the absence or presence of
   a comma does not meaningfully alter the interpreted syntax of the
   document, as this can be a common user-error in other languages. It
   also allows for the stylistic use of either trailing commas or line
   terminators as list delimiters which are both often desired for
   legibility and maintainability of source code.

  [240]2.1.6Lexical Tokens

   [241]Token
   [242]Punctuator
   [243]Name
   [244]IntValue
   [245]FloatValue
   [246]StringValue

   A GraphQL document is comprised of several kinds of indivisible lexical
   tokens defined here in a lexical grammar by patterns of source Unicode
   characters. Lexical tokens may be separated by [247]Ignored tokens.

   Tokens are later used as terminal symbols in GraphQL syntactic grammar
   rules.

  [248]2.1.7Ignored Tokens

   [249]Ignored
   [250]UnicodeBOM
   [251]WhiteSpace
   [252]LineTerminator
   [253]Comment
   [254]Comma

   [255]Ignored tokens are used to improve readability and provide
   separation between lexical tokens, but are otherwise insignificant and
   not referenced in syntactical grammar productions.

   Any amount of [256]Ignored may appear before and after every lexical
   token. No ignored regions of a source document are significant, however
   [257]SourceCharacter which appear in [258]Ignored may also appear
   within a lexical [259]Token in a significant way, for example a
   [260]StringValue may contain white space characters. No [261]Ignored
   may appear within a [262]Token, for example no white space characters
   are permitted between the characters defining a [263]FloatValue.

  [264]2.1.8Punctuators

   [265]Punctuator
   ! $ & ( ) ... : = @ [ ] { | }

   GraphQL documents include punctuation in order to describe structure.
   GraphQL is a data description language and not a programming language,
   therefore GraphQL lacks the punctuation often used to describe
   mathematical expressions.

  [266]2.1.9Names

   [267]Name
   [268]NameStart[269]NameContinuelistopt[270]NameContinue

   [271]NameStart
   [272]Letter
   _

   [273]NameContinue
   [274]Letter
   [275]Digit
   _

   [276]Letter
   A B C D E F G H I J K L M
   N O P Q R S T U V W X Y Z
   a b c d e f g h i j k l m
   n o p q r s t u v w x y z

   [277]Digit
   0 1 2 3 4 5 6 7 8 9

   GraphQL Documents are full of named things: operations, fields,
   arguments, types, directives, fragments, and variables. All names must
   follow the same grammatical form.

   Names in GraphQL are case-sensitive. That is to say name, Name, and
   NAME all refer to different names. Underscores are significant, which
   means other_name and othername are two different names.

   A [278]Name must not be followed by a [279]NameContinue. In other
   words, a [280]Name token is always the longest possible valid sequence.
   The source characters a1 cannot be interpreted as two tokens since a is
   followed by the [281]NameContinue 1.

   [282]Note Names in GraphQL are limited to the Latin ASCII subset of
   [283]SourceCharacter in order to support interoperation with as many
   other systems as possible.

        [284]Reserved Names

   Any [285]Name within a GraphQL type system must not start with two
   underscores "__" unless it is part of the [286]introspection system as
   defined by this specification.

[287]2.2Document

   [288]Document
   [289]Definitionlist

   [290]Definition
   [291]ExecutableDefinition
   [292]TypeSystemDefinitionOrExtension

   [293]ExecutableDocument
   [294]ExecutableDefinitionlist

   [295]ExecutableDefinition
   [296]OperationDefinition
   [297]FragmentDefinition

   A GraphQL Document describes a complete file or request string operated
   on by a GraphQL service or client. A document contains multiple
   definitions, either executable or representative of a GraphQL type
   system.

   Documents are only executable by a GraphQL service if they are
   [298]ExecutableDocument and contain at least one
   [299]OperationDefinition. A Document which contains
   [300]TypeSystemDefinitionOrExtension must not be executed; GraphQL
   execution services which receive a Document containing these should
   return a descriptive error.

   GraphQL services which only seek to execute GraphQL requests and not
   construct a new GraphQL schema may choose to only permit
   [301]ExecutableDocument.

   Documents which do not contain [302]OperationDefinition or do contain
   [303]TypeSystemDefinitionOrExtension may still be parsed and validated
   to allow client tools to represent many GraphQL uses which may appear
   across many individual files.

   If a Document contains only one operation, that operation may be
   unnamed. If that operation is a query without variables or directives
   then it may also be represented in the shorthand form, omitting both
   the query keyword as well as the operation name. Otherwise, if a
   GraphQL Document contains multiple operations, each operation must be
   named. When submitting a Document with multiple operations to a GraphQL
   service, the name of the desired operation to be executed must also be
   provided.

[304]2.3Operations

   [305]OperationDefinition
   [306]OperationType[307]Nameopt[308]VariableDefinitionsopt[309]Directive
   sopt[310]SelectionSet
   [311]SelectionSet

   [312]OperationType
   query mutation subscription

   There are three types of operations that GraphQL models:
     * query - a read-only fetch.
     * mutation - a write followed by a fetch.
     * subscription - a long-lived request that fetches data in response
       to source events.

   Each operation is represented by an optional operation name and a
   selection set.

   For example, this mutation operation might "like" a story and then
   retrieve the new number of likes:
[313]Example No. 5mutation {
  likeStory(storyID: 12345) {
    story {
      likeCount
    }
  }
}

        [314]Query shorthand

   If a document contains only one operation and that operation is a query
   which defines no variables and contains no directives then that
   operation may be represented in a short-hand form which omits the query
   keyword and operation name.

   For example, this unnamed query operation is written via query
   shorthand.
[315]Example No. 6{
  field
}

   [316]Note many examples below will use the query short-hand syntax.

[317]2.4Selection Sets

   [318]SelectionSet
   {[319]Selectionlist}

   [320]Selection
   [321]Field
   [322]FragmentSpread
   [323]InlineFragment

   An operation selects the set of information it needs, and will receive
   exactly that information and nothing more, avoiding over-fetching and
   under-fetching data.
[324]Example No. 7{
  id
  firstName
  lastName
}

   In this query operation, the id, firstName, and lastName fields form a
   selection set. Selection sets may also contain fragment references.

[325]2.5Fields

   [326]Field
   [327]Aliasopt[328]Name[329]Argumentsopt[330]Directivesopt[331]Selection
   Setopt

   A selection set is primarily composed of fields. A field describes one
   discrete piece of information available to request within a selection
   set.

   Some fields describe complex data or relationships to other data. In
   order to further explore this data, a field may itself contain a
   selection set, allowing for deeply nested requests. All GraphQL
   operations must specify their selections down to fields which return
   scalar values to ensure an unambiguously shaped response.

   For example, this operation selects fields of complex data and
   relationships down to scalar values.
[332]Example No. 8{
  me {
    id
    firstName
    lastName
    birthday {
      month
      day
    }
    friends {
      name
    }
  }
}

   Fields in the top-level selection set of an operation often represent
   some information that is globally accessible to your application and
   its current viewer. Some typical examples of these top fields include
   references to a current logged-in viewer, or accessing certain types of
   data referenced by a unique identifier.
[333]Example No. 9# `me` could represent the currently logged in viewer.
{
  me {
    name
  }
}

# `user` represents one of many users in a graph of data, referred to by a
# unique identifier.
{
  user(id: 4) {
    name
  }
}

[334]2.6Arguments

   [335]ArgumentsConst
   ([336]ArgumentConstlist)

   [337]ArgumentConst
   [338]Name:[339]ValueConst

   Fields are conceptually functions which return values, and occasionally
   accept arguments which alter their behavior. These arguments often map
   directly to function arguments within a GraphQL service's
   implementation.

   In this example, we want to query a specific user (requested via the id
   argument) and their profile picture of a specific size:
[340]Example No. 10{
  user(id: 4) {
    id
    name
    profilePic(size: 100)
  }
}

   Many arguments can exist for a given field:
[341]Example No. 11{
  user(id: 4) {
    id
    name
    profilePic(width: 100, height: 50)
  }
}

        [342]Arguments are unordered

   Arguments may be provided in any syntactic order and maintain identical
   semantic meaning.

   These two operations are semantically identical:
[343]Example No. 12{
  picture(width: 200, height: 100)
}

[344]Example No. 13{
  picture(height: 100, width: 200)
}

[345]2.7Field Alias

   [346]Alias
   [347]Name:

   By default a field's response key in the response object will use that
   field's name. However, you can define a different response key by
   specifying an alias.

   In this example, we can fetch two profile pictures of different sizes
   and ensure the resulting response object will not have duplicate keys:
[348]Example No. 14{
  user(id: 4) {
    id
    name
    smallPic: profilePic(size: 64)
    bigPic: profilePic(size: 1024)
  }
}

   which returns the result:
[349]Example No. 15{
  "user": {
    "id": 4,
    "name": "Mark Zuckerberg",
    "smallPic": "https://cdn.site.io/pic-4-64.jpg",
    "bigPic": "https://cdn.site.io/pic-4-1024.jpg"
  }
}

   The fields at the top level of an operation can also be given an alias:
[350]Example No. 16{
  zuck: user(id: 4) {
    id
    name
  }
}

   which returns the result:
[351]Example No. 17{
  "zuck": {
    "id": 4,
    "name": "Mark Zuckerberg"
  }
}

[352]2.8Fragments

   [353]FragmentSpread
   ...[354]FragmentName[355]Directivesopt

   [356]FragmentDefinition
   fragment[357]FragmentName[358]TypeCondition[359]Directivesopt[360]Selec
   tionSet

   [361]FragmentName
   [362]Nameon

   Fragments are the primary unit of composition in GraphQL.

   Fragments allow for the reuse of common repeated selections of fields,
   reducing duplicated text in the document. Inline Fragments can be used
   directly within a selection to condition upon a type condition when
   querying against an interface or union.

   For example, if we wanted to fetch some common information about mutual
   friends as well as friends of some user:
[363]Example No. 18query noFragments {
  user(id: 4) {
    friends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
    mutualFriends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
  }
}

   The repeated fields could be extracted into a fragment and composed by
   a parent fragment or operation.
[364]Example No. 19query withFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  profilePic(size: 50)
}

   Fragments are consumed by using the spread operator (...). All fields
   selected by the fragment will be added to the field selection at the
   same level as the fragment invocation. This happens through multiple
   levels of fragment spreads.

   For example:
[365]Example No. 20query withNestedFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  ...standardProfilePic
}

fragment standardProfilePic on User {
  profilePic(size: 50)
}

   The operations noFragments, withFragments, and withNestedFragments all
   produce the same response object.

  [366]2.8.1Type Conditions

   [367]TypeCondition
   on[368]NamedType

   Fragments must specify the type they apply to. In this example,
   friendFields can be used in the context of querying a User.

   Fragments cannot be specified on any input value (scalar, enumeration,
   or input object).

   Fragments can be specified on object types, interfaces, and unions.

   Selections within fragments only return values when the concrete type
   of the object it is operating on matches the type of the fragment.

   For example in this operation using the Facebook data model:
[369]Example No. 21query FragmentTyping {
  profiles(handles: ["zuck", "coca-cola"]) {
    handle
    ...userFragment
    ...pageFragment
  }
}

fragment userFragment on User {
  friends {
    count
  }
}

fragment pageFragment on Page {
  likers {
    count
  }
}

   The profiles root field returns a list where each element could be a
   Page or a User. When the object in the profiles result is a User,
   friends will be present and likers will not. Conversely when the result
   is a Page, likers will be present and friends will not.
[370]Example No. 22{
  "profiles": [
    {
      "handle": "zuck",
      "friends": { "count": 1234 }
    },
    {
      "handle": "coca-cola",
      "likers": { "count": 90234512 }
    }
  ]
}

  [371]2.8.2Inline Fragments

   [372]InlineFragment
   ...[373]TypeConditionopt[374]Directivesopt[375]SelectionSet

   Fragments can be defined inline within a selection set. This is done to
   conditionally include fields based on their runtime type. This feature
   of standard fragment inclusion was demonstrated in the query
   FragmentTyping example. We could accomplish the same thing using inline
   fragments.
[376]Example No. 23query inlineFragmentTyping {
  profiles(handles: ["zuck", "coca-cola"]) {
    handle
    ... on User {
      friends {
        count
      }
    }
    ... on Page {
      likers {
        count
      }
    }
  }
}

   Inline fragments may also be used to apply a directive to a group of
   fields. If the TypeCondition is omitted, an inline fragment is
   considered to be of the same type as the enclosing context.
[377]Example No. 24query inlineFragmentNoType($expandedInfo: Boolean) {
  user(handle: "zuck") {
    id
    name
    ... @include(if: $expandedInfo) {
      firstName
      lastName
      birthday
    }
  }
}

[378]2.9Input Values

   [379]ValueConst
   Const[380]Variable
   [381]IntValue
   [382]FloatValue
   [383]StringValue
   [384]BooleanValue
   [385]NullValue
   [386]EnumValue
   [387]ListValueConst
   [388]ObjectValueConst

   Field and directive arguments accept input values of various literal
   primitives; input values can be scalars, enumeration values, lists, or
   input objects.

   If not defined as constant (for example, in [389]DefaultValue), input
   values can be specified as a variable. List and inputs objects may also
   contain variables (unless defined to be constant).

  [390]2.9.1Int Value

   [391]IntValue
   [392]IntegerPart[393]Digit.[394]NameStart

   [395]IntegerPart
   [396]NegativeSignopt0
   [397]NegativeSignopt[398]NonZeroDigit[399]Digitlistopt

   [400]NegativeSign
   -

   [401]NonZeroDigit
   [402]Digit0

   An [403]IntValue is specified without a decimal point or exponent but
   may be negative (ex. -123). It must not have any leading 0.

   An [404]IntValue must not be followed by a [405]Digit. In other words,
   an [406]IntValue token is always the longest possible valid sequence.
   The source characters 12 cannot be interpreted as two tokens since 1 is
   followed by the [407]Digit 2. This also means the source 00 is invalid
   since it can neither be interpreted as a single token nor two 0 tokens.

   An [408]IntValue must not be followed by a . or [409]NameStart. If
   either . or [410]ExponentIndicator follows then the token must only be
   interpreted as a possible [411]FloatValue. No other [412]NameStart
   character can follow. For example the sequences 0x123 and 123L have no
   valid lexical representations.

  [413]2.9.2Float Value

   [414]FloatValue
   [415]IntegerPart[416]FractionalPart[417]ExponentPart[418]Digit.[419]Nam
   eStart
   [420]IntegerPart[421]FractionalPart[422]Digit.[423]NameStart
   [424]IntegerPart[425]ExponentPart[426]Digit.[427]NameStart

   [428]FractionalPart
   .[429]Digitlist

   [430]ExponentPart
   [431]ExponentIndicator[432]Signopt[433]Digitlist

   [434]ExponentIndicator
   e E

   [435]Sign
   + -

   A [436]FloatValue includes either a decimal point (ex. 1.0) or an
   exponent (ex. 1e50) or both (ex. 6.0221413e23) and may be negative.
   Like [437]IntValue, it also must not have any leading 0.

   A [438]FloatValue must not be followed by a [439]Digit. In other words,
   a [440]FloatValue token is always the longest possible valid sequence.
   The source characters 1.23 cannot be interpreted as two tokens since
   1.2 is followed by the [441]Digit 3.

   A [442]FloatValue must not be followed by a .. For example, the
   sequence 1.23.4 cannot be interpreted as two tokens (1.2, 3.4).

   A [443]FloatValue must not be followed by a [444]NameStart. For example
   the sequence 0x1.2p3 has no valid lexical representation.

   [445]Note The numeric literals [446]IntValue and [447]FloatValue both
   restrict being immediately followed by a letter (or other
   [448]NameStart) to reduce confusion or unexpected behavior since
   GraphQL only supports decimal numbers.

  [449]2.9.3Boolean Value

   [450]BooleanValue
   true false

   The two keywords true and false represent the two boolean values.

  [451]2.9.4String Value

   [452]StringValue
   """
   "[453]StringCharacterlist"
   """[454]BlockStringCharacterlistopt"""

   [455]StringCharacter
   [456]SourceCharacter"\[457]LineTerminator
   \u[458]EscapedUnicode
   \[459]EscapedCharacter

   [460]EscapedUnicode
   /[0-9A-Fa-f]{4}/

   [461]EscapedCharacter
   " \ / b f n r t

   [462]BlockStringCharacter
   [463]SourceCharacter"""\"""
   \"""

   Strings are sequences of characters wrapped in quotation marks
   (U+0022). (ex. "Hello World"). White space and other otherwise-ignored
   characters are significant within a string value.

   The empty string "" must not be followed by another " otherwise it
   would be interpreted as the beginning of a block string. As an example,
   the source """""" can only be interpreted as a single empty block
   string and not three empty strings.

   Non-ASCII Unicode characters are allowed within single-quoted strings.
   Since [464]SourceCharacter must not contain some ASCII control
   characters, escape sequences must be used to represent these
   characters. The \, " characters also must be escaped. All other escape
   sequences are optional.

        [465]Block Strings

   Block strings are sequences of characters wrapped in triple-quotes
   ("""). White space, line terminators, quote, and backslash characters
   may all be used unescaped to enable verbatim text. Characters must all
   be valid [466]SourceCharacter.

   Since block strings represent freeform text often used in indented
   positions, the string value semantics of a block string excludes
   uniform indentation and blank initial and trailing lines via
   [467]BlockStringValue().

   For example, the following operation containing a block string:
[468]Example No. 25mutation {
  sendEmail(message: """
    Hello,
      World!

    Yours,
      GraphQL.
  """)
}

   Is identical to the standard quoted string:
[469]Example No. 26mutation {
  sendEmail(message: "Hello,\n  World!\n\nYours,\n  GraphQL.")
}

   Since block string values strip leading and trailing empty lines, there
   is no single canonical printed block string for a given value. Because
   block strings typically represent freeform text, it is considered
   easier to read if they begin and end with an empty line.
[470]Example No. 27"""
This starts with and ends with an empty line,
which makes it easier to read.
"""

[471]Counter Example No. 28"""This does not start with or end with any empty lin
es,
which makes it a little harder to read."""

   [472]Note If non-printable ASCII characters are needed in a string
   value, a standard quoted string with appropriate escape sequences must
   be used instead of a block string.

        [473]Semantics

   [474]StringValue
   ""
    1. Return an empty sequence.

   [475]StringValue
   "[476]StringCharacterlist"
    1. Return the sequence of all [477]StringCharacter code points.

   [478]StringCharacter
   [479]SourceCharacter"\[480]LineTerminator
    1. Return the code point [481]SourceCharacter.

   [482]StringCharacter
   \u[483]EscapedUnicode
    1. Let value be the 16-bit hexadecimal value represented by the
       sequence of hexadecimal digits within [484]EscapedUnicode.
    2. Return the code point value.

   [485]StringCharacter
   \[486]EscapedCharacter
    1. Return the code point represented by [487]EscapedCharacter
       according to the table below.

   Escaped Character Code Point        Character Name
   "                 U+0022     double quote
   \                 U+005C     reverse solidus (back slash)
   /                 U+002F     solidus (forward slash)
   b                 U+0008     backspace
   f                 U+000C     form feed
   n                 U+000A     line feed (new line)
   r                 U+000D     carriage return
   t                 U+0009     horizontal tab

   [488]StringValue
   """[489]BlockStringCharacterlistopt"""
    1. Let rawValue be the Unicode character sequence of all
       [490]BlockStringCharacter Unicode character values (which may be an
       empty sequence).
    2. Return the result of [491]BlockStringValue(rawValue).

   [492]BlockStringCharacter
   [493]SourceCharacter"""\"""
    1. Return the character value of [494]SourceCharacter.

   [495]BlockStringCharacter
   \"""
    1. Return the character sequence """.

   [496]BlockStringValue(rawValue)
    1. Let lines be the result of splitting rawValue by
       [497]LineTerminator.
    2. Let commonIndent be null.
    3. For each line in lines:
         1. If line is the first item in lines, continue to the next line.
         2. Let length be the number of characters in line.
         3. Let indent be the number of leading consecutive
            [498]WhiteSpace characters in line.
         4. If indent is less than length:
              1. If commonIndent is null or indent is less than
                 commonIndent:
                   1. Let commonIndent be indent.
    4. If commonIndent is not null:
         1. For each line in lines:
              1. If line is the first item in lines, continue to the next
                 line.
              2. Remove commonIndent characters from the beginning of
                 line.
    5. While the first item line in lines contains only [499]WhiteSpace:
         1. Remove the first item from lines.
    6. While the last item line in lines contains only [500]WhiteSpace:
         1. Remove the last item from lines.
    7. Let formatted be the empty character sequence.
    8. For each line in lines:
         1. If line is the first item in lines:
              1. Append formatted with line.
         2. Otherwise:
              1. Append formatted with a line feed character (U+000A).
              2. Append formatted with line.
    9. Return formatted.

  [501]2.9.5Null Value

   [502]NullValue
   null

   Null values are represented as the keyword null.

   GraphQL has two semantically different ways to represent the lack of a
   value:
     * Explicitly providing the literal value: null.
     * Implicitly not providing a value at all.

   For example, these two field calls are similar, but are not identical:
[503]Example No. 29{
  field(arg: null)
  field
}

   The first has explicitly provided null to the argument "arg", while the
   second has implicitly not provided a value to the argument "arg". These
   two forms may be interpreted differently. For example, a mutation
   representing deleting a field vs not altering a field, respectively.
   Neither form may be used for an input expecting a Non-Null type.

   [504]Note The same two methods of representing the lack of a value are
   possible via variables by either providing the variable value as null
   or not providing a variable value at all.

  [505]2.9.6Enum Value

   [506]EnumValue
   [507]Nametruefalsenull

   Enum values are represented as unquoted names (ex. MOBILE_WEB). It is
   recommended that Enum values be "all caps". Enum values are only used
   in contexts where the precise enumeration type is known. Therefore it's
   not necessary to supply an enumeration type name in the literal.

  [508]2.9.7List Value

   [509]ListValueConst
   []
   [[510]ValueConstlist]

   Lists are ordered sequences of values wrapped in square-brackets [ ].
   The values of a List literal may be any value literal or variable (ex.
   [1, 2, 3]).

   Commas are optional throughout GraphQL so trailing commas are allowed
   and repeated commas do not represent missing values.

        [511]Semantics

   [512]ListValue
   []
    1. Return a new empty list value.

   [513]ListValue
   [[514]Valuelist]
    1. Let inputList be a new empty list value.
    2. For each [515]Valuelist
         1. Let value be the result of evaluating [516]Value.
         2. Append value to inputList.
    3. Return inputList

  [517]2.9.8Input Object Values

   [518]ObjectValueConst
   {}
   {[519]ObjectFieldConstlist}

   [520]ObjectFieldConst
   [521]Name:[522]ValueConst

   Input object literal values are unordered lists of keyed input values
   wrapped in curly-braces { }. The values of an object literal may be any
   input value literal or variable (ex. { name: "Hello world", score: 1.0
   }). We refer to literal representation of input objects as "object
   literals."

        [523]Input object fields are unordered

   Input object fields may be provided in any syntactic order and maintain
   identical semantic meaning.

   These two operations are semantically identical:
[524]Example No. 30{
  nearestThing(location: { lon: 12.43, lat: -53.211 })
}

[525]Example No. 31{
  nearestThing(location: { lat: -53.211, lon: 12.43 })
}

        [526]Semantics

   [527]ObjectValue
   {}
    1. Return a new input object value with no fields.

   [528]ObjectValue
   {[529]ObjectFieldlist}
    1. Let inputObject be a new input object value with no fields.
    2. For each field in [530]ObjectFieldlist
         1. Let name be [531]Name in field.
         2. Let value be the result of evaluating [532]Value in field.
         3. Add a field to inputObject of name name containing value
            value.
    3. Return inputObject

[533]2.10Variables

   [534]Variable
   $[535]Name

   [536]VariableDefinitions
   ([537]VariableDefinitionlist)

   [538]VariableDefinition
   [539]Variable:[540]Type[541]DefaultValueopt[542]DirectivesConstopt

   [543]DefaultValue
   =[544]ValueConst

   A GraphQL operation can be parameterized with variables, maximizing
   reuse, and avoiding costly string building in clients at runtime.

   If not defined as constant (for example, in [545]DefaultValue), a
   [546]Variable can be supplied for an input value.

   Variables must be defined at the top of an operation and are in scope
   throughout the execution of that operation. Values for those variables
   are provided to a GraphQL service as part of a request so they may be
   substituted in during execution.

   In this example, we want to fetch a profile picture size based on the
   size of a particular device:
[547]Example No. 32query getZuckProfile($devicePicSize: Int) {
  user(id: 4) {
    id
    name
    profilePic(size: $devicePicSize)
  }
}

   If providing JSON for the variables' values, we could request a
   profilePic of size 60:
[548]Example No. 33{
  "devicePicSize": 60
}

        [549]Variable use within Fragments

   Variables can be used within fragments. Variables have global scope
   with a given operation, so a variable used within a fragment must be
   declared in any top-level operation that transitively consumes that
   fragment. If a variable is referenced in a fragment and is included by
   an operation that does not define that variable, that operation is
   invalid (see [550]All Variable Uses Defined).

[551]2.11Type References

   [552]Type
   [553]NamedType
   [554]ListType
   [555]NonNullType

   [556]NamedType
   [557]Name

   [558]ListType
   [[559]Type]

   [560]NonNullType
   [561]NamedType!
   [562]ListType!

   GraphQL describes the types of data expected by arguments and
   variables. Input types may be lists of another input type, or a
   non-null variant of any other input type.

        [563]Semantics

   [564]Type
   [565]Name
    1. Let name be the string value of [566]Name
    2. Let type be the type defined in the Schema named name
    3. type must not be null
    4. Return type

   [567]Type
   [[568]Type]
    1. Let itemType be the result of evaluating [569]Type
    2. Let type be a List type where itemType is the contained type.
    3. Return type

   [570]Type
   [571]Type!
    1. Let nullableType be the result of evaluating [572]Type
    2. Let type be a Non-Null type where nullableType is the contained
       type.
    3. Return type

[573]2.12Directives

   [574]DirectivesConst
   [575]DirectiveConstlist

   [576]DirectiveConst
   @[577]Name[578]ArgumentsConstopt

   Directives provide a way to describe alternate runtime execution and
   type validation behavior in a GraphQL document.

   In some cases, you need to provide options to alter GraphQL's execution
   behavior in ways field arguments will not suffice, such as
   conditionally including or skipping a field. Directives provide this by
   describing additional information to the executor.

   Directives have a name along with a list of arguments which may accept
   values of any input type.

   Directives can be used to describe additional information for types,
   fields, fragments and operations.

   As future versions of GraphQL adopt new configurable execution
   capabilities, they may be exposed via directives. GraphQL services and
   tools may also provide any additional [579]custom directive beyond
   those described here.

        [580]Directive order is significant

   Directives may be provided in a specific syntactic order which may have
   semantic interpretation.

   These two type definitions may have different semantic meaning:
[581]Example No. 34type Person
  @addExternalFields(source: "profiles")
  @excludeField(name: "photo") {
  name: String
}

[582]Example No. 35type Person
  @excludeField(name: "photo")
  @addExternalFields(source: "profiles") {
  name: String
}

                               [583]3Type System

   The GraphQL Type system describes the capabilities of a GraphQL service
   and is used to determine if a requested operation is valid, to
   guarantee the type of response results, and describes the input types
   of variables to determine if values provided at request time are valid.

   [584]TypeSystemDocument
   [585]TypeSystemDefinitionlist

   [586]TypeSystemDefinition
   [587]SchemaDefinition
   [588]TypeDefinition
   [589]DirectiveDefinition

   The GraphQL language includes an [590]IDL used to describe a GraphQL
   service's type system. Tools may use this definition language to
   provide utilities such as client code generation or service
   boot-strapping.

   GraphQL tools or services which only seek to execute GraphQL requests
   and not construct a new GraphQL schema may choose not to allow
   [591]TypeSystemDefinition. Tools which only seek to produce schema and
   not execute requests may choose to only allow [592]TypeSystemDocument
   and not allow [593]ExecutableDefinition or [594]TypeSystemExtension but
   should provide a descriptive error if present.

   [595]Note The type system definition language is used throughout the
   remainder of this specification document when illustrating example type
   systems.

[596]3.1Type System Extensions

   [597]TypeSystemExtensionDocument
   [598]TypeSystemDefinitionOrExtensionlist

   [599]TypeSystemDefinitionOrExtension
   [600]TypeSystemDefinition
   [601]TypeSystemExtension

   [602]TypeSystemExtension
   [603]SchemaExtension
   [604]TypeExtension

   Type system extensions are used to represent a GraphQL type system
   which has been extended from some original type system. For example,
   this might be used by a local service to represent data a GraphQL
   client only accesses locally, or by a GraphQL service which is itself
   an extension of another GraphQL service.

   Tools which only seek to produce and extend schema and not execute
   requests may choose to only allow [605]TypeSystemExtensionDocument and
   not allow [606]ExecutableDefinition but should provide a descriptive
   error if present.

[607]3.2Descriptions

   [608]Description
   [609]StringValue

   Documentation is a first-class feature of GraphQL type systems. To
   ensure the documentation of a GraphQL service remains consistent with
   its capabilities, descriptions of GraphQL definitions are provided
   alongside their definitions and made available via introspection.

   To allow GraphQL service designers to easily publish documentation
   alongside the capabilities of a GraphQL service, GraphQL descriptions
   are defined using the Markdown syntax (as specified by
   [610]CommonMark). In the type system definition language, these
   description strings (often BlockString) occur immediately before the
   definition they describe.

   GraphQL schema and all other definitions (e.g. types, fields,
   arguments, etc.) which can be described should provide a
   [611]Description unless they are considered self descriptive.

   As an example, this simple GraphQL schema is well described:
[612]Example No. 36"""
A simple GraphQL schema which is well described.
"""
schema {
  query: Query
}

"""
Root type for all your query operations
"""
type Query {
  """
  Translates a string from a given language into a different language.
  """
  translate(
    "The original language that `text` is provided in."
    fromLanguage: Language

    "The translated language to be returned."
    toLanguage: Language

    "The text to be translated."
    text: String
  ): String
}

"""
The set of languages supported by `translate`.
"""
enum Language {
  "English"
  EN

  "French"
  FR

  "Chinese"
  CH
}

[613]3.3Schema

   [614]SchemaDefinition
   [615]Descriptionoptschema[616]DirectivesConstopt{[617]RootOperationType
   Definitionlist}

   [618]RootOperationTypeDefinition
   [619]OperationType:[620]NamedType

   A GraphQL service's collective type system capabilities are referred to
   as that service's "schema". A schema is defined in terms of the types
   and directives it supports as well as the root operation types for each
   kind of operation: query, mutation, and subscription; this determines
   the place in the type system where those operations begin.

   A GraphQL schema must itself be internally valid. This section
   describes the rules for this validation process where relevant.

   All types within a GraphQL schema must have unique names. No two
   provided types may have the same name. No provided type may have a name
   which conflicts with any built in types (including Scalar and
   Introspection types).

   All directives within a GraphQL schema must have unique names.

   All types and directives defined within a schema must not have a name
   which begins with "__" (two underscores), as this is used exclusively
   by GraphQL's introspection system.

  [621]3.3.1Root Operation Types

   A schema defines the initial root operation type for each kind of
   operation it supports: query, mutation, and subscription; this
   determines the place in the type system where those operations begin.

   The query root operation type must be provided and must be an Object
   type.

   The mutation root operation type is optional; if it is not provided,
   the service does not support mutations. If it is provided, it must be
   an Object type.

   Similarly, the subscription root operation type is also optional; if it
   is not provided, the service does not support subscriptions. If it is
   provided, it must be an Object type.

   The query, mutation, and subscription root types must all be different
   types if provided.

   The fields on the query root operation type indicate what fields are
   available at the top level of a GraphQL query operation.

   For example, this example operation:
[622]Example No. 37query {
  myName
}

   is only valid when the query root operation type has a field named
   "myName":
[623]Example No. 38type Query {
  myName: String
}

   Similarly, the following mutation is only valid if the mutation root
   operation type has a field named "setName".
[624]Example No. 39mutation {
  setName(name: "Zuck") {
    newName
  }
}

   When using the type system definition language, a document must include
   at most one schema definition.

   In this example, a GraphQL schema is defined with both query and
   mutation root operation types:
[625]Example No. 40schema {
  query: MyQueryRootType
  mutation: MyMutationRootType
}

type MyQueryRootType {
  someField: String
}

type MyMutationRootType {
  setSomeField(to: String): String
}

        [626]Default Root Operation Type Names

   While any type can be the root operation type for a GraphQL operation,
   the type system definition language can omit the schema definition when
   the query, mutation, and subscription root types are named "Query",
   "Mutation", and "Subscription" respectively.

   Likewise, when representing a GraphQL schema using the type system
   definition language, a schema definition should be omitted if it only
   uses the default root operation type names.

   This example describes a valid complete GraphQL schema, despite not
   explicitly including a schema definition. The "Query" type is presumed
   to be the query root operation type of the schema.
[627]Example No. 41type Query {
  someField: String
}

  [628]3.3.2Schema Extension

   [629]SchemaExtension
   extendschema[630]DirectivesConstopt{[631]RootOperationTypeDefinitionlis
   t}
   extendschema[632]DirectivesConst{

   Schema extensions are used to represent a schema which has been
   extended from an original schema. For example, this might be used by a
   GraphQL service which adds additional operation types, or additional
   directives to an existing schema.

   [633]Note Schema extensions without additional operation type
   definitions must not be followed by a { (such as a query shorthand) to
   avoid parsing ambiguity. The same limitation applies to the type
   definitions and extensions below.

        [634]Schema Validation

   Schema extensions have the potential to be invalid if incorrectly
   defined.
    1. The Schema must already be defined.
    2. Any non-repeatable directives provided must not already apply to
       the original Schema.

[635]3.4Types

   [636]TypeDefinition
   [637]ScalarTypeDefinition
   [638]ObjectTypeDefinition
   [639]InterfaceTypeDefinition
   [640]UnionTypeDefinition
   [641]EnumTypeDefinition
   [642]InputObjectTypeDefinition

   The fundamental unit of any GraphQL Schema is the type. There are six
   kinds of named type definitions in GraphQL, and two wrapping types.

   The most basic type is a Scalar. A scalar represents a primitive value,
   like a string or an integer. Oftentimes, the possible responses for a
   scalar field are enumerable. GraphQL offers an Enum type in those
   cases, where the type specifies the space of valid responses.

   Scalars and Enums form the leaves in response trees; the intermediate
   levels are Object types, which define a set of fields, where each field
   is another type in the system, allowing the definition of arbitrary
   type hierarchies.

   GraphQL supports two abstract types: interfaces and unions.

   An Interface defines a list of fields; Object types and other Interface
   types which implement this Interface are guaranteed to implement those
   fields. Whenever a field claims it will return an Interface type, it
   will return a valid implementing Object type during execution.

   A Union defines a list of possible types; similar to interfaces,
   whenever the type system claims a union will be returned, one of the
   possible types will be returned.

   Finally, oftentimes it is useful to provide complex structs as inputs
   to GraphQL field arguments or variables; the Input Object type allows
   the schema to define exactly what data is expected.

  [643]3.4.1Wrapping Types

   All of the types so far are assumed to be both nullable and singular:
   e.g. a scalar string returns either null or a singular string.

   A GraphQL schema may describe that a field represents a list of another
   type; the List type is provided for this reason, and wraps another
   type.

   Similarly, the Non-Null type wraps another type, and denotes that the
   resulting value will never be null (and that a field error cannot
   result in a null value).

   These two types are referred to as "wrapping types"; non-wrapping types
   are referred to as "named types". A wrapping type has an underlying
   named type, found by continually unwrapping the type until a named type
   is found.

  [644]3.4.2Input and Output Types

   Types are used throughout GraphQL to describe both the values accepted
   as input to arguments and variables as well as the values output by
   fields. These two uses categorize types as input types and output
   types. Some kinds of types, like Scalar and Enum types, can be used as
   both input types and output types; other kinds of types can only be
   used in one or the other. Input Object types can only be used as input
   types. Object, Interface, and Union types can only be used as output
   types. Lists and Non-Null types may be used as input types or output
   types depending on how the wrapped type may be used.

   [645]IsInputType(type)
    1. If type is a List type or Non-Null type:
         1. Let unwrappedType be the unwrapped type of type.
         2. Return IsInputType(unwrappedType)
    2. If type is a Scalar, Enum, or Input Object type:
         1. Return true
    3. Return false

   [646]IsOutputType(type)
    1. If type is a List type or Non-Null type:
         1. Let unwrappedType be the unwrapped type of type.
         2. Return IsOutputType(unwrappedType)
    2. If type is a Scalar, Object, Interface, Union, or Enum type:
         1. Return true
    3. Return false

  [647]3.4.3Type Extensions

   [648]TypeExtension
   [649]ScalarTypeExtension
   [650]ObjectTypeExtension
   [651]InterfaceTypeExtension
   [652]UnionTypeExtension
   [653]EnumTypeExtension
   [654]InputObjectTypeExtension

   Type extensions are used to represent a GraphQL type which has been
   extended from some original type. For example, this might be used by a
   local service to represent additional fields a GraphQL client only
   accesses locally.

[655]3.5Scalars

   [656]ScalarTypeDefinition
   [657]Descriptionoptscalar[658]Name[659]DirectivesConstopt

   Scalar types represent primitive leaf values in a GraphQL type system.
   GraphQL responses take the form of a hierarchical tree; the leaves of
   this tree are typically GraphQL Scalar types (but may also be Enum
   types or null values).

   GraphQL provides a number of built-in scalars which are fully defined
   in the sections below, however type systems may also add additional
   custom scalars to introduce additional semantic meaning.

        [660]Built-in Scalars

   GraphQL specifies a basic set of well-defined Scalar types: Int, Float,
   String, Boolean, and ID. A GraphQL framework should support all of
   these types, and a GraphQL service which provides a type by these names
   must adhere to the behavior described for them in this document. As an
   example, a service must not include a type called Int and use it to
   represent 64-bit numbers, internationalization information, or anything
   other than what is defined in this document.

   When returning the set of types from the __Schema introspection type,
   all referenced built-in scalars must be included. If a built-in scalar
   type is not referenced anywhere in a schema (there is no field,
   argument, or input field of that type) then it must not be included.

   When representing a GraphQL schema using the type system definition
   language, all built-in scalars must be omitted for brevity.

        [661]Custom Scalars

   GraphQL services may use custom scalar types in addition to the
   built-in scalars. For example, a GraphQL service could define a scalar
   called UUID which, while serialized as a string, conforms to [662]RFC
   4122. When querying a field of type UUID, you can then rely on the
   ability to parse the result with a RFC 4122 compliant parser. Another
   example of a potentially useful custom scalar is URL, which serializes
   as a string, but is guaranteed by the server to be a valid URL.

   When defining a custom scalar, GraphQL services should provide a
   [663]scalar specification URL via the @specifiedBy directive or the
   specifiedByURL introspection field. This URL must link to a
   human-readable specification of the data format, serialization, and
   coercion rules for the scalar.

   For example, a GraphQL service providing a UUID scalar may link to RFC
   4122, or some custom document defining a reasonable subset of that RFC.
   If a [664]scalar specification URL is present, systems and tools that
   are aware of it should conform to its described rules.
[665]Example No. 42scalar UUID @specifiedBy(url: "https://tools.ietf.org/html/rf
c4122")
scalar URL @specifiedBy(url: "https://tools.ietf.org/html/rfc3986")

   Custom [666]scalar specification URLs should provide a single, stable
   format to avoid ambiguity. If the linked specification is in flux, the
   service should link to a fixed version rather than to a resource which
   might change.

   Custom [667]scalar specification URLs should not be changed once
   defined. Doing so would likely disrupt tooling or could introduce
   breaking changes within the linked specification's contents.

   Built-in scalar types must not provide a [668]scalar specification URL
   as they are specified by this document.

   [669]Note Custom scalars should also summarize the specified format and
   provide examples in their description.

        [670]Result Coercion and Serialization

   A GraphQL service, when preparing a field of a given scalar type, must
   uphold the contract the scalar type describes, either by coercing the
   value or producing a [671]field error if a value cannot be coerced or
   if coercion may result in data loss.

   A GraphQL service may decide to allow coercing different internal types
   to the expected return type. For example when coercing a field of type
   Int a boolean true value may produce 1 or a string value "123" may be
   parsed as base-10 123. However if internal type coercion cannot be
   reasonably performed without losing information, then it must raise a
   field error.

   Since this coercion behavior is not observable to clients of the
   GraphQL service, the precise rules of coercion are left to the
   implementation. The only requirement is that the service must yield
   values which adhere to the expected Scalar type.

   GraphQL scalars are serialized according to the serialization format
   being used. There may be a most appropriate serialized primitive for
   each given scalar type, and the service should produce each primitive
   where appropriate.

   See [672]Serialization Format for more detailed information on the
   serialization of scalars in common JSON and other formats.

        [673]Input Coercion

   If a GraphQL service expects a scalar type as input to an argument,
   coercion is observable and the rules must be well defined. If an input
   value does not match a coercion rule, a [674]request error must be
   raised (input values are validated before execution begins).

   GraphQL has different constant literals to represent integer and
   floating-point input values, and coercion rules may apply differently
   depending on which type of input value is encountered. GraphQL may be
   parameterized by variables, the values of which are often serialized
   when sent over a transport like HTTP. Since some common serializations
   (ex. JSON) do not discriminate between integer and floating-point
   values, they are interpreted as an integer input value if they have an
   empty fractional part (ex. 1.0) and otherwise as floating-point input
   value.

   For all types below, with the exception of Non-Null, if the explicit
   value null is provided, then the result of input coercion is null.

  [675]3.5.1Int

   The Int scalar type represents a signed 32-bit numeric non-fractional
   value. Response formats that support a 32-bit integer or a number type
   should use that type to represent this scalar.

        [676]Result Coercion

   Fields returning the type Int expect to encounter 32-bit integer
   internal values.

   GraphQL services may coerce non-integer internal values to integers
   when reasonable without losing information, otherwise they must raise a
   field error. Examples of this may include returning 1 for the
   floating-point number 1.0, or returning 123 for the string "123". In
   scenarios where coercion may lose data, raising a field error is more
   appropriate. For example, a floating-point number 1.2 should raise a
   field error instead of being truncated to 1.

   If the integer internal value represents a value less than -2^31 or
   greater than or equal to 2^31, a field error should be raised.

        [677]Input Coercion

   When expected as an input type, only integer input values are accepted.
   All other input values, including strings with numeric content, must
   raise a request error indicating an incorrect type. If the integer
   input value represents a value less than -2^31 or greater than or equal
   to 2^31, a request error should be raised.

   [678]Note Numeric integer values larger than 32-bit should either use
   String or a custom-defined Scalar type, as not all platforms and
   transports support encoding integer numbers larger than 32-bit.

  [679]3.5.2Float

   The Float scalar type represents signed double-precision finite values
   as specified by [680]IEEE 754. Response formats that support an
   appropriate double-precision number type should use that type to
   represent this scalar.

        [681]Result Coercion

   Fields returning the type Float expect to encounter double-precision
   floating-point internal values.

   GraphQL services may coerce non-floating-point internal values to Float
   when reasonable without losing information, otherwise they must raise a
   field error. Examples of this may include returning 1.0 for the integer
   number 1, or 123.0 for the string "123".

   Non-finite floating-point internal values (NaN and Infinity) cannot be
   coerced to Float and must raise a field error.

        [682]Input Coercion

   When expected as an input type, both integer and float input values are
   accepted. Integer input values are coerced to Float by adding an empty
   fractional part, for example 1.0 for the integer input value 1. All
   other input values, including strings with numeric content, must raise
   a request error indicating an incorrect type. If the input value
   otherwise represents a value not representable by finite IEEE 754 (e.g.
   NaN, Infinity, or a value outside the available precision), a request
   error must be raised.

  [683]3.5.3String

   The String scalar type represents textual data, represented as a
   sequence of Unicode code points. The String type is most often used by
   GraphQL to represent free-form human-readable text. How the String is
   encoded internally (for example UTF-8) is left to the service
   implementation. All response serialization formats must support a
   string representation (for example, JSON Unicode strings), and that
   representation must be used to serialize this type.

        [684]Result Coercion

   Fields returning the type String expect to encounter Unicode string
   values.

   GraphQL services may coerce non-string raw values to String when
   reasonable without losing information, otherwise they must raise a
   field error. Examples of this may include returning the string "true"
   for a boolean true value, or the string "1" for the integer 1.

        [685]Input Coercion

   When expected as an input type, only valid Unicode string input values
   are accepted. All other input values must raise a request error
   indicating an incorrect type.

  [686]3.5.4Boolean

   The Boolean scalar type represents true or false. Response formats
   should use a built-in boolean type if supported; otherwise, they should
   use their representation of the integers 1 and 0.

        [687]Result Coercion

   Fields returning the type Boolean expect to encounter boolean internal
   values.

   GraphQL services may coerce non-boolean raw values to Boolean when
   reasonable without losing information, otherwise they must raise a
   field error. Examples of this may include returning true for non-zero
   numbers.

        [688]Input Coercion

   When expected as an input type, only boolean input values are accepted.
   All other input values must raise a request error indicating an
   incorrect type.

  [689]3.5.5ID

   The ID scalar type represents a unique identifier, often used to
   refetch an object or as the key for a cache. The ID type is serialized
   in the same way as a String; however, it is not intended to be
   human-readable. While it is often numeric, it should always serialize
   as a String.

        [690]Result Coercion

   GraphQL is agnostic to ID format, and serializes to string to ensure
   consistency across many formats ID could represent, from small
   auto-increment numbers, to large 128-bit random numbers, to base64
   encoded values, or string values of a format like [691]GUID.

   GraphQL services should coerce as appropriate given the ID formats they
   expect. When coercion is not possible they must raise a field error.

        [692]Input Coercion

   When expected as an input type, any string (such as "4") or integer
   (such as 4 or -4) input value should be coerced to ID as appropriate
   for the ID formats a given GraphQL service expects. Any other input
   value, including float input values (such as 4.0), must raise a request
   error indicating an incorrect type.

  [693]3.5.6Scalar Extensions

   [694]ScalarTypeExtension
   extendscalar[695]Name[696]DirectivesConst

   Scalar type extensions are used to represent a scalar type which has
   been extended from some original scalar type. For example, this might
   be used by a GraphQL tool or service which adds directives to an
   existing scalar.

        [697]Type Validation

   Scalar type extensions have the potential to be invalid if incorrectly
   defined.
    1. The named type must already be defined and must be a Scalar type.
    2. Any non-repeatable directives provided must not already apply to
       the original Scalar type.

[698]3.6Objects

   [699]ObjectTypeDefinition
   [700]Descriptionopttype[701]Name[702]ImplementsInterfacesopt[703]Direct
   ivesConstopt[704]FieldsDefinition
   [705]Descriptionopttype[706]Name[707]ImplementsInterfacesopt[708]Direct
   ivesConstopt{

   [709]ImplementsInterfaces
   [710]ImplementsInterfaces&[711]NamedType
   implements&opt[712]NamedType

   [713]FieldsDefinition
   {[714]FieldDefinitionlist}

   [715]FieldDefinition
   [716]Descriptionopt[717]Name[718]ArgumentsDefinitionopt:[719]Type[720]D
   irectivesConstopt

   GraphQL operations are hierarchical and composed, describing a tree of
   information. While Scalar types describe the leaf values of these
   hierarchical operations, Objects describe the intermediate levels.

   GraphQL Objects represent a list of named fields, each of which yield a
   value of a specific type. Object values should be serialized as ordered
   maps, where the selected field names (or aliases) are the keys and the
   result of evaluating the field is the value, ordered by the order in
   which they appear in the selection set.

   All fields defined within an Object type must not have a name which
   begins with "__" (two underscores), as this is used exclusively by
   GraphQL's introspection system.

   For example, a type Person could be described as:
[721]Example No. 43type Person {
  name: String
  age: Int
  picture: Url
}

   Where name is a field that will yield a String value, and age is a
   field that will yield an Int value, and picture is a field that will
   yield a Url value.

   A query of an object value must select at least one field. This
   selection of fields will yield an ordered map containing exactly the
   subset of the object queried, which should be represented in the order
   in which they were queried. Only fields that are declared on the object
   type may validly be queried on that object.

   For example, selecting all the fields of Person:
[722]Example No. 44{
  name
  age
  picture
}

   Would yield the object:
[723]Example No. 45{
  "name": "Mark Zuckerberg",
  "age": 30,
  "picture": "http://some.cdn/picture.jpg"
}

   While selecting a subset of fields:
[724]Example No. 46{
  age
  name
}

   Must only yield exactly that subset:
[725]Example No. 47{
  "age": 30,
  "name": "Mark Zuckerberg"
}

   A field of an Object type may be a Scalar, Enum, another Object type,
   an Interface, or a Union. Additionally, it may be any wrapping type
   whose underlying base type is one of those five.

   For example, the Person type might include a relationship:
[726]Example No. 48type Person {
  name: String
  age: Int
  picture: Url
  relationship: Person
}

   Valid operations must supply a nested field set for any field that
   returns an object, so this operation is not valid:
[727]Counter Example No. 49{
  name
  relationship
}

   However, this example is valid:
[728]Example No. 50{
  name
  relationship {
    name
  }
}

   And will yield the subset of each object type queried:
[729]Example No. 51{
  "name": "Mark Zuckerberg",
  "relationship": {
    "name": "Priscilla Chan"
  }
}

        [730]Field Ordering

   When querying an Object, the resulting mapping of fields are
   conceptually ordered in the same order in which they were encountered
   during execution, excluding fragments for which the type does not apply
   and fields or fragments that are skipped via @skip or @include
   directives. This ordering is correctly produced when using the
   [731]CollectFields() algorithm.

   Response serialization formats capable of representing ordered maps
   should maintain this ordering. Serialization formats which can only
   represent unordered maps (such as JSON) should retain this order
   textually. That is, if two fields {foo, bar} were queried in that
   order, the resulting JSON serialization should contain {"foo": "...",
   "bar": "..."} in the same order.

   Producing a response where fields are represented in the same order in
   which they appear in the request improves human readability during
   debugging and enables more efficient parsing of responses if the order
   of properties can be anticipated.

   If a fragment is spread before other fields, the fields that fragment
   specifies occur in the response before the following fields.
[732]Example No. 52{
  foo
  ...Frag
  qux
}

fragment Frag on Query {
  bar
  baz
}

   Produces the ordered result:
[733]Example No. 53{
  "foo": 1,
  "bar": 2,
  "baz": 3,
  "qux": 4
}

   If a field is queried multiple times in a selection, it is ordered by
   the first time it is encountered. However fragments for which the type
   does not apply does not affect ordering.
[734]Example No. 54{
  foo
  ...Ignored
  ...Matching
  bar
}

fragment Ignored on UnknownType {
  qux
  baz
}

fragment Matching on Query {
  bar
  qux
  foo
}

   Produces the ordered result:
[735]Example No. 55{
  "foo": 1,
  "bar": 2,
  "qux": 3
}

   Also, if directives result in fields being excluded, they are not
   considered in the ordering of fields.
[736]Example No. 56{
  foo @skip(if: true)
  bar
  foo
}

   Produces the ordered result:
[737]Example No. 57{
  "bar": 1,
  "foo": 2
}

        [738]Result Coercion

   Determining the result of coercing an object is the heart of the
   GraphQL executor, so this is covered in that section of the spec.

        [739]Input Coercion

   Objects are never valid inputs.

        [740]Type Validation

   Object types have the potential to be invalid if incorrectly defined.
   This set of rules must be adhered to by every Object type in a GraphQL
   schema.
    1. An Object type must define one or more fields.
    2. For each field of an Object type:
         1. The field must have a unique name within that Object type; no
            two fields may share the same name.
         2. The field must not have a name which begins with the
            characters "__" (two underscores).
         3. The field must return a type where
            [741]IsOutputType(fieldType) returns true.
         4. For each argument of the field:
              1. The argument must not have a name which begins with the
                 characters "__" (two underscores).
              2. The argument must accept a type where
                 [742]IsInputType(argumentType) returns true.
    3. An object type may declare that it implements one or more unique
       interfaces.
    4. An object type must be a super-set of all interfaces it implements:
         1. Let this object type be objectType.
         2. For each interface declared implemented as interfaceType,
            [743]IsValidImplementation(objectType, interfaceType) must be
            true.

   [744]IsValidImplementation(type, implementedType)
    1. If implementedType declares it implements any interfaces, type must
       also declare it implements those interfaces.
    2. type must include a field of the same name for every field defined
       in implementedType.
         1. Let field be that named field on type.
         2. Let implementedField be that named field on implementedType.
         3. field must include an argument of the same name for every
            argument defined in implementedField.
              1. That named argument on field must accept the same type
                 (invariant) as that named argument on implementedField.
         4. field may include additional arguments not defined in
            implementedField, but any additional argument must not be
            required, e.g. must not be of a non-nullable type.
         5. field must return a type which is equal to or a sub-type of
            (covariant) the return type of implementedField field's return
            type:
              1. Let fieldType be the return type of field.
              2. Let implementedFieldType be the return type of
                 implementedField.
              3. [745]IsValidImplementationFieldType(fieldType,
                 implementedFieldType) must be true.

   [746]IsValidImplementationFieldType(fieldType, implementedFieldType)
    1. If fieldType is a Non-Null type:
         1. Let nullableType be the unwrapped nullable type of fieldType.
         2. Let implementedNullableType be the unwrapped nullable type of
            implementedFieldType if it is a Non-Null type, otherwise let
            it be implementedFieldType directly.
         3. Return [747]IsValidImplementationFieldType(nullableType,
            implementedNullableType).
    2. If fieldType is a List type and implementedFieldType is also a List
       type:
         1. Let itemType be the unwrapped item type of fieldType.
         2. Let implementedItemType be the unwrapped item type of
            implementedFieldType.
         3. Return [748]IsValidImplementationFieldType(itemType,
            implementedItemType).
    3. If fieldType is the same type as implementedFieldType then return
       true.
    4. If fieldType is an Object type and implementedFieldType is a Union
       type and fieldType is a possible type of implementedFieldType then
       return true.
    5. If fieldType is an Object or Interface type and
       implementedFieldType is an Interface type and fieldType declares it
       implements implementedFieldType then return true.
    6. Otherwise return false.

  [749]3.6.1Field Arguments

   [750]ArgumentsDefinition
   ([751]InputValueDefinitionlist)

   [752]InputValueDefinition
   [753]Descriptionopt[754]Name:[755]Type[756]DefaultValueopt[757]Directiv
   esConstopt

   Object fields are conceptually functions which yield values.
   Occasionally object fields can accept arguments to further specify the
   return value. Object field arguments are defined as a list of all
   possible argument names and their expected input types.

   All arguments defined within a field must not have a name which begins
   with "__" (two underscores), as this is used exclusively by GraphQL's
   introspection system.

   For example, a Person type with a picture field could accept an
   argument to determine what size of an image to return.
[758]Example No. 58type Person {
  name: String
  picture(size: Int): Url
}

   Operations can optionally specify arguments to their fields to provide
   these arguments.

   This example operation:
[759]Example No. 59{
  name
  picture(size: 600)
}

   May return the result:
[760]Example No. 60{
  "name": "Mark Zuckerberg",
  "picture": "http://some.cdn/picture_600.jpg"
}

   The type of an object field argument must be an input type (any type
   except an Object, Interface, or Union type).

  [761]3.6.2Field Deprecation

   Fields in an object may be marked as deprecated as deemed necessary by
   the application. It is still legal to include these fields in a
   selection set (to ensure existing clients are not broken by the
   change), but the fields should be appropriately treated in
   documentation and tooling.

   When using the type system definition language, @deprecated directives
   are used to indicate that a field is deprecated:
[762]Example No. 61type ExampleType {
  oldField: String @deprecated
}

  [763]3.6.3Object Extensions

   [764]ObjectTypeExtension
   extendtype[765]Name[766]ImplementsInterfacesopt[767]DirectivesConstopt[
   768]FieldsDefinition
   extendtype[769]Name[770]ImplementsInterfacesopt[771]DirectivesConst{
   extendtype[772]Name[773]ImplementsInterfaces{

   Object type extensions are used to represent a type which has been
   extended from some original type. For example, this might be used to
   represent local data, or by a GraphQL service which is itself an
   extension of another GraphQL service.

   In this example, a local data field is added to a Story type:
[774]Example No. 62extend type Story {
  isHiddenLocally: Boolean
}

   Object type extensions may choose not to add additional fields, instead
   only adding interfaces or directives.

   In this example, a directive is added to a User type without adding
   fields:
[775]Example No. 63extend type User @addedDirective

        [776]Type Validation

   Object type extensions have the potential to be invalid if incorrectly
   defined.
    1. The named type must already be defined and must be an Object type.
    2. The fields of an Object type extension must have unique names; no
       two fields may share the same name.
    3. Any fields of an Object type extension must not be already defined
       on the original Object type.
    4. Any non-repeatable directives provided must not already apply to
       the original Object type.
    5. Any interfaces provided must not be already implemented by the
       original Object type.
    6. The resulting extended object type must be a super-set of all
       interfaces it implements.

[777]3.7Interfaces

   [778]InterfaceTypeDefinition
   [779]Descriptionoptinterface[780]Name[781]ImplementsInterfacesopt[782]D
   irectivesConstopt[783]FieldsDefinition
   [784]Descriptionoptinterface[785]Name[786]ImplementsInterfacesopt[787]D
   irectivesConstopt{

   GraphQL interfaces represent a list of named fields and their
   arguments. GraphQL objects and interfaces can then implement these
   interfaces which requires that the implementing type will define all
   fields defined by those interfaces.

   Fields on a GraphQL interface have the same rules as fields on a
   GraphQL object; their type can be Scalar, Object, Enum, Interface, or
   Union, or any wrapping type whose base type is one of those five.

   For example, an interface NamedEntity may describe a required field and
   types such as Person or Business may then implement this interface to
   guarantee this field will always exist.

   Types may also implement multiple interfaces. For example, Business
   implements both the NamedEntity and ValuedEntity interfaces in the
   example below.
[788]Example No. 64interface NamedEntity {
  name: String
}

interface ValuedEntity {
  value: Int
}

type Person implements NamedEntity {
  name: String
  age: Int
}

type Business implements NamedEntity & ValuedEntity {
  name: String
  value: Int
  employeeCount: Int
}

   Fields which yield an interface are useful when one of many Object
   types are expected, but some fields should be guaranteed.

   To continue the example, a Contact might refer to NamedEntity.
[789]Example No. 65type Contact {
  entity: NamedEntity
  phoneNumber: String
  address: String
}

   This allows us to write a selection set for a Contact that can select
   the common fields.
[790]Example No. 66{
  entity {
    name
  }
  phoneNumber
}

   When selecting fields on an interface type, only those fields declared
   on the interface may be queried. In the above example, entity returns a
   NamedEntity, and name is defined on NamedEntity, so it is valid.
   However, the following would not be a valid selection set against
   Contact:
[791]Counter Example No. 67{
  entity {
    name
    age
  }
  phoneNumber
}

   because entity refers to a NamedEntity, and age is not defined on that
   interface. Querying for age is only valid when the result of entity is
   a Person; this can be expressed using a fragment or an inline fragment:
[792]Example No. 68{
  entity {
    name
    ... on Person {
      age
    }
  }
  phoneNumber
}

        [793]Interfaces Implementing Interfaces

   When defining an interface that implements another interface, the
   implementing interface must define each field that is specified by the
   implemented interface. For example, the interface Resource must define
   the field id to implement the Node interface:
[794]Example No. 69interface Node {
  id: ID!
}

interface Resource implements Node {
  id: ID!
  url: String
}

   Transitively implemented interfaces (interfaces implemented by the
   interface that is being implemented) must also be defined on an
   implementing type or interface. For example, Image cannot implement
   Resource without also implementing Node:
[795]Example No. 70interface Node {
  id: ID!
}

interface Resource implements Node {
  id: ID!
  url: String
}

interface Image implements Resource & Node {
  id: ID!
  url: String
  thumbnail: String
}

   Interface definitions must not contain cyclic references nor implement
   themselves. This example is invalid because Node and Named implement
   themselves and each other:
[796]Counter Example No. 71interface Node implements Named & Node {
  id: ID!
  name: String
}

interface Named implements Node & Named {
  id: ID!
  name: String
}

        [797]Result Coercion

   The interface type should have some way of determining which object a
   given result corresponds to. Once it has done so, the result coercion
   of the interface is the same as the result coercion of the object.

        [798]Input Coercion

   Interfaces are never valid inputs.

        [799]Type Validation

   Interface types have the potential to be invalid if incorrectly
   defined.
    1. An Interface type must define one or more fields.
    2. For each field of an Interface type:
         1. The field must have a unique name within that Interface type;
            no two fields may share the same name.
         2. The field must not have a name which begins with the
            characters "__" (two underscores).
         3. The field must return a type where
            [800]IsOutputType(fieldType) returns true.
         4. For each argument of the field:
              1. The argument must not have a name which begins with the
                 characters "__" (two underscores).
              2. The argument must accept a type where
                 [801]IsInputType(argumentType) returns true.
    3. An interface type may declare that it implements one or more unique
       interfaces, but may not implement itself.
    4. An interface type must be a super-set of all interfaces it
       implements:
         1. Let this interface type be implementingType.
         2. For each interface declared implemented as implementedType,
            [802]IsValidImplementation(implementingType, implementedType)
            must be true.

  [803]3.7.1Interface Extensions

   [804]InterfaceTypeExtension
   extendinterface[805]Name[806]ImplementsInterfacesopt[807]DirectivesCons
   topt[808]FieldsDefinition
   extendinterface[809]Name[810]ImplementsInterfacesopt[811]DirectivesCons
   t{
   extendinterface[812]Name[813]ImplementsInterfaces{

   Interface type extensions are used to represent an interface which has
   been extended from some original interface. For example, this might be
   used to represent common local data on many types, or by a GraphQL
   service which is itself an extension of another GraphQL service.

   In this example, an extended data field is added to a NamedEntity type
   along with the types which implement it:
[814]Example No. 72extend interface NamedEntity {
  nickname: String
}

extend type Person {
  nickname: String
}

extend type Business {
  nickname: String
}

   Interface type extensions may choose not to add additional fields,
   instead only adding directives.

   In this example, a directive is added to a NamedEntity type without
   adding fields:
[815]Example No. 73extend interface NamedEntity @addedDirective

        [816]Type Validation

   Interface type extensions have the potential to be invalid if
   incorrectly defined.
    1. The named type must already be defined and must be an Interface
       type.
    2. The fields of an Interface type extension must have unique names;
       no two fields may share the same name.
    3. Any fields of an Interface type extension must not be already
       defined on the original Interface type.
    4. Any Object or Interface type which implemented the original
       Interface type must also be a super-set of the fields of the
       Interface type extension (which may be due to Object type
       extension).
    5. Any non-repeatable directives provided must not already apply to
       the original Interface type.
    6. The resulting extended Interface type must be a super-set of all
       Interfaces it implements.

[817]3.8Unions

   [818]UnionTypeDefinition
   [819]Descriptionoptunion[820]Name[821]DirectivesConstopt[822]UnionMembe
   rTypesopt

   [823]UnionMemberTypes
   [824]UnionMemberTypes|[825]NamedType
   =|opt[826]NamedType

   GraphQL Unions represent an object that could be one of a list of
   GraphQL Object types, but provides for no guaranteed fields between
   those types. They also differ from interfaces in that Object types
   declare what interfaces they implement, but are not aware of what
   unions contain them.

   With interfaces and objects, only those fields defined on the type can
   be queried directly; to query other fields on an interface, typed
   fragments must be used. This is the same as for unions, but unions do
   not define any fields, so no fields may be queried on this type without
   the use of type refining fragments or inline fragments (with the
   exception of the meta-field __typename).

   For example, we might define the following types:
[827]Example No. 74union SearchResult = Photo | Person

type Person {
  name: String
  age: Int
}

type Photo {
  height: Int
  width: Int
}

type SearchQuery {
  firstSearchResult: SearchResult
}

   In this example, a query operation wants the name if the result was a
   Person, and the height if it was a photo. However because a union
   itself defines no fields, this could be ambiguous and is invalid.
[828]Counter Example No. 75{
  firstSearchResult {
    name
    height
  }
}

   A valid operation includes typed fragments (in this example, inline
   fragments):
[829]Example No. 76{
  firstSearchResult {
    ... on Person {
      name
    }
    ... on Photo {
      height
    }
  }
}

   Union members may be defined with an optional leading | character to
   aid formatting when representing a longer list of possible types:
[830]Example No. 77union SearchResult =
  | Photo
  | Person

        [831]Result Coercion

   The union type should have some way of determining which object a given
   result corresponds to. Once it has done so, the result coercion of the
   union is the same as the result coercion of the object.

        [832]Input Coercion

   Unions are never valid inputs.

        [833]Type Validation

   Union types have the potential to be invalid if incorrectly defined.
    1. A Union type must include one or more unique member types.
    2. The member types of a Union type must all be Object base types;
       Scalar, Interface and Union types must not be member types of a
       Union. Similarly, wrapping types must not be member types of a
       Union.

  [834]3.8.1Union Extensions

   [835]UnionTypeExtension
   extendunion[836]Name[837]DirectivesConstopt[838]UnionMemberTypes
   extendunion[839]Name[840]DirectivesConst

   Union type extensions are used to represent a union type which has been
   extended from some original union type. For example, this might be used
   to represent additional local data, or by a GraphQL service which is
   itself an extension of another GraphQL service.

        [841]Type Validation

   Union type extensions have the potential to be invalid if incorrectly
   defined.
    1. The named type must already be defined and must be a Union type.
    2. The member types of a Union type extension must all be Object base
       types; Scalar, Interface and Union types must not be member types
       of a Union. Similarly, wrapping types must not be member types of a
       Union.
    3. All member types of a Union type extension must be unique.
    4. All member types of a Union type extension must not already be a
       member of the original Union type.
    5. Any non-repeatable directives provided must not already apply to
       the original Union type.

[842]3.9Enums

   [843]EnumTypeDefinition
   [844]Descriptionoptenum[845]Name[846]DirectivesConstopt[847]EnumValuesD
   efinition
   [848]Descriptionoptenum[849]Name[850]DirectivesConstopt{

   [851]EnumValuesDefinition
   {[852]EnumValueDefinitionlist}

   [853]EnumValueDefinition
   [854]Descriptionopt[855]EnumValue[856]DirectivesConstopt

   GraphQL Enum types, like Scalar types, also represent leaf values in a
   GraphQL type system. However Enum types describe the set of possible
   values.

   Enums are not references for a numeric value, but are unique values in
   their own right. They may serialize as a string: the name of the
   represented value.

   In this example, an Enum type called Direction is defined:
[857]Example No. 78enum Direction {
  NORTH
  EAST
  SOUTH
  WEST
}

        [858]Result Coercion

   GraphQL services must return one of the defined set of possible values.
   If a reasonable coercion is not possible they must raise a field error.

        [859]Input Coercion

   GraphQL has a constant literal to represent enum input values. GraphQL
   string literals must not be accepted as an enum input and instead raise
   a request error.

   Variable transport serializations which have a different representation
   for non-string symbolic values (for example, [860]EDN) should only
   allow such values as enum input values. Otherwise, for most transport
   serializations that do not, strings may be interpreted as the enum
   input value with the same name.

        [861]Type Validation

   Enum types have the potential to be invalid if incorrectly defined.
    1. An Enum type must define one or more unique enum values.

  [862]3.9.1Enum Extensions

   [863]EnumTypeExtension
   extendenum[864]Name[865]DirectivesConstopt[866]EnumValuesDefinition
   extendenum[867]Name[868]DirectivesConst{

   Enum type extensions are used to represent an enum type which has been
   extended from some original enum type. For example, this might be used
   to represent additional local data, or by a GraphQL service which is
   itself an extension of another GraphQL service.

        [869]Type Validation

   Enum type extensions have the potential to be invalid if incorrectly
   defined.
    1. The named type must already be defined and must be an Enum type.
    2. All values of an Enum type extension must be unique.
    3. All values of an Enum type extension must not already be a value of
       the original Enum.
    4. Any non-repeatable directives provided must not already apply to
       the original Enum type.

[870]3.10Input Objects

   [871]InputObjectTypeDefinition
   [872]Descriptionoptinput[873]Name[874]DirectivesConstopt[875]InputField
   sDefinition
   [876]Descriptionoptinput[877]Name[878]DirectivesConstopt{

   [879]InputFieldsDefinition
   {[880]InputValueDefinitionlist}

   Fields may accept arguments to configure their behavior. These inputs
   are often scalars or enums, but they sometimes need to represent more
   complex values.

   A GraphQL Input Object defines a set of input fields; the input fields
   are either scalars, enums, or other input objects. This allows
   arguments to accept arbitrarily complex structs.

   In this example, an Input Object called Point2D describes x and y
   inputs:
[881]Example No. 79input Point2D {
  x: Float
  y: Float
}

   [882]Note The GraphQL Object type ([883]ObjectTypeDefinition) defined
   above is inappropriate for re-use here, because Object types can
   contain fields that define arguments or contain references to
   interfaces and unions, neither of which is appropriate for use as an
   input argument. For this reason, input objects have a separate type in
   the system.

        [884]Circular References

   Input Objects are allowed to reference other Input Objects as field
   types. A circular reference occurs when an Input Object references
   itself either directly or through referenced Input Objects.

   Circular references are generally allowed, however they may not be
   defined as an unbroken chain of Non-Null singular fields. Such Input
   Objects are invalid because there is no way to provide a legal value
   for them.

   This example of a circularly-referenced input type is valid as the
   field self may be omitted or the value null.
[885]Example No. 80input Example {
  self: Example
  value: String
}

   This example is also valid as the field self may be an empty List.
[886]Example No. 81input Example {
  self: [Example!]!
  value: String
}

   This example of a circularly-referenced input type is invalid as the
   field self cannot be provided a finite value.
[887]Counter Example No. 82input Example {
  value: String
  self: Example!
}

   This example is also invalid, as there is a non-null singular circular
   reference via the First.second and Second.first fields.
[888]Counter Example No. 83input First {
  second: Second!
  value: String
}

input Second {
  first: First!
  value: String
}

        [889]Result Coercion

   An input object is never a valid result. Input Object types cannot be
   the return type of an Object or Interface field.

        [890]Input Coercion

   The value for an input object should be an input object literal or an
   unordered map supplied by a variable, otherwise a request error must be
   raised. In either case, the input object literal or unordered map must
   not contain any entries with names not defined by a field of this input
   object type, otherwise a response error must be raised.

   The result of coercion is an unordered map with an entry for each field
   both defined by the input object type and for which a value exists. The
   resulting map is constructed with the following rules:
     * If no value is provided for a defined input object field and that
       field definition provides a default value, the default value should
       be used. If no default value is provided and the input object
       field's type is non-null, an error should be raised. Otherwise, if
       the field is not required, then no entry is added to the coerced
       unordered map.
     * If the value null was provided for an input object field, and the
       field's type is not a non-null type, an entry in the coerced
       unordered map is given the value null. In other words, there is a
       semantic difference between the explicitly provided value null
       versus having not provided a value.
     * If a literal value is provided for an input object field, an entry
       in the coerced unordered map is given the result of coercing that
       value according to the input coercion rules for the type of that
       field.
     * If a variable is provided for an input object field, the runtime
       value of that variable must be used. If the runtime value is null
       and the field type is non-null, a field error must be raised. If no
       runtime value is provided, the variable definition's default value
       should be used. If the variable definition does not provide a
       default value, the input object field definition's default value
       should be used.

   Following are examples of input coercion for an input object type with
   a String field a and a required (non-null) Int! field b:
[891]Example No. 84input ExampleInputObject {
  a: String
  b: Int!
}

     Literal Value            Variables                 Coerced Value
 { a: "abc", b: 123 }   {}                    { a: "abc", b: 123 }
 { a: null, b: 123 }    {}                    { a: null, b: 123 }
 { b: 123 }             {}                    { b: 123 }
 { a: $var, b: 123 }    { var: null }         { a: null, b: 123 }
 { a: $var, b: 123 }    {}                    { b: 123 }
 { b: $var }            { var: 123 }          { b: 123 }
 $var                   { var: { b: 123 } }   { b: 123 }
 "abc123"               {}                    Error: Incorrect value
 $var                   { var: "abc123" }     Error: Incorrect value
 { a: "abc", b: "123" } {}                    Error: Incorrect value for field b
 { a: "abc" }           {}                    Error: Missing required field b
 { b: $var }            {}                    Error: Missing required field b.
 $var                   { var: { a: "abc" } } Error: Missing required field b
 { a: "abc", b: null }  {}                    Error: b must be non-null.
 { b: $var }            { var: null }         Error: b must be non-null.
 { b: 123, c: "xyz" }   {}                    Error: Unexpected field c

        [892]Type Validation

    1. An Input Object type must define one or more input fields.
    2. For each input field of an Input Object type:
         1. The input field must have a unique name within that Input
            Object type; no two input fields may share the same name.
         2. The input field must not have a name which begins with the
            characters "__" (two underscores).
         3. The input field must accept a type where
            [893]IsInputType(inputFieldType) returns true.
    3. If an Input Object references itself either directly or through
       referenced Input Objects, at least one of the fields in the chain
       of references must be either a nullable or a List type.

  [894]3.10.1Input Object Extensions

   [895]InputObjectTypeExtension
   extendinput[896]Name[897]DirectivesConstopt[898]InputFieldsDefinition
   extendinput[899]Name[900]DirectivesConst{

   Input object type extensions are used to represent an input object type
   which has been extended from some original input object type. For
   example, this might be used by a GraphQL service which is itself an
   extension of another GraphQL service.

        [901]Type Validation

   Input object type extensions have the potential to be invalid if
   incorrectly defined.
    1. The named type must already be defined and must be a Input Object
       type.
    2. All fields of an Input Object type extension must have unique
       names.
    3. All fields of an Input Object type extension must not already be a
       field of the original Input Object.
    4. Any non-repeatable directives provided must not already apply to
       the original Input Object type.

[902]3.11List

   A GraphQL list is a special collection type which declares the type of
   each item in the List (referred to as the item type of the list). List
   values are serialized as ordered lists, where each item in the list is
   serialized as per the item type.

   To denote that a field uses a List type the item type is wrapped in
   square brackets like this: pets: [Pet]. Nesting lists is allowed:
   matrix: [[Int]].

        [903]Result Coercion

   GraphQL services must return an ordered list as the result of a list
   type. Each item in the list must be the result of a result coercion of
   the item type. If a reasonable coercion is not possible it must raise a
   field error. In particular, if a non-list is returned, the coercion
   should fail, as this indicates a mismatch in expectations between the
   type system and the implementation.

   If a list's item type is nullable, then errors occurring during
   preparation or coercion of an individual item in the list must result
   in a the value null at that position in the list along with a field
   error added to the response. If a list's item type is non-null, a field
   error occurring at an individual item in the list must result in a
   field error for the entire list.

   [904]Note See [905]Handling Field Errors for more about this behavior.

        [906]Input Coercion

   When expected as an input, list values are accepted only when each item
   in the list can be accepted by the list's item type.

   If the value passed as an input to a list type is not a list and not
   the null value, then the result of input coercion is a list of size
   one, where the single item value is the result of input coercion for
   the list's item type on the provided value (note this may apply
   recursively for nested lists).

   This allows inputs which accept one or many arguments (sometimes
   referred to as "var args") to declare their input type as a list while
   for the common case of a single value, a client can just pass that
   value directly rather than constructing the list.

   Following are examples of input coercion with various list types and
   values:

   Expected Type Provided Value        Coerced Value
   [Int]         [1, 2, 3]      [1, 2, 3]
   [Int]         [1, "b", true] Error: Incorrect item value
   [Int]         1              [1]
   [Int]         null           null
   [[Int]]       [[1], [2, 3]]  [[1], [2, 3]]
   [[Int]]       [1, 2, 3]      Error: Incorrect item value
   [[Int]]       1              [[1]]
   [[Int]]       null           null

[907]3.12Non-Null

   By default, all types in GraphQL are nullable; the null value is a
   valid response for all of the above types. To declare a type that
   disallows null, the GraphQL Non-Null type can be used. This type wraps
   an underlying type, and this type acts identically to that wrapped
   type, with the exception that null is not a valid response for the
   wrapping type. A trailing exclamation mark is used to denote a field
   that uses a Non-Null type like this: name: String!.

        [908]Nullable vs. Optional

   Fields are always optional within the context of a selection set, a
   field may be omitted and the selection set is still valid. However
   fields that return Non-Null types will never return the value null if
   queried.

   Inputs (such as field arguments), are always optional by default.
   However a non-null input type is required. In addition to not accepting
   the value null, it also does not accept omission. For the sake of
   simplicity nullable types are always optional and non-null types are
   always required.

        [909]Result Coercion

   In all of the above result coercions, null was considered a valid
   value. To coerce the result of a Non-Null type, the coercion of the
   wrapped type should be performed. If that result was not null, then the
   result of coercing the Non-Null type is that result. If that result was
   null, then a field error must be raised.

   [910]Note When a field error is raised on a non-null value, the error
   propagates to the parent field. For more information on this process,
   see "Errors and Non-Nullability" within the Execution section.

        [911]Input Coercion

   If an argument or input-object field of a Non-Null type is not
   provided, is provided with the literal value null, or is provided with
   a variable that was either not provided a value at runtime, or was
   provided the value null, then a request error must be raised.

   If the value provided to the Non-Null type is provided with a literal
   value other than null, or a Non-Null variable value, it is coerced
   using the input coercion for the wrapped type.

   A non-null argument cannot be omitted:
[912]Counter Example No. 85{
  fieldWithNonNullArg
}

   The value null cannot be provided to a non-null argument:
[913]Counter Example No. 86{
  fieldWithNonNullArg(nonNullArg: null)
}

   A variable of a nullable type cannot be provided to a non-null
   argument:
[914]Example No. 87query withNullableVariable($var: String) {
  fieldWithNonNullArg(nonNullArg: $var)
}

   [915]Note The Validation section defines providing a nullable variable
   type to a non-null input type as invalid.

        [916]Type Validation

    1. A Non-Null type must not wrap another Non-Null type.

  [917]3.12.1Combining List and Non-Null

   The List and Non-Null wrapping types can compose, representing more
   complex types. The rules for result coercion and input coercion of
   Lists and Non-Null types apply in a recursive fashion.

   For example if the inner item type of a List is Non-Null (e.g. [T!]),
   then that List may not contain any null items. However if the inner
   type of a Non-Null is a List (e.g. [T]!), then null is not accepted
   however an empty list is accepted.

   Following are examples of result coercion with various types and
   values:

   Expected Type Internal Value          Coerced Result
   [Int]         [1, 2, 3]      [1, 2, 3]
   [Int]         null           null
   [Int]         [1, 2, null]   [1, 2, null]
   [Int]         [1, 2, Error]  [1, 2, null] (With logged error)
   [Int]!        [1, 2, 3]      [1, 2, 3]
   [Int]!        null           Error: Value cannot be null
   [Int]!        [1, 2, null]   [1, 2, null]
   [Int]!        [1, 2, Error]  [1, 2, null] (With logged error)
   [Int!]        [1, 2, 3]      [1, 2, 3]
   [Int!]        null           null
   [Int!]        [1, 2, null]   null (With logged coercion error)
   [Int!]        [1, 2, Error]  null (With logged error)
   [Int!]!       [1, 2, 3]      [1, 2, 3]
   [Int!]!       null           Error: Value cannot be null
   [Int!]!       [1, 2, null]   Error: Item cannot be null
   [Int!]!       [1, 2, Error]  Error: Error occurred in item

[918]3.13Directives

   [919]DirectiveDefinition
   [920]Descriptionoptdirective@[921]Name[922]ArgumentsDefinitionoptrepeat
   ableopton[923]DirectiveLocations

   [924]DirectiveLocations
   [925]DirectiveLocations|[926]DirectiveLocation
   |opt[927]DirectiveLocation

   [928]DirectiveLocation
   [929]ExecutableDirectiveLocation
   [930]TypeSystemDirectiveLocation

   [931]ExecutableDirectiveLocation
   QUERY
   MUTATION
   SUBSCRIPTION
   FIELD
   FRAGMENT_DEFINITION
   FRAGMENT_SPREAD
   INLINE_FRAGMENT
   VARIABLE_DEFINITION

   [932]TypeSystemDirectiveLocation
   SCHEMA
   SCALAR
   OBJECT
   FIELD_DEFINITION
   ARGUMENT_DEFINITION
   INTERFACE
   UNION
   ENUM
   ENUM_VALUE
   INPUT_OBJECT
   INPUT_FIELD_DEFINITION

   A GraphQL schema describes directives which are used to annotate
   various parts of a GraphQL document as an indicator that they should be
   evaluated differently by a validator, executor, or client tool such as
   a code generator.

        [933]Built-in Directives

   A [934]built-in directive is any directive defined within this
   specification.

   GraphQL implementations should provide the @skip and @include
   directives.

   GraphQL implementations that support the type system definition
   language must provide the @deprecated directive if representing
   deprecated portions of the schema.

   GraphQL implementations that support the type system definition
   language should provide the @specifiedBy directive if representing
   custom scalar definitions.

   When representing a GraphQL schema using the type system definition
   language any [935]built-in directive may be omitted for brevity.

   When introspecting a GraphQL service all provided directives, including
   any [936]built-in directive, must be included in the set of returned
   directives.

        [937]Custom Directives

   GraphQL services and client tooling may provide any additional
   [938]custom directive beyond those defined in this document. Directives
   are the preferred way to extend GraphQL with custom or experimental
   behavior.

   [939]Note When defining a [940]custom directive, it is recommended to
   prefix the directive's name to make its scope of usage clear and to
   prevent a collision with [941]built-in directive which may be specified
   by future versions of this document (which will not include _ in their
   name). For example, a [942]custom directive used by Facebook's GraphQL
   service should be named @fb_auth instead of @auth. This is especially
   recommended for proposed additions to this specification which can
   change during the [943]RFC process. For example a work in progress
   version of @live should be named @rfc_live.

   Directives must only be used in the locations they are declared to
   belong in. In this example, a directive is defined which can be used to
   annotate a field:
[944]Example No. 88directive @example on FIELD

fragment SomeFragment on SomeType {
  field @example
}

   Directive locations may be defined with an optional leading | character
   to aid formatting when representing a longer list of possible
   locations:
[945]Example No. 89directive @example on
  | FIELD
  | FRAGMENT_SPREAD
  | INLINE_FRAGMENT

   Directives can also be used to annotate the type system definition
   language as well, which can be a useful tool for supplying additional
   metadata in order to generate GraphQL execution services, produce
   client generated runtime code, or many other useful extensions of the
   GraphQL semantics.

   In this example, the directive @example annotates field and argument
   definitions:
[946]Example No. 90directive @example on FIELD_DEFINITION | ARGUMENT_DEFINITION

type SomeType {
  field(arg: Int @example): String @example
}

   A directive may be defined as repeatable by including the "repeatable"
   keyword. Repeatable directives are often useful when the same directive
   should be used with different arguments at a single location,
   especially in cases where additional information needs to be provided
   to a type or schema extension via a directive:
[947]Example No. 91directive @delegateField(name: String!) repeatable on OBJECT
| INTERFACE

type Book @delegateField(name: "pageCount") @delegateField(name: "author") {
  id: ID!
}

extend type Book @delegateField(name: "index")

   While defining a directive, it must not reference itself directly or
   indirectly:
[948]Counter Example No. 92directive @invalidExample(arg: String @invalidExample
) on ARGUMENT_DEFINITION

   [949]Note The order in which directives appear may be significant,
   including repeatable directives.

        [950]Validation

    1. A directive definition must not contain the use of a directive
       which references itself directly.
    2. A directive definition must not contain the use of a directive
       which references itself indirectly by referencing a Type or
       Directive which transitively includes a reference to this
       directive.
    3. The directive must not have a name which begins with the characters
       "__" (two underscores).
    4. For each argument of the directive:
         1. The argument must not have a name which begins with the
            characters "__" (two underscores).
         2. The argument must accept a type where
            [951]IsInputType(argumentType) returns true.

  [952]3.13.1@skip

directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

   The @skip [953]built-in directive may be provided for fields, fragment
   spreads, and inline fragments, and allows for conditional exclusion
   during execution as described by the if argument.

   In this example experimentalField will only be queried if the variable
   $someTest has the value false.
[954]Example No. 93query myQuery($someTest: Boolean!) {
  experimentalField @skip(if: $someTest)
}

  [955]3.13.2@include

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

   The @include [956]built-in directive may be provided for fields,
   fragment spreads, and inline fragments, and allows for conditional
   inclusion during execution as described by the if argument.

   In this example experimentalField will only be queried if the variable
   $someTest has the value true
[957]Example No. 94query myQuery($someTest: Boolean!) {
  experimentalField @include(if: $someTest)
}

   [958]Note Neither @skip nor @include has precedence over the other. In
   the case that both the @skip and @include directives are provided on
   the same field or fragment, it must be queried only if the @skip
   condition is false and the @include condition is true. Stated
   conversely, the field or fragment must not be queried if either the
   @skip condition is true or the @include condition is false.

  [959]3.13.3@deprecated

directive @deprecated(
  reason: String = "No longer supported"
) on FIELD_DEFINITION | ENUM_VALUE

   The @deprecated [960]built-in directive is used within the type system
   definition language to indicate deprecated portions of a GraphQL
   service's schema, such as deprecated fields on a type or deprecated
   enum values.

   Deprecations include a reason for why it is deprecated, which is
   formatted using Markdown syntax (as specified by [961]CommonMark).

   In this example type definition, oldField is deprecated in favor of
   using newField.
[962]Example No. 95type ExampleType {
  newField: String
  oldField: String @deprecated(reason: "Use `newField`.")
}

  [963]3.13.4@specifiedBy

directive @specifiedBy(url: String!) on SCALAR

   The @specifiedBy [964]built-in directive is used within the type system
   definition language to provide a [965]scalar specification URL for
   specifying the behavior of [966]custom scalar types. The URL should
   point to a human-readable specification of the data format,
   serialization, and coercion rules. It must not appear on built-in
   scalar types.

   In this example, a custom scalar type for UUID is defined with a URL
   pointing to the relevant IETF specification.
[967]Example No. 96scalar UUID @specifiedBy(url: "https://tools.ietf.org/html/rf
c4122")

                              [968]4Introspection

   A GraphQL service supports introspection over its schema. This schema
   is queried using GraphQL itself, creating a powerful platform for
   tool-building.

   Take an example request for a trivial app. In this case there is a User
   type with three fields: id, name, and birthday.

   For example, given a service with the following type definition:
[969]Example No. 97type User {
  id: String
  name: String
  birthday: Date
}

   A request containing the operation:
[970]Example No. 98{
  __type(name: "User") {
    name
    fields {
      name
      type {
        name
      }
    }
  }
}

   would produce the result:
[971]Example No. 99{
  "__type": {
    "name": "User",
    "fields": [
      {
        "name": "id",
        "type": { "name": "String" }
      },
      {
        "name": "name",
        "type": { "name": "String" }
      },
      {
        "name": "birthday",
        "type": { "name": "Date" }
      }
    ]
  }
}

        [972]Reserved Names

   Types and fields required by the GraphQL introspection system that are
   used in the same context as user-defined types and fields are prefixed
   with "__" two underscores. This in order to avoid naming collisions
   with user-defined GraphQL types.

   Otherwise, any [973]Name within a GraphQL type system must not start
   with two underscores "__".

[974]4.1Type Name Introspection

   GraphQL supports type name introspection within any selection set in an
   operation, with the single exception of selections at the root of a
   subscription operation. Type name introspection is accomplished via the
   meta-field __typename: String! on any Object, Interface, or Union. It
   returns the name of the concrete Object type at that point during
   execution.

   This is most often used when querying against Interface or Union types
   to identify which actual Object type of the possible types has been
   returned.

   As a meta-field, __typename is implicit and does not appear in the
   fields list in any defined type.

   [975]Note __typename may not be included as a root field in a
   subscription operation.

[976]4.2Schema Introspection

   The schema introspection system is accessible from the meta-fields
   __schema and __type which are accessible from the type of the root of a
   query operation.
__schema: __Schema!
__type(name: String!): __Type

   Like all meta-fields, these are implicit and do not appear in the
   fields list in the root type of the query operation.

        [977]First Class Documentation

   All types in the introspection system provide a description field of
   type String to allow type designers to publish documentation in
   addition to capabilities. A GraphQL service may return the description
   field using Markdown syntax (as specified by [978]CommonMark).
   Therefore it is recommended that any tool that displays description use
   a CommonMark-compliant Markdown renderer.

        [979]Deprecation

   To support the management of backwards compatibility, GraphQL fields
   and enum values can indicate whether or not they are deprecated
   (isDeprecated: Boolean) and a description of why it is deprecated
   (deprecationReason: String).

   Tools built using GraphQL introspection should respect deprecation by
   discouraging deprecated use through information hiding or
   developer-facing warnings.

        [980]Schema Introspection Schema

   The schema introspection system is itself represented as a GraphQL
   schema. Below are the full set of type system definitions providing
   schema introspection, which are fully defined in the sections below.
type __Schema {
  description: String
  types: [__Type!]!
  queryType: __Type!
  mutationType: __Type
  subscriptionType: __Type
  directives: [__Directive!]!
}

type __Type {
  kind: __TypeKind!
  name: String
  description: String
  # must be non-null for OBJECT and INTERFACE, otherwise null.
  fields(includeDeprecated: Boolean = false): [__Field!]
  # must be non-null for OBJECT and INTERFACE, otherwise null.
  interfaces: [__Type!]
  # must be non-null for INTERFACE and UNION, otherwise null.
  possibleTypes: [__Type!]
  # must be non-null for ENUM, otherwise null.
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]
  # must be non-null for INPUT_OBJECT, otherwise null.
  inputFields: [__InputValue!]
  # must be non-null for NON_NULL and LIST, otherwise null.
  ofType: __Type
  # may be non-null for custom SCALAR, otherwise null.
  specifiedByURL: String
}

enum __TypeKind {
  SCALAR
  OBJECT
  INTERFACE
  UNION
  ENUM
  INPUT_OBJECT
  LIST
  NON_NULL
}

type __Field {
  name: String!
  description: String
  args: [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

type __InputValue {
  name: String!
  description: String
  type: __Type!
  defaultValue: String
}

type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

type __Directive {
  name: String!
  description: String
  locations: [__DirectiveLocation!]!
  args: [__InputValue!]!
  isRepeatable: Boolean!
}

enum __DirectiveLocation {
  QUERY
  MUTATION
  SUBSCRIPTION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
  VARIABLE_DEFINITION
  SCHEMA
  SCALAR
  OBJECT
  FIELD_DEFINITION
  ARGUMENT_DEFINITION
  INTERFACE
  UNION
  ENUM
  ENUM_VALUE
  INPUT_OBJECT
  INPUT_FIELD_DEFINITION
}

  [981]4.2.1The __Schema Type

   The __Schema type is returned from the __schema meta-field and provides
   all information about the schema of a GraphQL service.

   Fields:
     * description may return a String or null.
     * queryType is the root type of a query operation.
     * mutationType is the root type of a mutation operation, if
       supported. Otherwise null.
     * subscriptionType is the root type of a subscription operation, if
       supported. Otherwise null.
     * types must return the set of all named types contained within this
       schema. Any named type which can be found through a field of any
       introspection type must be included in this set.
     * directives must return the set of all directives available within
       this schema including all built-in directives.

  [982]4.2.2The __Type Type

   __Type is at the core of the type introspection system, it represents
   all types in the system: both named types (e.g. Scalars and Object
   types) and type modifiers (e.g. List and Non-Null types).

   Type modifiers are used to modify the type presented in the field
   ofType. This modified type may recursively be a modified type,
   representing lists, non-nullables, and combinations thereof, ultimately
   modifying a named type.

   There are several different kinds of type. In each kind, different
   fields are actually valid. All possible kinds are listed in the
   __TypeKind enum.

   Each sub-section below defines the expected fields of __Type given each
   possible value of the __TypeKind enum:
     * "SCALAR"
     * "OBJECT"
     * "INTERFACE"
     * "UNION"
     * "ENUM"
     * "INPUT_OBJECT"
     * "LIST"
     * "NON_NULL"

        [983]Scalar

   Represents scalar types such as Int, String, and Boolean. Scalars
   cannot have fields.

   Also represents [984]Custom scalars which may provide specifiedByURL as
   a [985]scalar specification URL.

   Fields:
     * kind must return __TypeKind.SCALAR.
     * name must return a String.
     * description may return a String or null.
     * specifiedByURL may return a String (in the form of a URL) for
       custom scalars, otherwise must be null.
     * All other fields must return null.

        [986]Object

   Object types represent concrete instantiations of sets of fields. The
   introspection types (e.g. __Type, __Field, etc) are examples of
   objects.

   Fields:
     * kind must return __TypeKind.OBJECT.
     * name must return a String.
     * description may return a String or null.
     * fields must return the set of fields that can be selected for this
       type.
          + Accepts the argument includeDeprecated which defaults to
            false. If true, deprecated fields are also returned.
     * interfaces must return the set of interfaces that an object
       implements (if none, interfaces must return the empty set).
     * All other fields must return null.

        [987]Union

   Unions are an abstract type where no common fields are declared. The
   possible types of a union are explicitly listed out in possibleTypes.
   Types can be made parts of unions without modification of that type.

   Fields:
     * kind must return __TypeKind.UNION.
     * name must return a String.
     * description may return a String or null.
     * possibleTypes returns the list of types that can be represented
       within this union. They must be object types.
     * All other fields must return null.

        [988]Interface

   Interfaces are an abstract type where there are common fields declared.
   Any type that implements an interface must define all the fields with
   names and types exactly matching. The implementations of this interface
   are explicitly listed out in possibleTypes.

   Fields:
     * kind must return __TypeKind.INTERFACE.
     * name must return a String.
     * description may return a String or null.
     * fields must return the set of fields required by this interface.
          + Accepts the argument includeDeprecated which defaults to
            false. If true, deprecated fields are also returned.
     * interfaces must return the set of interfaces that an object
       implements (if none, interfaces must return the empty set).
     * possibleTypes returns the list of types that implement this
       interface. They must be object types.
     * All other fields must return null.

        [989]Enum

   Enums are special scalars that can only have a defined set of values.

   Fields:
     * kind must return __TypeKind.ENUM.
     * name must return a String.
     * description may return a String or null.
     * enumValues must return the set of enum values as a list of
       __EnumValue. There must be at least one and they must have unique
       names.
          + Accepts the argument includeDeprecated which defaults to
            false. If true, deprecated enum values are also returned.
     * All other fields must return null.

        [990]Input Object

   Input objects are composite types defined as a list of named input
   values. They are only used as inputs to arguments and variables and
   cannot be a field return type.

   For example the input object Point could be defined as:
[991]Example No. 100input Point {
  x: Int
  y: Int
}

   Fields:
     * kind must return __TypeKind.INPUT_OBJECT.
     * name must return a String.
     * description may return a String or null.
     * inputFields must return the set of input fields as a list of
       __InputValue.
     * All other fields must return null.

        [992]List

   Lists represent sequences of values in GraphQL. A List type is a type
   modifier: it wraps another type instance in the ofType field, which
   defines the type of each item in the list.

   The modified type in the ofType field may itself be a modified type,
   allowing the representation of Lists of Lists, or Lists of Non-Nulls.

   Fields:
     * kind must return __TypeKind.LIST.
     * ofType must return a type of any kind.
     * All other fields must return null.

        [993]Non-Null

   GraphQL types are nullable. The value null is a valid response for
   field type.

   A Non-Null type is a type modifier: it wraps another type instance in
   the ofType field. Non-null types do not allow null as a response, and
   indicate required inputs for arguments and input object fields.

   The modified type in the ofType field may itself be a modified List
   type, allowing the representation of Non-Null of Lists. However it must
   not be a modified Non-Null type to avoid a redundant Non-Null of
   Non-Null.

   Fields:
     * kind must return __TypeKind.NON_NULL.
     * ofType must return a type of any kind except Non-Null.
     * All other fields must return null.

  [994]4.2.3The __Field Type

   The __Field type represents each field in an Object or Interface type.

   Fields:
     * name must return a String
     * description may return a String or null
     * args returns a List of __InputValue representing the arguments this
       field accepts.
     * type must return a __Type that represents the type of value
       returned by this field.
     * isDeprecated returns true if this field should no longer be used,
       otherwise false.
     * deprecationReason optionally provides a reason why this field is
       deprecated.

  [995]4.2.4The __InputValue Type

   The __InputValue type represents field and directive arguments as well
   as the inputFields of an input object.

   Fields:
     * name must return a String
     * description may return a String or null
     * type must return a __Type that represents the type this input value
       expects.
     * defaultValue may return a String encoding (using the GraphQL
       language) of the default value used by this input value in the
       condition a value is not provided at runtime. If this input value
       has no default value, returns null.

  [996]4.2.5The __EnumValue Type

   The __EnumValue type represents one of possible values of an enum.

   Fields:
     * name must return a String
     * description may return a String or null
     * isDeprecated returns true if this enum value should no longer be
       used, otherwise false.
     * deprecationReason optionally provides a reason why this enum value
       is deprecated.

  [997]4.2.6The __Directive Type

   The __Directive type represents a directive that a service supports.

   This includes both any [998]built-in directive and any [999]custom
   directive.

   Individual directives may only be used in locations that are explicitly
   supported. All possible locations are listed in the __DirectiveLocation
   enum:
     * "QUERY"
     * "MUTATION"
     * "SUBSCRIPTION"
     * "FIELD"
     * "FRAGMENT_DEFINITION"
     * "FRAGMENT_SPREAD"
     * "INLINE_FRAGMENT"
     * "VARIABLE_DEFINITION"
     * "SCHEMA"
     * "SCALAR"
     * "OBJECT"
     * "FIELD_DEFINITION"
     * "ARGUMENT_DEFINITION"
     * "INTERFACE"
     * "UNION"
     * "ENUM"
     * "ENUM_VALUE"
     * "INPUT_OBJECT"
     * "INPUT_FIELD_DEFINITION"

   Fields:
     * name must return a String
     * description may return a String or null
     * locations returns a List of __DirectiveLocation representing the
       valid locations this directive may be placed.
     * args returns a List of __InputValue representing the arguments this
       directive accepts.
     * isRepeatable must return a Boolean that indicates if the directive
       may be used repeatedly at a single location.

                               [1000]5Validation

   GraphQL does not just verify if a request is syntactically correct, but
   also ensures that it is unambiguous and mistake-free in the context of
   a given GraphQL schema.

   An invalid request is still technically executable, and will always
   produce a stable result as defined by the algorithms in the Execution
   section, however that result may be ambiguous, surprising, or
   unexpected relative to a request containing validation errors, so
   execution should only occur for valid requests.

   Typically validation is performed in the context of a request
   immediately before execution, however a GraphQL service may execute a
   request without explicitly validating it if that exact same request is
   known to have been validated before. For example: the request may be
   validated during development, provided it does not later change, or a
   service may validate a request once and memoize the result to avoid
   validating the same request again in the future. Any client-side or
   development-time tool should report validation errors and not allow the
   formulation or execution of requests known to be invalid at that given
   point in time.

        [1001]Type system evolution

   As GraphQL type system schema evolves over time by adding new types and
   new fields, it is possible that a request which was previously valid
   could later become invalid. Any change that can cause a previously
   valid request to become invalid is considered a breaking change.
   GraphQL services and schema maintainers are encouraged to avoid
   breaking changes, however in order to be more resilient to these
   breaking changes, sophisticated GraphQL systems may still allow for the
   execution of requests which at some point were known to be free of any
   validation errors, and have not changed since.

        [1002]Examples

   For this section of this schema, we will assume the following type
   system in order to demonstrate examples:
[1003]Example No. 101type Query {
  dog: Dog
}

enum DogCommand {
  SIT
  DOWN
  HEEL
}

type Dog implements Pet {
  name: String!
  nickname: String
  barkVolume: Int
  doesKnowCommand(dogCommand: DogCommand!): Boolean!
  isHouseTrained(atOtherHomes: Boolean): Boolean!
  owner: Human
}

interface Sentient {
  name: String!
}

interface Pet {
  name: String!
}

type Alien implements Sentient {
  name: String!
  homePlanet: String
}

type Human implements Sentient {
  name: String!
  pets: [Pet!]
}

enum CatCommand {
  JUMP
}

type Cat implements Pet {
  name: String!
  nickname: String
  doesKnowCommand(catCommand: CatCommand!): Boolean!
  meowVolume: Int
}

union CatOrDog = Cat | Dog
union DogOrHuman = Dog | Human
union HumanOrAlien = Human | Alien

[1004]5.1Documents

  [1005]5.1.1Executable Definitions

        [1006]Formal Specification

     * For each definition definition in the document.
     * definition must be [1007]ExecutableDefinition (it must not be
       [1008]TypeSystemDefinitionOrExtension).

        [1009]Explanatory Text

   GraphQL execution will only consider the executable definitions
   Operation and Fragment. Type system definitions and extensions are not
   executable, and are not considered during execution.

   To avoid ambiguity, a document containing
   [1010]TypeSystemDefinitionOrExtension is invalid for execution.

   GraphQL documents not intended to be directly executed may include
   [1011]TypeSystemDefinitionOrExtension.

   For example, the following document is invalid for execution since the
   original executing schema may not know about the provided type
   extension:
[1012]Counter Example No. 102query getDogName {
  dog {
    name
    color
  }
}

extend type Dog {
  color: String
}

[1013]5.2Operations

  [1014]5.2.1Named Operation Definitions

    [1015]5.2.1.1Operation Name Uniqueness

        [1016]Formal Specification

     * For each operation definition operation in the document.
     * Let operationName be the name of operation.
     * If operationName exists
          + Let operations be all operation definitions in the document
            named operationName.
          + operations must be a set of one.

        [1017]Explanatory Text

   Each named operation definition must be unique within a document when
   referred to by its name.

   For example the following document is valid:
[1018]Example No. 103query getDogName {
  dog {
    name
  }
}

query getOwnerName {
  dog {
    owner {
      name
    }
  }
}

   While this document is invalid:
[1019]Counter Example No. 104query getName {
  dog {
    name
  }
}

query getName {
  dog {
    owner {
      name
    }
  }
}

   It is invalid even if the type of each operation is different:
[1020]Counter Example No. 105query dogOperation {
  dog {
    name
  }
}

mutation dogOperation {
  mutateDog {
    id
  }
}

  [1021]5.2.2Anonymous Operation Definitions

    [1022]5.2.2.1Lone Anonymous Operation

        [1023]Formal Specification

     * Let operations be all operation definitions in the document.
     * Let anonymous be all anonymous operation definitions in the
       document.
     * If operations is a set of more than 1:
          + anonymous must be empty.

        [1024]Explanatory Text

   GraphQL allows a short-hand form for defining query operations when
   only that one operation exists in the document.

   For example the following document is valid:
[1025]Example No. 106{
  dog {
    name
  }
}

   While this document is invalid:
[1026]Counter Example No. 107{
  dog {
    name
  }
}

query getName {
  dog {
    owner {
      name
    }
  }
}

  [1027]5.2.3Subscription Operation Definitions

    [1028]5.2.3.1Single root field

        [1029]Formal Specification

     * For each subscription operation definition subscription in the
       document
     * Let subscriptionType be the root Subscription type in schema.
     * Let selectionSet be the top level selection set on subscription.
     * Let variableValues be the empty set.
     * Let groupedFieldSet be the result of
       [1030]CollectFields(subscriptionType, selectionSet,
       variableValues).
     * groupedFieldSet must have exactly one entry, which must not be an
       introspection field.

        [1031]Explanatory Text

   Subscription operations must have exactly one root field.

   Valid examples:
[1032]Example No. 108subscription sub {
  newMessage {
    body
    sender
  }
}

[1033]Example No. 109subscription sub {
  ...newMessageFields
}

fragment newMessageFields on Subscription {
  newMessage {
    body
    sender
  }
}

   Invalid:
[1034]Counter Example No. 110subscription sub {
  newMessage {
    body
    sender
  }
  disallowedSecondRootField
}

[1035]Counter Example No. 111subscription sub {
  ...multipleSubscriptions
}

fragment multipleSubscriptions on Subscription {
  newMessage {
    body
    sender
  }
  disallowedSecondRootField
}

   The root field of a subscription operation must not be an introspection
   field. The following example is also invalid:
[1036]Counter Example No. 112subscription sub {
  __typename
}

   [1037]Note While each subscription must have exactly one root field, a
   document may contain any number of operations, each of which may
   contain different root fields. When executed, a document containing
   multiple subscription operations must provide the operation name as
   described in [1038]GetOperation().

[1039]5.3Fields

  [1040]5.3.1Field Selections

   Field selections must exist on Object, Interface, and Union types.

        [1041]Formal Specification

     * For each selection in the document.
     * Let fieldName be the target field of selection
     * fieldName must be defined on type in scope

        [1042]Explanatory Text

   The target field of a field selection must be defined on the scoped
   type of the selection set. There are no limitations on alias names.

   For example the following fragment would not pass validation:
[1043]Counter Example No. 113fragment fieldNotDefined on Dog {
  meowVolume
}

fragment aliasedLyingFieldTargetNotDefined on Dog {
  barkVolume: kawVolume
}

   For interfaces, direct field selection can only be done on fields.
   Fields of concrete implementors are not relevant to the validity of the
   given interface-typed selection set.

   For example, the following is valid:
[1044]Example No. 114fragment interfaceFieldSelection on Pet {
  name
}

   and the following is invalid:
[1045]Counter Example No. 115fragment definedOnImplementorsButNotInterface on Pe
t {
  nickname
}

   Because unions do not define fields, fields may not be directly
   selected from a union-typed selection set, with the exception of the
   meta-field __typename. Fields from a union-typed selection set must
   only be queried indirectly via a fragment.

   For example the following is valid:
[1046]Example No. 116fragment inDirectFieldSelectionOnUnion on CatOrDog {
  __typename
  ... on Pet {
    name
  }
  ... on Dog {
    barkVolume
  }
}

   But the following is invalid:
[1047]Counter Example No. 117fragment directFieldSelectionOnUnion on CatOrDog {
  name
  barkVolume
}

  [1048]5.3.2Field Selection Merging

        [1049]Formal Specification

     * Let set be any selection set defined in the GraphQL document.
     * [1050]FieldsInSetCanMerge(set) must be true.

   [1051]FieldsInSetCanMerge(set)
    1. Let fieldsForName be the set of selections with a given response
       name in set including visiting fragments and inline fragments.
    2. Given each pair of members fieldA and fieldB in fieldsForName:
         1. [1052]SameResponseShape(fieldA, fieldB) must be true.
         2. If the parent types of fieldA and fieldB are equal or if
            either is not an Object Type:
              1. fieldA and fieldB must have identical field names.
              2. fieldA and fieldB must have identical sets of arguments.
              3. Let mergedSet be the result of adding the selection set
                 of fieldA and the selection set of fieldB.
              4. [1053]FieldsInSetCanMerge(mergedSet) must be true.

   [1054]SameResponseShape(fieldA, fieldB)
    1. Let typeA be the return type of fieldA.
    2. Let typeB be the return type of fieldB.
    3. If typeA or typeB is Non-Null.
         1. If typeA or typeB is nullable, return false.
         2. Let typeA be the nullable type of typeA
         3. Let typeB be the nullable type of typeB
    4. If typeA or typeB is List.
         1. If typeA or typeB is not List, return false.
         2. Let typeA be the item type of typeA
         3. Let typeB be the item type of typeB
         4. Repeat from step 3.
    5. If typeA or typeB is Scalar or Enum.
         1. If typeA and typeB are the same type return true, otherwise
            return false.
    6. Assert: typeA and typeB are both composite types.
    7. Let mergedSet be the result of adding the selection set of fieldA
       and the selection set of fieldB.
    8. Let fieldsForName be the set of selections with a given response
       name in mergedSet including visiting fragments and inline
       fragments.
    9. Given each pair of members subfieldA and subfieldB in
       fieldsForName:
         1. If [1055]SameResponseShape(subfieldA, subfieldB) is false,
            return false.
   10. Return true.

        [1056]Explanatory Text

   If multiple field selections with the same response names are
   encountered during execution, the field and arguments to execute and
   the resulting value should be unambiguous. Therefore any two field
   selections which might both be encountered for the same object are only
   valid if they are equivalent.

   During execution, the simultaneous execution of fields with the same
   response name is accomplished by [1057]MergeSelectionSets() and
   [1058]CollectFields().

   For simple hand-written GraphQL, this rule is obviously a clear
   developer error, however nested fragments can make this difficult to
   detect manually.

   The following selections correctly merge:
[1059]Example No. 118fragment mergeIdenticalFields on Dog {
  name
  name
}

fragment mergeIdenticalAliasesAndFields on Dog {
  otherName: name
  otherName: name
}

   The following is not able to merge:
[1060]Counter Example No. 119fragment conflictingBecauseAlias on Dog {
  name: nickname
  name
}

   Identical arguments are also merged if they have identical arguments.
   Both values and variables can be correctly merged.

   For example the following correctly merge:
[1061]Example No. 120fragment mergeIdenticalFieldsWithIdenticalArgs on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: SIT)
}

fragment mergeIdenticalFieldsWithIdenticalValues on Dog {
  doesKnowCommand(dogCommand: $dogCommand)
  doesKnowCommand(dogCommand: $dogCommand)
}

   The following do not correctly merge:
[1062]Counter Example No. 121fragment conflictingArgsOnValues on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: HEEL)
}

fragment conflictingArgsValueAndVar on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: $dogCommand)
}

fragment conflictingArgsWithVars on Dog {
  doesKnowCommand(dogCommand: $varOne)
  doesKnowCommand(dogCommand: $varTwo)
}

fragment differingArgs on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand
}

   The following fields would not merge together, however both cannot be
   encountered against the same object, so they are safe:
[1063]Example No. 122fragment safeDifferingFields on Pet {
  ... on Dog {
    volume: barkVolume
  }
  ... on Cat {
    volume: meowVolume
  }
}

fragment safeDifferingArgs on Pet {
  ... on Dog {
    doesKnowCommand(dogCommand: SIT)
  }
  ... on Cat {
    doesKnowCommand(catCommand: JUMP)
  }
}

   However, the field responses must be shapes which can be merged. For
   example, scalar values must not differ. In this example, someValue
   might be a String or an Int:
[1064]Counter Example No. 123fragment conflictingDifferingResponses on Pet {
  ... on Dog {
    someValue: nickname
  }
  ... on Cat {
    someValue: meowVolume
  }
}

  [1065]5.3.3Leaf Field Selections

        [1066]Formal Specification

     * For each selection in the document
     * Let selectionType be the result type of selection
     * If selectionType is a scalar or enum:
          + The subselection set of that selection must be empty
     * If selectionType is an interface, union, or object
          + The subselection set of that selection must NOT BE empty

        [1067]Explanatory Text

   Field selections on scalars or enums are never allowed, because they
   are the leaf nodes of any GraphQL operation.

   The following is valid.
[1068]Example No. 124fragment scalarSelection on Dog {
  barkVolume
}

   The following is invalid.
[1069]Counter Example No. 125fragment scalarSelectionsNotAllowedOnInt on Dog {
  barkVolume {
    sinceWhen
  }
}

   Conversely the leaf field selections of GraphQL operations must be of
   type scalar or enum. Leaf selections on objects, interfaces, and unions
   without subfields are disallowed.

   Let's assume the following additions to the query root operation type
   of the schema:
[1070]Example No. 126extend type Query {
  human: Human
  pet: Pet
  catOrDog: CatOrDog
}

   The following examples are invalid
[1071]Counter Example No. 127query directQueryOnObjectWithoutSubFields {
  human
}

query directQueryOnInterfaceWithoutSubFields {
  pet
}

query directQueryOnUnionWithoutSubFields {
  catOrDog
}

[1072]5.4Arguments

   Arguments are provided to both fields and directives. The following
   validation rules apply in both cases.

  [1073]5.4.1Argument Names

        [1074]Formal Specification

     * For each argument in the document
     * Let argumentName be the Name of argument.
     * Let argumentDefinition be the argument definition provided by the
       parent field or definition named argumentName.
     * argumentDefinition must exist.

        [1075]Explanatory Text

   Every argument provided to a field or directive must be defined in the
   set of possible arguments of that field or directive.

   For example the following are valid:
[1076]Example No. 128fragment argOnRequiredArg on Dog {
  doesKnowCommand(dogCommand: SIT)
}

fragment argOnOptional on Dog {
  isHouseTrained(atOtherHomes: true) @include(if: true)
}

   the following is invalid since command is not defined on DogCommand.
[1077]Counter Example No. 129fragment invalidArgName on Dog {
  doesKnowCommand(command: CLEAN_UP_HOUSE)
}

   and this is also invalid as unless is not defined on @include.
[1078]Counter Example No. 130fragment invalidArgName on Dog {
  isHouseTrained(atOtherHomes: true) @include(unless: false)
}

   In order to explore more complicated argument examples, let's add the
   following to our type system:
[1079]Example No. 131type Arguments {
  multipleRequirements(x: Int!, y: Int!): Int!
  booleanArgField(booleanArg: Boolean): Boolean
  floatArgField(floatArg: Float): Float
  intArgField(intArg: Int): Int
  nonNullBooleanArgField(nonNullBooleanArg: Boolean!): Boolean!
  booleanListArgField(booleanListArg: [Boolean]!): [Boolean]
  optionalNonNullBooleanArgField(optionalBooleanArg: Boolean! = false): Boolean!
}

extend type Query {
  arguments: Arguments
}

   Order does not matter in arguments. Therefore both the following
   examples are valid.
[1080]Example No. 132fragment multipleArgs on Arguments {
  multipleRequirements(x: 1, y: 2)
}

fragment multipleArgsReverseOrder on Arguments {
  multipleRequirements(y: 2, x: 1)
}

  [1081]5.4.2Argument Uniqueness

   Fields and directives treat arguments as a mapping of argument name to
   value. More than one argument with the same name in an argument set is
   ambiguous and invalid.

        [1082]Formal Specification

     * For each argument in the Document.
     * Let argumentName be the Name of argument.
     * Let arguments be all Arguments named argumentName in the Argument
       Set which contains argument.
     * arguments must be the set containing only argument.

    [1083]5.4.2.1Required Arguments

     * For each Field or Directive in the document.
     * Let arguments be the arguments provided by the Field or Directive.
     * Let argumentDefinitions be the set of argument definitions of that
       Field or Directive.
     * For each argumentDefinition in argumentDefinitions:
          + Let type be the expected type of argumentDefinition.
          + Let defaultValue be the default value of argumentDefinition.
          + If type is Non-Null and defaultValue does not exist:
               o Let argumentName be the name of argumentDefinition.
               o Let argument be the argument in arguments named
                 argumentName
               o argument must exist.
               o Let value be the value of argument.
               o value must not be the null literal.

        [1084]Explanatory Text

   Arguments can be required. An argument is required if the argument type
   is non-null and does not have a default value. Otherwise, the argument
   is optional.

   For example the following are valid:
[1085]Example No. 133fragment goodBooleanArg on Arguments {
  booleanArgField(booleanArg: true)
}

fragment goodNonNullArg on Arguments {
  nonNullBooleanArgField(nonNullBooleanArg: true)
}

   The argument can be omitted from a field with a nullable argument.

   Therefore the following fragment is valid:
[1086]Example No. 134fragment goodBooleanArgDefault on Arguments {
  booleanArgField
}

   but this is not valid on a required argument.
[1087]Counter Example No. 135fragment missingRequiredArg on Arguments {
  nonNullBooleanArgField
}

   Providing the explicit value null is also not valid since required
   arguments always have a non-null type.
[1088]Counter Example No. 136fragment missingRequiredArg on Arguments {
  nonNullBooleanArgField(nonNullBooleanArg: null)
}

[1089]5.5Fragments

  [1090]5.5.1Fragment Declarations

    [1091]5.5.1.1Fragment Name Uniqueness

        [1092]Formal Specification

     * For each fragment definition fragment in the document
     * Let fragmentName be the name of fragment.
     * Let fragments be all fragment definitions in the document named
       fragmentName.
     * fragments must be a set of one.

        [1093]Explanatory Text

   Fragment definitions are referenced in fragment spreads by name. To
   avoid ambiguity, each fragment's name must be unique within a document.

   Inline fragments are not considered fragment definitions, and are
   unaffected by this validation rule.

   For example the following document is valid:
[1094]Example No. 137{
  dog {
    ...fragmentOne
    ...fragmentTwo
  }
}

fragment fragmentOne on Dog {
  name
}

fragment fragmentTwo on Dog {
  owner {
    name
  }
}

   While this document is invalid:
[1095]Counter Example No. 138{
  dog {
    ...fragmentOne
  }
}

fragment fragmentOne on Dog {
  name
}

fragment fragmentOne on Dog {
  owner {
    name
  }
}

    [1096]5.5.1.2Fragment Spread Type Existence

        [1097]Formal Specification

     * For each named spread namedSpread in the document
     * Let fragment be the target of namedSpread
     * The target type of fragment must be defined in the schema

        [1098]Explanatory Text

   Fragments must be specified on types that exist in the schema. This
   applies for both named and inline fragments. If they are not defined in
   the schema, the fragment is invalid.

   For example the following fragments are valid:
[1099]Example No. 139fragment correctType on Dog {
  name
}

fragment inlineFragment on Dog {
  ... on Dog {
    name
  }
}

fragment inlineFragment2 on Dog {
  ... @include(if: true) {
    name
  }
}

   and the following do not validate:
[1100]Counter Example No. 140fragment notOnExistingType on NotInSchema {
  name
}

fragment inlineNotExistingType on Dog {
  ... on NotInSchema {
    name
  }
}

    [1101]5.5.1.3Fragments On Composite Types

        [1102]Formal Specification

     * For each fragment defined in the document.
     * The target type of fragment must have kind UNION, INTERFACE, or
       OBJECT.

        [1103]Explanatory Text

   Fragments can only be declared on unions, interfaces, and objects. They
   are invalid on scalars. They can only be applied on non-leaf fields.
   This rule applies to both inline and named fragments.

   The following fragment declarations are valid:
[1104]Example No. 141fragment fragOnObject on Dog {
  name
}

fragment fragOnInterface on Pet {
  name
}

fragment fragOnUnion on CatOrDog {
  ... on Dog {
    name
  }
}

   and the following are invalid:
[1105]Counter Example No. 142fragment fragOnScalar on Int {
  something
}

fragment inlineFragOnScalar on Dog {
  ... on Boolean {
    somethingElse
  }
}

    [1106]5.5.1.4Fragments Must Be Used

        [1107]Formal Specification

     * For each fragment defined in the document.
     * fragment must be the target of at least one spread in the document

        [1108]Explanatory Text

   Defined fragments must be used within a document.

   For example the following is an invalid document:
[1109]Counter Example No. 143fragment nameFragment on Dog { # unused
  name
}

{
  dog {
    name
  }
}

  [1110]5.5.2Fragment Spreads

   Field selection is also determined by spreading fragments into one
   another. The selection set of the target fragment is combined into the
   selection set at the level at which the target fragment is referenced.

    [1111]5.5.2.1Fragment spread target defined

        [1112]Formal Specification

     * For every namedSpread in the document.
     * Let fragment be the target of namedSpread
     * fragment must be defined in the document

        [1113]Explanatory Text

   Named fragment spreads must refer to fragments defined within the
   document. It is a validation error if the target of a spread is not
   defined.
[1114]Counter Example No. 144{
  dog {
    ...undefinedFragment
  }
}

    [1115]5.5.2.2Fragment spreads must not form cycles

        [1116]Formal Specification

     * For each fragmentDefinition in the document
     * Let visited be the empty set.
     * [1117]DetectFragmentCycles(fragmentDefinition, visited)

   [1118]DetectFragmentCycles(fragmentDefinition, visited)
    1. Let spreads be all fragment spread descendants of
       fragmentDefinition
    2. For each spread in spreads
         1. visited must not contain spread
         2. Let nextVisited be the set including spread and members of
            visited
         3. Let nextFragmentDefinition be the target of spread
         4. [1119]DetectFragmentCycles(nextFragmentDefinition,
            nextVisited)

        [1120]Explanatory Text

   The graph of fragment spreads must not form any cycles including
   spreading itself. Otherwise an operation could infinitely spread or
   infinitely execute on cycles in the underlying data.

   This invalidates fragments that would result in an infinite spread:
[1121]Counter Example No. 145{
  dog {
    ...nameFragment
  }
}

fragment nameFragment on Dog {
  name
  ...barkVolumeFragment
}

fragment barkVolumeFragment on Dog {
  barkVolume
  ...nameFragment
}

   If the above fragments were inlined, this would result in the
   infinitely large:
[1122]Example No. 146{
  dog {
    name
    barkVolume
    name
    barkVolume
    name
    barkVolume
    name
    # forever...
  }
}

   This also invalidates fragments that would result in an infinite
   recursion when executed against cyclic data:
[1123]Counter Example No. 147{
  dog {
    ...dogFragment
  }
}

fragment dogFragment on Dog {
  name
  owner {
    ...ownerFragment
  }
}

fragment ownerFragment on Human {
  name
  pets {
    ...dogFragment
  }
}

    [1124]5.5.2.3Fragment spread is possible

        [1125]Formal Specification

     * For each spread (named or inline) defined in the document.
     * Let fragment be the target of spread
     * Let fragmentType be the type condition of fragment
     * Let parentType be the type of the selection set containing spread
     * Let applicableTypes be the intersection of
       [1126]GetPossibleTypes(fragmentType) and
       [1127]GetPossibleTypes(parentType)
     * applicableTypes must not be empty.

   [1128]GetPossibleTypes(type)
    1. If type is an object type, return a set containing type
    2. If type is an interface type, return the set of types implementing
       type
    3. If type is a union type, return the set of possible types of type

        [1129]Explanatory Text

   Fragments are declared on a type and will only apply when the runtime
   object type matches the type condition. They also are spread within the
   context of a parent type. A fragment spread is only valid if its type
   condition could ever apply within the parent type.

      [1130]5.5.2.3.1Object Spreads In Object Scope

   In the scope of an object type, the only valid object type fragment
   spread is one that applies to the same type that is in scope.

   For example
[1131]Example No. 148fragment dogFragment on Dog {
  ... on Dog {
    barkVolume
  }
}

   and the following is invalid
[1132]Counter Example No. 149fragment catInDogFragmentInvalid on Dog {
  ... on Cat {
    meowVolume
  }
}

      [1133]5.5.2.3.2Abstract Spreads in Object Scope

   In scope of an object type, unions or interface spreads can be used if
   the object type implements the interface or is a member of the union.

   For example
[1134]Example No. 150fragment petNameFragment on Pet {
  name
}

fragment interfaceWithinObjectFragment on Dog {
  ...petNameFragment
}

   is valid because Dog implements Pet.

   Likewise
[1135]Example No. 151fragment catOrDogNameFragment on CatOrDog {
  ... on Cat {
    meowVolume
  }
}

fragment unionWithObjectFragment on Dog {
  ...catOrDogNameFragment
}

   is valid because Dog is a member of the CatOrDog union. It is worth
   noting that if one inspected the contents of the CatOrDogNameFragment
   you could note that no valid results would ever be returned. However we
   do not specify this as invalid because we only consider the fragment
   declaration, not its body.

      [1136]5.5.2.3.3Object Spreads In Abstract Scope

   Union or interface spreads can be used within the context of an object
   type fragment, but only if the object type is one of the possible types
   of that interface or union.

   For example, the following fragments are valid:
[1137]Example No. 152fragment petFragment on Pet {
  name
  ... on Dog {
    barkVolume
  }
}

fragment catOrDogFragment on CatOrDog {
  ... on Cat {
    meowVolume
  }
}

   petFragment is valid because Dog implements the interface Pet.
   catOrDogFragment is valid because Cat is a member of the CatOrDog
   union.

   By contrast the following fragments are invalid:
[1138]Counter Example No. 153fragment sentientFragment on Sentient {
  ... on Dog {
    barkVolume
  }
}

fragment humanOrAlienFragment on HumanOrAlien {
  ... on Cat {
    meowVolume
  }
}

   Dog does not implement the interface Sentient and therefore
   sentientFragment can never return meaningful results. Therefore the
   fragment is invalid. Likewise Cat is not a member of the union
   HumanOrAlien, and it can also never return meaningful results, making
   it invalid.

      [1139]5.5.2.3.4Abstract Spreads in Abstract Scope

   Union or interfaces fragments can be used within each other. As long as
   there exists at least one object type that exists in the intersection
   of the possible types of the scope and the spread, the spread is
   considered valid.

   So for example
[1140]Example No. 154fragment unionWithInterface on Pet {
  ...dogOrHumanFragment
}

fragment dogOrHumanFragment on DogOrHuman {
  ... on Dog {
    barkVolume
  }
}

   is considered valid because Dog implements interface Pet and is a
   member of DogOrHuman.

   However
[1141]Counter Example No. 155fragment nonIntersectingInterfaces on Pet {
  ...sentientFragment
}

fragment sentientFragment on Sentient {
  name
}

   is not valid because there exists no type that implements both Pet and
   Sentient.

        [1142]Interface Spreads in implemented Interface Scope

   Additionally, an interface type fragment can always be spread into an
   interface scope which it implements.

   In the example below, the ...resourceFragment fragments spreads is
   valid, since Resource implements Node.
[1143]Example No. 156interface Node {
  id: ID!
}

interface Resource implements Node {
  id: ID!
  url: String
}

fragment interfaceWithInterface on Node {
  ...resourceFragment
}

fragment resourceFragment on Resource {
  url
}

[1144]5.6Values

  [1145]5.6.1Values of Correct Type

        [1146]Formal Specification

     * For each input Value value in the document.
          + Let type be the type expected in the position value is found.
          + value must be coercible to type.

        [1147]Explanatory Text

   Literal values must be compatible with the type expected in the
   position they are found as per the coercion rules defined in the Type
   System chapter.

   The type expected in a position includes the type defined by the
   argument a value is provided for, the type defined by an input object
   field a value is provided for, and the type of a variable definition a
   default value is provided for.

   The following examples are valid use of value literals:
[1148]Example No. 157fragment goodBooleanArg on Arguments {
  booleanArgField(booleanArg: true)
}

fragment coercedIntIntoFloatArg on Arguments {
  # Note: The input coercion rules for Float allow Int literals.
  floatArgField(floatArg: 123)
}

query goodComplexDefaultValue($search: ComplexInput = { name: "Fido" }) {
  findDog(complex: $search)
}

   Non-coercible values (such as a String into an Int) are invalid. The
   following examples are invalid:
[1149]Counter Example No. 158fragment stringIntoInt on Arguments {
  intArgField(intArg: "123")
}

query badComplexValue {
  findDog(complex: { name: 123 })
}

  [1150]5.6.2Input Object Field Names

        [1151]Formal Specification

     * For each Input Object Field inputField in the document
     * Let inputFieldName be the Name of inputField.
     * Let inputFieldDefinition be the input field definition provided by
       the parent input object type named inputFieldName.
     * inputFieldDefinition must exist.

        [1152]Explanatory Text

   Every input field provided in an input object value must be defined in
   the set of possible fields of that input object's expected type.

   For example the following example input object is valid:
[1153]Example No. 159{
  findDog(complex: { name: "Fido" })
}

   While the following example input-object uses a field
   "favoriteCookieFlavor" which is not defined on the expected type:
[1154]Counter Example No. 160{
  findDog(complex: { favoriteCookieFlavor: "Bacon" })
}

  [1155]5.6.3Input Object Field Uniqueness

        [1156]Formal Specification

     * For each input object value inputObject in the document.
     * For every inputField in inputObject
          + Let name be the Name of inputField.
          + Let fields be all Input Object Fields named name in
            inputObject.
          + fields must be the set containing only inputField.

        [1157]Explanatory Text

   Input objects must not contain more than one field of the same name,
   otherwise an ambiguity would exist which includes an ignored portion of
   syntax.

   For example the following document will not pass validation.
[1158]Counter Example No. 161{
  field(arg: { field: true, field: false })
}

  [1159]5.6.4Input Object Required Fields

        [1160]Formal Specification

     * For each Input Object in the document.
          + Let fields be the fields provided by that Input Object.
          + Let fieldDefinitions be the set of input field definitions of
            that Input Object.
     * For each fieldDefinition in fieldDefinitions:
          + Let type be the expected type of fieldDefinition.
          + Let defaultValue be the default value of fieldDefinition.
          + If type is Non-Null and defaultValue does not exist:
               o Let fieldName be the name of fieldDefinition.
               o Let field be the input field in fields named fieldName
               o field must exist.
               o Let value be the value of field.
               o value must not be the null literal.

        [1161]Explanatory Text

   Input object fields may be required. Much like a field may have
   required arguments, an input object may have required fields. An input
   field is required if it has a non-null type and does not have a default
   value. Otherwise, the input object field is optional.

[1162]5.7Directives

  [1163]5.7.1Directives Are Defined

        [1164]Formal Specification

     * For every directive in a document.
     * Let directiveName be the name of directive.
     * Let directiveDefinition be the directive named directiveName.
     * directiveDefinition must exist.

        [1165]Explanatory Text

   GraphQL services define what directives they support. For each usage of
   a directive, the directive must be available on that service.

  [1166]5.7.2Directives Are In Valid Locations

        [1167]Formal Specification

     * For every directive in a document.
     * Let directiveName be the name of directive.
     * Let directiveDefinition be the directive named directiveName.
     * Let locations be the valid locations for directiveDefinition.
     * Let adjacent be the AST node the directive affects.
     * adjacent must be represented by an item within locations.

        [1168]Explanatory Text

   GraphQL services define what directives they support and where they
   support them. For each usage of a directive, the directive must be used
   in a location that the service has declared support for.

   For example the following document will not pass validation because
   @skip does not provide QUERY as a valid location.
[1169]Counter Example No. 162query @skip(if: $foo) {
  field
}

  [1170]5.7.3Directives Are Unique Per Location

        [1171]Formal Specification

     * For every location in the document for which Directives can apply:
          + Let directives be the set of Directives which apply to
            location and are not repeatable.
          + For each directive in directives:
               o Let directiveName be the name of directive.
               o Let namedDirectives be the set of all Directives named
                 directiveName in directives.
               o namedDirectives must be a set of one.

        [1172]Explanatory Text

   Directives are used to describe some metadata or behavioral change on
   the definition they apply to. When more than one directive of the same
   name is used, the expected metadata or behavior becomes ambiguous,
   therefore only one of each directive is allowed per location.

   For example, the following document will not pass validation because
   @skip has been used twice for the same field:
[1173]Counter Example No. 163query ($foo: Boolean = true, $bar: Boolean = false)
 {
  field @skip(if: $foo) @skip(if: $bar)
}

   However the following example is valid because @skip has been used only
   once per location, despite being used twice in the operation and on the
   same named field:
[1174]Example No. 164query ($foo: Boolean = true, $bar: Boolean = false) {
  field @skip(if: $foo) {
    subfieldA
  }
  field @skip(if: $bar) {
    subfieldB
  }
}

[1175]5.8Variables

  [1176]5.8.1Variable Uniqueness

        [1177]Formal Specification

     * For every operation in the document
          + For every variable defined on operation
               o Let variableName be the name of variable
               o Let variables be the set of all variables named
                 variableName on operation
               o variables must be a set of one

        [1178]Explanatory Text

   If any operation defines more than one variable with the same name, it
   is ambiguous and invalid. It is invalid even if the type of the
   duplicate variable is the same.
[1179]Counter Example No. 165query houseTrainedQuery($atOtherHomes: Boolean, $at
OtherHomes: Boolean) {
  dog {
    isHouseTrained(atOtherHomes: $atOtherHomes)
  }
}

   It is valid for multiple operations to define a variable with the same
   name. If two operations reference the same fragment, it might actually
   be necessary:
[1180]Example No. 166query A($atOtherHomes: Boolean) {
  ...HouseTrainedFragment
}

query B($atOtherHomes: Boolean) {
  ...HouseTrainedFragment
}

fragment HouseTrainedFragment on Query {
  dog {
    isHouseTrained(atOtherHomes: $atOtherHomes)
  }
}

  [1181]5.8.2Variables Are Input Types

        [1182]Formal Specification

     * For every operation in a document
     * For every variable on each operation
          + Let variableType be the type of variable
          + [1183]IsInputType(variableType) must be true

        [1184]Explanatory Text

   Variables can only be input types. Objects, unions, and interfaces
   cannot be used as inputs.

   For these examples, consider the following type system additions:
[1185]Example No. 167input ComplexInput {
  name: String
  owner: String
}

extend type Query {
  findDog(complex: ComplexInput): Dog
  booleanList(booleanListArg: [Boolean!]): Boolean
}

   The following operations are valid:
[1186]Example No. 168query takesBoolean($atOtherHomes: Boolean) {
  dog {
    isHouseTrained(atOtherHomes: $atOtherHomes)
  }
}

query takesComplexInput($complexInput: ComplexInput) {
  findDog(complex: $complexInput) {
    name
  }
}

query TakesListOfBooleanBang($booleans: [Boolean!]) {
  booleanList(booleanListArg: $booleans)
}

   The following operations are invalid:
[1187]Counter Example No. 169query takesCat($cat: Cat) {
  # ...
}

query takesDogBang($dog: Dog!) {
  # ...
}

query takesListOfPet($pets: [Pet]) {
  # ...
}

query takesCatOrDog($catOrDog: CatOrDog) {
  # ...
}

  [1188]5.8.3All Variable Uses Defined

        [1189]Formal Specification

     * For each operation in a document
          + For each variableUsage in scope, variable must be in
            operation`s variable list.
          + Let fragments be every fragment referenced by that operation
            transitively
          + For each fragment in fragments
               o For each variableUsage in scope of fragment, variable
                 must be in operation`s variable list.

        [1190]Explanatory Text

   Variables are scoped on a per-operation basis. That means that any
   variable used within the context of an operation must be defined at the
   top level of that operation

   For example:
[1191]Example No. 170query variableIsDefined($atOtherHomes: Boolean) {
  dog {
    isHouseTrained(atOtherHomes: $atOtherHomes)
  }
}

   is valid. $atOtherHomes is defined by the operation.

   By contrast the following document is invalid:
[1192]Counter Example No. 171query variableIsNotDefined {
  dog {
    isHouseTrained(atOtherHomes: $atOtherHomes)
  }
}

   $atOtherHomes is not defined by the operation.

   Fragments complicate this rule. Any fragment transitively included by
   an operation has access to the variables defined by that operation.
   Fragments can appear within multiple operations and therefore variable
   usages must correspond to variable definitions in all of those
   operations.

   For example the following is valid:
[1193]Example No. 172query variableIsDefinedUsedInSingleFragment($atOtherHomes:
Boolean) {
  dog {
    ...isHouseTrainedFragment
  }
}

fragment isHouseTrainedFragment on Dog {
  isHouseTrained(atOtherHomes: $atOtherHomes)
}

   since isHouseTrainedFragment is used within the context of the
   operation variableIsDefinedUsedInSingleFragment and the variable is
   defined by that operation.

   On the other hand, if a fragment is included within an operation that
   does not define a referenced variable, the document is invalid.
[1194]Counter Example No. 173query variableIsNotDefinedUsedInSingleFragment {
  dog {
    ...isHouseTrainedFragment
  }
}

fragment isHouseTrainedFragment on Dog {
  isHouseTrained(atOtherHomes: $atOtherHomes)
}

   This applies transitively as well, so the following also fails:
[1195]Counter Example No. 174query variableIsNotDefinedUsedInNestedFragment {
  dog {
    ...outerHouseTrainedFragment
  }
}

fragment outerHouseTrainedFragment on Dog {
  ...isHouseTrainedFragment
}

fragment isHouseTrainedFragment on Dog {
  isHouseTrained(atOtherHomes: $atOtherHomes)
}

   Variables must be defined in all operations in which a fragment is
   used.
[1196]Example No. 175query houseTrainedQueryOne($atOtherHomes: Boolean) {
  dog {
    ...isHouseTrainedFragment
  }
}

query houseTrainedQueryTwo($atOtherHomes: Boolean) {
  dog {
    ...isHouseTrainedFragment
  }
}

fragment isHouseTrainedFragment on Dog {
  isHouseTrained(atOtherHomes: $atOtherHomes)
}

   However the following does not validate:
[1197]Counter Example No. 176query houseTrainedQueryOne($atOtherHomes: Boolean)
{
  dog {
    ...isHouseTrainedFragment
  }
}

query houseTrainedQueryTwoNotDefined {
  dog {
    ...isHouseTrainedFragment
  }
}

fragment isHouseTrainedFragment on Dog {
  isHouseTrained(atOtherHomes: $atOtherHomes)
}

   This is because houseTrainedQueryTwoNotDefined does not define a
   variable $atOtherHomes but that variable is used by
   isHouseTrainedFragment which is included in that operation.

  [1198]5.8.4All Variables Used

        [1199]Formal Specification

     * For every operation in the document.
     * Let variables be the variables defined by that operation
     * Each variable in variables must be used at least once in either the
       operation scope itself or any fragment transitively referenced by
       that operation.

        [1200]Explanatory Text

   All variables defined by an operation must be used in that operation or
   a fragment transitively included by that operation. Unused variables
   cause a validation error.

   For example the following is invalid:
[1201]Counter Example No. 177query variableUnused($atOtherHomes: Boolean) {
  dog {
    isHouseTrained
  }
}

   because $atOtherHomes is not referenced.

   These rules apply to transitive fragment spreads as well:
[1202]Example No. 178query variableUsedInFragment($atOtherHomes: Boolean) {
  dog {
    ...isHouseTrainedFragment
  }
}

fragment isHouseTrainedFragment on Dog {
  isHouseTrained(atOtherHomes: $atOtherHomes)
}

   The above is valid since $atOtherHomes is used in
   isHouseTrainedFragment which is included by variableUsedInFragment.

   If that fragment did not have a reference to $atOtherHomes it would be
   not valid:
[1203]Counter Example No. 179query variableNotUsedWithinFragment($atOtherHomes:
Boolean) {
  dog {
    ...isHouseTrainedWithoutVariableFragment
  }
}

fragment isHouseTrainedWithoutVariableFragment on Dog {
  isHouseTrained
}

   All operations in a document must use all of their variables.

   As a result, the following document does not validate.
[1204]Counter Example No. 180query queryWithUsedVar($atOtherHomes: Boolean) {
  dog {
    ...isHouseTrainedFragment
  }
}

query queryWithExtraVar($atOtherHomes: Boolean, $extra: Int) {
  dog {
    ...isHouseTrainedFragment
  }
}

fragment isHouseTrainedFragment on Dog {
  isHouseTrained(atOtherHomes: $atOtherHomes)
}

   This document is not valid because queryWithExtraVar defines an
   extraneous variable.

  [1205]5.8.5All Variable Usages are Allowed

        [1206]Formal Specification

     * For each operation in document:
     * Let variableUsages be all usages transitively included in the
       operation.
     * For each variableUsage in variableUsages:
          + Let variableName be the name of variableUsage.
          + Let variableDefinition be the [1207]VariableDefinition named
            variableName defined within operation.
          + [1208]IsVariableUsageAllowed(variableDefinition,
            variableUsage) must be true.

   [1209]IsVariableUsageAllowed(variableDefinition, variableUsage)
    1. Let variableType be the expected type of variableDefinition.
    2. Let locationType be the expected type of the [1210]Argument,
       [1211]ObjectField, or [1212]ListValue entry where variableUsage is
       located.
    3. If locationType is a non-null type AND variableType is NOT a
       non-null type:
         1. Let hasNonNullVariableDefaultValue be true if a default value
            exists for variableDefinition and is not the value null.
         2. Let hasLocationDefaultValue be true if a default value exists
            for the [1213]Argument or [1214]ObjectField where
            variableUsage is located.
         3. If hasNonNullVariableDefaultValue is NOT true AND
            hasLocationDefaultValue is NOT true, return false.
         4. Let nullableLocationType be the unwrapped nullable type of
            locationType.
         5. Return [1215]AreTypesCompatible(variableType,
            nullableLocationType).
    4. Return [1216]AreTypesCompatible(variableType, locationType).

   [1217]AreTypesCompatible(variableType, locationType)
    1. If locationType is a non-null type:
         1. If variableType is NOT a non-null type, return false.
         2. Let nullableLocationType be the unwrapped nullable type of
            locationType.
         3. Let nullableVariableType be the unwrapped nullable type of
            variableType.
         4. Return [1218]AreTypesCompatible(nullableVariableType,
            nullableLocationType).
    2. Otherwise, if variableType is a non-null type:
         1. Let nullableVariableType be the nullable type of variableType.
         2. Return [1219]AreTypesCompatible(nullableVariableType,
            locationType).
    3. Otherwise, if locationType is a list type:
         1. If variableType is NOT a list type, return false.
         2. Let itemLocationType be the unwrapped item type of
            locationType.
         3. Let itemVariableType be the unwrapped item type of
            variableType.
         4. Return [1220]AreTypesCompatible(itemVariableType,
            itemLocationType).
    4. Otherwise, if variableType is a list type, return false.
    5. Return true if variableType and locationType are identical,
       otherwise false.

        [1221]Explanatory Text

   Variable usages must be compatible with the arguments they are passed
   to.

   Validation failures occur when variables are used in the context of
   types that are complete mismatches, or if a nullable type in a variable
   is passed to a non-null argument type.

   Types must match:
[1222]Counter Example No. 181query intCannotGoIntoBoolean($intArg: Int) {
  arguments {
    booleanArgField(booleanArg: $intArg)
  }
}

   $intArg typed as Int cannot be used as an argument to booleanArg, typed
   as Boolean.

   List cardinality must also be the same. For example, lists cannot be
   passed into singular values.
[1223]Counter Example No. 182query booleanListCannotGoIntoBoolean($booleanListAr
g: [Boolean]) {
  arguments {
    booleanArgField(booleanArg: $booleanListArg)
  }
}

   Nullability must also be respected. In general a nullable variable
   cannot be passed to a non-null argument.
[1224]Counter Example No. 183query booleanArgQuery($booleanArg: Boolean) {
  arguments {
    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)
  }
}

   For list types, the same rules around nullability apply to both outer
   types and inner types. A nullable list cannot be passed to a non-null
   list, and a list of nullable values cannot be passed to a list of
   non-null values. The following is valid:
[1225]Example No. 184query nonNullListToList($nonNullBooleanList: [Boolean]!) {
  arguments {
    booleanListArgField(booleanListArg: $nonNullBooleanList)
  }
}

   However, a nullable list cannot be passed to a non-null list:
[1226]Counter Example No. 185query listToNonNullList($booleanList: [Boolean]) {
  arguments {
    nonNullBooleanListField(nonNullBooleanListArg: $booleanList)
  }
}

   This would fail validation because a [T] cannot be passed to a [T]!.
   Similarly a [T] cannot be passed to a [T!].

        [1227]Allowing optional variables when default values exist

   A notable exception to typical variable type compatibility is allowing
   a variable definition with a nullable type to be provided to a non-null
   location as long as either that variable or that location provides a
   default value.

   In the example below, an optional variable $booleanArg is allowed to be
   used in the non-null argument optionalBooleanArg because the field
   argument is optional since it provides a default value in the schema.
[1228]Example No. 186query booleanArgQueryWithDefault($booleanArg: Boolean) {
  arguments {
    optionalNonNullBooleanArgField(optionalBooleanArg: $booleanArg)
  }
}

   In the example below, an optional variable $booleanArg is allowed to be
   used in the non-null argument (nonNullBooleanArg) because the variable
   provides a default value in the operation. This behavior is explicitly
   supported for compatibility with earlier editions of this
   specification. GraphQL authoring tools may wish to report this as a
   warning with the suggestion to replace Boolean with Boolean! to avoid
   ambiguity.
[1229]Example No. 187query booleanArgQueryWithDefault($booleanArg: Boolean = tru
e) {
  arguments {
    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)
  }
}

   [1230]Note The value null could still be provided to such a variable at
   runtime. A non-null argument must raise a field error if provided a
   null value.

                                [1231]6Execution

   GraphQL generates a response from a request via execution.

   A request for execution consists of a few pieces of information:
     * The schema to use, typically solely provided by the GraphQL
       service.
     * A [1232]Document which must contain GraphQL
       [1233]OperationDefinition and may contain [1234]FragmentDefinition.
     * Optionally: The name of the Operation in the Document to execute.
     * Optionally: Values for any Variables defined by the Operation.
     * An initial value corresponding to the root type being executed.
       Conceptually, an initial value represents the "universe" of data
       available via a GraphQL Service. It is common for a GraphQL Service
       to always use the same initial value for every request.

   Given this information, the result of [1235]ExecuteRequest() produces
   the response, to be formatted according to the Response section below.

[1236]6.1Executing Requests

   To execute a request, the executor must have a parsed [1237]Document
   and a selected operation name to run if the document defines multiple
   operations, otherwise the document is expected to only contain a single
   operation. The result of the request is determined by the result of
   executing this operation according to the "Executing Operations"
   section below.

   [1238]ExecuteRequest(schema, document, operationName, variableValues,
   initialValue)
    1. Let operation be the result of [1239]GetOperation(document,
       operationName).
    2. Let coercedVariableValues be the result of
       [1240]CoerceVariableValues(schema, operation, variableValues).
    3. If operation is a query operation:
         1. Return [1241]ExecuteQuery(operation, schema,
            coercedVariableValues, initialValue).
    4. Otherwise if operation is a mutation operation:
         1. Return [1242]ExecuteMutation(operation, schema,
            coercedVariableValues, initialValue).
    5. Otherwise if operation is a subscription operation:
         1. Return [1243]Subscribe(operation, schema,
            coercedVariableValues, initialValue).

   [1244]GetOperation(document, operationName)
    1. If operationName is null:
         1. If document contains exactly one operation.
              1. Return the Operation contained in the document.
         2. Otherwise raise a request error requiring operationName.
    2. Otherwise:
         1. Let operation be the Operation named operationName in
            document.
         2. If operation was not found, raise a request error.
         3. Return operation.

  [1245]6.1.1Validating Requests

   As explained in the Validation section, only requests which pass all
   validation rules should be executed. If validation errors are known,
   they should be reported in the list of "errors" in the response and the
   request must fail without execution.

   Typically validation is performed in the context of a request
   immediately before execution, however a GraphQL service may execute a
   request without immediately validating it if that exact same request is
   known to have been validated before. A GraphQL service should only
   execute requests which at some point were known to be free of any
   validation errors, and have since not changed.

   For example: the request may be validated during development, provided
   it does not later change, or a service may validate a request once and
   memoize the result to avoid validating the same request again in the
   future.

  [1246]6.1.2Coercing Variable Values

   If the operation has defined any variables, then the values for those
   variables need to be coerced using the input coercion rules of
   variable's declared type. If a request error is encountered during
   input coercion of variable values, then the operation fails without
   execution.

   [1247]CoerceVariableValues(schema, operation, variableValues)
    1. Let coercedValues be an empty unordered Map.
    2. Let variableDefinitions be the variables defined by operation.
    3. For each variableDefinition in variableDefinitions:
         1. Let variableName be the name of variableDefinition.
         2. Let variableType be the expected type of variableDefinition.
         3. Assert: [1248]IsInputType(variableType) must be true.
         4. Let defaultValue be the default value for variableDefinition.
         5. Let hasValue be true if variableValues provides a value for
            the name variableName.
         6. Let value be the value provided in variableValues for the name
            variableName.
         7. If hasValue is not true and defaultValue exists (including
            null):
              1. Add an entry to coercedValues named variableName with the
                 value defaultValue.
         8. Otherwise if variableType is a Non-Nullable type, and either
            hasValue is not true or value is null, raise a request error.
         9. Otherwise if hasValue is true:
              1. If value is null:
                   1. Add an entry to coercedValues named variableName
                      with the value null.
              2. Otherwise:
                   1. If value cannot be coerced according to the input
                      coercion rules of variableType, raise a request
                      error.
                   2. Let coercedValue be the result of coercing value
                      according to the input coercion rules of
                      variableType.
                   3. Add an entry to coercedValues named variableName
                      with the value coercedValue.
    4. Return coercedValues.

   [1249]Note This algorithm is very similar to
   [1250]CoerceArgumentValues().

[1251]6.2Executing Operations

   The type system, as described in the "Type System" section of the spec,
   must provide a query root operation type. If mutations or subscriptions
   are supported, it must also provide a mutation or subscription root
   operation type, respectively.

  [1252]6.2.1Query

   If the operation is a query, the result of the operation is the result
   of executing the operation's top level selection set with the query
   root operation type.

   An initial value may be provided when executing a query operation.

   [1253]ExecuteQuery(query, schema, variableValues, initialValue)
    1. Let queryType be the root Query type in schema.
    2. Assert: queryType is an Object type.
    3. Let selectionSet be the top level Selection Set in query.
    4. Let data be the result of running
       [1254]ExecuteSelectionSet(selectionSet, queryType, initialValue,
       variableValues) normally (allowing parallelization).
    5. Let errors be any field errors produced while executing the
       selection set.
    6. Return an unordered map containing data and errors.

  [1255]6.2.2Mutation

   If the operation is a mutation, the result of the operation is the
   result of executing the operation's top level selection set on the
   mutation root object type. This selection set should be executed
   serially.

   It is expected that the top level fields in a mutation operation
   perform side-effects on the underlying data system. Serial execution of
   the provided mutations ensures against race conditions during these
   side-effects.

   [1256]ExecuteMutation(mutation, schema, variableValues, initialValue)
    1. Let mutationType be the root Mutation type in schema.
    2. Assert: mutationType is an Object type.
    3. Let selectionSet be the top level Selection Set in mutation.
    4. Let data be the result of running
       [1257]ExecuteSelectionSet(selectionSet, mutationType, initialValue,
       variableValues) serially.
    5. Let errors be any field errors produced while executing the
       selection set.
    6. Return an unordered map containing data and errors.

  [1258]6.2.3Subscription

   If the operation is a subscription, the result is an event stream
   called the "Response Stream" where each event in the event stream is
   the result of executing the operation for each new event on an
   underlying "Source Stream".

   Executing a subscription operation creates a persistent function on the
   service that maps an underlying Source Stream to a returned Response
   Stream.

   [1259]Subscribe(subscription, schema, variableValues, initialValue)
    1. Let sourceStream be the result of running
       [1260]CreateSourceEventStream(subscription, schema, variableValues,
       initialValue).
    2. Let responseStream be the result of running
       [1261]MapSourceToResponseEvent(sourceStream, subscription, schema,
       variableValues)
    3. Return responseStream.

   [1262]Note In large scale subscription systems, the [1263]Subscribe()
   and [1264]ExecuteSubscriptionEvent() algorithms may be run on separate
   services to maintain predictable scaling properties. See the section
   below on Supporting Subscriptions at Scale.

   As an example, consider a chat application. To subscribe to new
   messages posted to the chat room, the client sends a request like so:
[1265]Example No. 188subscription NewMessages {
  newMessage(roomId: 123) {
    sender
    text
  }
}

   While the client is subscribed, whenever new messages are posted to
   chat room with ID "123", the selection for "sender" and "text" will be
   evaluated and published to the client, for example:
[1266]Example No. 189{
  "data": {
    "newMessage": {
      "sender": "Hagrid",
      "text": "You're a wizard!"
    }
  }
}

   The "new message posted to chat room" could use a "Pub-Sub" system
   where the chat room ID is the "topic" and each "publish" contains the
   sender and text.

        [1267]Event Streams

   An event stream represents a sequence of discrete events over time
   which can be observed. As an example, a "Pub-Sub" system may produce an
   event stream when "subscribing to a topic", with an event occurring on
   that event stream for each "publish" to that topic. Event streams may
   produce an infinite sequence of events or may complete at any point.
   Event streams may complete in response to an error or simply because no
   more events will occur. An observer may at any point decide to stop
   observing an event stream by cancelling it, after which it must receive
   no more events from that event stream.

        [1268]Supporting Subscriptions at Scale

   Supporting subscriptions is a significant change for any GraphQL
   service. Query and mutation operations are stateless, allowing scaling
   via cloning of GraphQL service instances. Subscriptions, by contrast,
   are stateful and require maintaining the GraphQL document, variables,
   and other context over the lifetime of the subscription.

   Consider the behavior of your system when state is lost due to the
   failure of a single machine in a service. Durability and availability
   may be improved by having separate dedicated services for managing
   subscription state and client connectivity.

        [1269]Delivery Agnostic

   GraphQL subscriptions do not require any specific serialization format
   or transport mechanism. Subscriptions specifies algorithms for the
   creation of a stream, the content of each payload on that stream, and
   the closing of that stream. There are intentionally no specifications
   for message acknowledgement, buffering, resend requests, or any other
   quality of service (QoS) details. Message serialization, transport
   mechanisms, and quality of service details should be chosen by the
   implementing service.

    [1270]6.2.3.1Source Stream

   A Source Stream represents the sequence of events, each of which will
   trigger a GraphQL execution corresponding to that event. Like field
   value resolution, the logic to create a Source Stream is
   application-specific.

   [1271]CreateSourceEventStream(subscription, schema, variableValues,
   initialValue)
    1. Let subscriptionType be the root Subscription type in schema.
    2. Assert: subscriptionType is an Object type.
    3. Let selectionSet be the top level Selection Set in subscription.
    4. Let groupedFieldSet be the result of
       [1272]CollectFields(subscriptionType, selectionSet,
       variableValues).
    5. If groupedFieldSet does not have exactly one entry, raise a request
       error.
    6. Let fields be the value of the first entry in groupedFieldSet.
    7. Let fieldName be the name of the first entry in fields. Note: This
       value is unaffected if an alias is used.
    8. Let field be the first entry in fields.
    9. Let argumentValues be the result of
       [1273]CoerceArgumentValues(subscriptionType, field, variableValues)
   10. Let fieldStream be the result of running
       [1274]ResolveFieldEventStream(subscriptionType, initialValue,
       fieldName, argumentValues).
   11. Return fieldStream.

   [1275]ResolveFieldEventStream(subscriptionType, rootValue, fieldName,
   argumentValues)
    1. Let resolver be the internal function provided by subscriptionType
       for determining the resolved event stream of a subscription field
       named fieldName.
    2. Return the result of calling resolver, providing rootValue and
       argumentValues.

   [1276]Note This [1277]ResolveFieldEventStream() algorithm is
   intentionally similar to [1278]ResolveFieldValue() to enable
   consistency when defining resolvers on any operation type.

    [1279]6.2.3.2Response Stream

   Each event in the underlying Source Stream triggers execution of the
   subscription selection set using that event as a root value.

   [1280]MapSourceToResponseEvent(sourceStream, subscription, schema,
   variableValues)
    1. Return a new event stream responseStream which yields events as
       follows:
    2. For each event on sourceStream:
         1. Let response be the result of running
            [1281]ExecuteSubscriptionEvent(subscription, schema,
            variableValues, event).
         2. Yield an event containing response.
    3. When responseStream completes: complete this event stream.

   [1282]ExecuteSubscriptionEvent(subscription, schema, variableValues,
   initialValue)
    1. Let subscriptionType be the root Subscription type in schema.
    2. Assert: subscriptionType is an Object type.
    3. Let selectionSet be the top level Selection Set in subscription.
    4. Let data be the result of running
       [1283]ExecuteSelectionSet(selectionSet, subscriptionType,
       initialValue, variableValues) normally (allowing parallelization).
    5. Let errors be any field errors produced while executing the
       selection set.
    6. Return an unordered map containing data and errors.

   [1284]Note The [1285]ExecuteSubscriptionEvent() algorithm is
   intentionally similar to [1286]ExecuteQuery() since this is how each
   event result is produced.

    [1287]6.2.3.3Unsubscribe

   Unsubscribe cancels the Response Stream when a client no longer wishes
   to receive payloads for a subscription. This may in turn also cancel
   the Source Stream. This is also a good opportunity to clean up any
   other resources used by the subscription.

   [1288]Unsubscribe(responseStream)
    1. Cancel responseStream

[1289]6.3Executing Selection Sets

   To execute a selection set, the object value being evaluated and the
   object type need to be known, as well as whether it must be executed
   serially, or may be executed in parallel.

   First, the selection set is turned into a grouped field set; then, each
   represented field in the grouped field set produces an entry into a
   response map.

   [1290]ExecuteSelectionSet(selectionSet, objectType, objectValue,
   variableValues)
    1. Let groupedFieldSet be the result of
       [1291]CollectFields(objectType, selectionSet, variableValues).
    2. Initialize resultMap to an empty ordered map.
    3. For each groupedFieldSet as responseKey and fields:
         1. Let fieldName be the name of the first entry in fields. Note:
            This value is unaffected if an alias is used.
         2. Let fieldType be the return type defined for the field
            fieldName of objectType.
         3. If fieldType is defined:
              1. Let responseValue be [1292]ExecuteField(objectType,
                 objectValue, fieldType, fields, variableValues).
              2. Set responseValue as the value for responseKey in
                 resultMap.
    4. Return resultMap.

   [1293]Note resultMap is ordered by which fields appear first in the
   operation. This is explained in greater detail in the Field Collection
   section below.

        [1294]Errors and Non-Null Fields

   If during [1295]ExecuteSelectionSet() a field with a non-null fieldType
   raises a field error then that error must propagate to this entire
   selection set, either resolving to null if allowed or further
   propagated to a parent field.

   If this occurs, any sibling fields which have not yet executed or have
   not yet yielded a value may be cancelled to avoid unnecessary work.

   [1296]Note See [1297]Handling Field Errors for more about this
   behavior.

  [1298]6.3.1Normal and Serial Execution

   Normally the executor can execute the entries in a grouped field set in
   whatever order it chooses (normally in parallel). Because the
   resolution of fields other than top-level mutation fields must always
   be side effect-free and idempotent, the execution order must not affect
   the result, and hence the service has the freedom to execute the field
   entries in whatever order it deems optimal.

   For example, given the following grouped field set to be executed
   normally:
[1299]Example No. 190{
  birthday {
    month
  }
  address {
    street
  }
}

   A valid GraphQL executor can resolve the four fields in whatever order
   it chose (however of course birthday must be resolved before month, and
   address before street).

   When executing a mutation, the selections in the top most selection set
   will be executed in serial order, starting with the first appearing
   field textually.

   When executing a grouped field set serially, the executor must consider
   each entry from the grouped field set in the order provided in the
   grouped field set. It must determine the corresponding entry in the
   result map for each item to completion before it continues on to the
   next item in the grouped field set:

   For example, given the following selection set to be executed serially:
[1300]Example No. 191{
  changeBirthday(birthday: $newBirthday) {
    month
  }
  changeAddress(address: $newAddress) {
    street
  }
}

   The executor must, in serial:
     * Run [1301]ExecuteField() for changeBirthday, which during
       [1302]CompleteValue() will execute the { month } sub-selection set
       normally.
     * Run [1303]ExecuteField() for changeAddress, which during
       [1304]CompleteValue() will execute the { street } sub-selection set
       normally.

   As an illustrative example, let's assume we have a mutation field
   changeTheNumber that returns an object containing one field, theNumber.
   If we execute the following selection set serially:
[1305]Example No. 192{
  first: changeTheNumber(newNumber: 1) {
    theNumber
  }
  second: changeTheNumber(newNumber: 3) {
    theNumber
  }
  third: changeTheNumber(newNumber: 2) {
    theNumber
  }
}

   The executor will execute the following serially:
     * Resolve the changeTheNumber(newNumber: 1) field
     * Execute the { theNumber } sub-selection set of first normally
     * Resolve the changeTheNumber(newNumber: 3) field
     * Execute the { theNumber } sub-selection set of second normally
     * Resolve the changeTheNumber(newNumber: 2) field
     * Execute the { theNumber } sub-selection set of third normally

   A correct executor must generate the following result for that
   selection set:
[1306]Example No. 193{
  "first": {
    "theNumber": 1
  },
  "second": {
    "theNumber": 3
  },
  "third": {
    "theNumber": 2
  }
}

  [1307]6.3.2Field Collection

   Before execution, the selection set is converted to a grouped field set
   by calling [1308]CollectFields(). Each entry in the grouped field set
   is a list of fields that share a response key (the alias if defined,
   otherwise the field name). This ensures all fields with the same
   response key (including those in referenced fragments) are executed at
   the same time.

   As an example, collecting the fields of this selection set would
   collect two instances of the field a and one of field b:
[1309]Example No. 194{
  a {
    subfield1
  }
  ...ExampleFragment
}

fragment ExampleFragment on Query {
  a {
    subfield2
  }
  b
}

   The depth-first-search order of the field groups produced by
   [1310]CollectFields() is maintained through execution, ensuring that
   fields appear in the executed response in a stable and predictable
   order.

   [1311]CollectFields(objectType, selectionSet, variableValues,
   visitedFragments)
    1. If visitedFragments is not provided, initialize it to the empty
       set.
    2. Initialize groupedFields to an empty ordered map of lists.
    3. For each selection in selectionSet:
         1. If selection provides the directive @skip, let skipDirective
            be that directive.
              1. If skipDirective`s if argument is true or is a variable
                 in variableValues with the value true, continue with the
                 next selection in selectionSet.
         2. If selection provides the directive @include, let
            includeDirective be that directive.
              1. If includeDirective`s if argument is not true and is not
                 a variable in variableValues with the value true,
                 continue with the next selection in selectionSet.
         3. If selection is a [1312]Field:
              1. Let responseKey be the response key of selection (the
                 alias if defined, otherwise the field name).
              2. Let groupForResponseKey be the list in groupedFields for
                 responseKey; if no such list exists, create it as an
                 empty list.
              3. Append selection to the groupForResponseKey.
         4. If selection is a [1313]FragmentSpread:
              1. Let fragmentSpreadName be the name of selection.
              2. If fragmentSpreadName is in visitedFragments, continue
                 with the next selection in selectionSet.
              3. Add fragmentSpreadName to visitedFragments.
              4. Let fragment be the Fragment in the current Document
                 whose name is fragmentSpreadName.
              5. If no such fragment exists, continue with the next
                 selection in selectionSet.
              6. Let fragmentType be the type condition on fragment.
              7. If [1314]DoesFragmentTypeApply(objectType, fragmentType)
                 is false, continue with the next selection in
                 selectionSet.
              8. Let fragmentSelectionSet be the top-level selection set
                 of fragment.
              9. Let fragmentGroupedFieldSet be the result of calling
                 [1315]CollectFields(objectType, fragmentSelectionSet,
                 variableValues, visitedFragments).
             10. For each fragmentGroup in fragmentGroupedFieldSet:
                   1. Let responseKey be the response key shared by all
                      fields in fragmentGroup.
                   2. Let groupForResponseKey be the list in groupedFields
                      for responseKey; if no such list exists, create it
                      as an empty list.
                   3. Append all items in fragmentGroup to
                      groupForResponseKey.
         5. If selection is an [1316]InlineFragment:
              1. Let fragmentType be the type condition on selection.
              2. If fragmentType is not null and
                 [1317]DoesFragmentTypeApply(objectType, fragmentType) is
                 false, continue with the next selection in selectionSet.
              3. Let fragmentSelectionSet be the top-level selection set
                 of selection.
              4. Let fragmentGroupedFieldSet be the result of calling
                 [1318]CollectFields(objectType, fragmentSelectionSet,
                 variableValues, visitedFragments).
              5. For each fragmentGroup in fragmentGroupedFieldSet:
                   1. Let responseKey be the response key shared by all
                      fields in fragmentGroup.
                   2. Let groupForResponseKey be the list in groupedFields
                      for responseKey; if no such list exists, create it
                      as an empty list.
                   3. Append all items in fragmentGroup to
                      groupForResponseKey.
    4. Return groupedFields.

   [1319]DoesFragmentTypeApply(objectType, fragmentType)
    1. If fragmentType is an Object Type:
         1. if objectType and fragmentType are the same type, return true,
            otherwise return false.
    2. If fragmentType is an Interface Type:
         1. if objectType is an implementation of fragmentType, return
            true otherwise return false.
    3. If fragmentType is a Union:
         1. if objectType is a possible type of fragmentType, return true
            otherwise return false.

   [1320]Note The steps in [1321]CollectFields() evaluating the @skip and
   @include directives may be applied in either order since they apply
   commutatively.

[1322]6.4Executing Fields

   Each field requested in the grouped field set that is defined on the
   selected objectType will result in an entry in the response map. Field
   execution first coerces any provided argument values, then resolves a
   value for the field, and finally completes that value either by
   recursively executing another selection set or coercing a scalar value.

   [1323]ExecuteField(objectType, objectValue, fieldType, fields,
   variableValues)
    1. Let field be the first entry in fields.
    2. Let fieldName be the field name of field.
    3. Let argumentValues be the result of
       [1324]CoerceArgumentValues(objectType, field, variableValues)
    4. Let resolvedValue be [1325]ResolveFieldValue(objectType,
       objectValue, fieldName, argumentValues).
    5. Return the result of [1326]CompleteValue(fieldType, fields,
       resolvedValue, variableValues).

  [1327]6.4.1Coercing Field Arguments

   Fields may include arguments which are provided to the underlying
   runtime in order to correctly produce a value. These arguments are
   defined by the field in the type system to have a specific input type.

   At each argument position in an operation may be a literal [1328]Value,
   or a [1329]Variable to be provided at runtime.

   [1330]CoerceArgumentValues(objectType, field, variableValues)
    1. Let coercedValues be an empty unordered Map.
    2. Let argumentValues be the argument values provided in field.
    3. Let fieldName be the name of field.
    4. Let argumentDefinitions be the arguments defined by objectType for
       the field named fieldName.
    5. For each argumentDefinition in argumentDefinitions:
         1. Let argumentName be the name of argumentDefinition.
         2. Let argumentType be the expected type of argumentDefinition.
         3. Let defaultValue be the default value for argumentDefinition.
         4. Let hasValue be true if argumentValues provides a value for
            the name argumentName.
         5. Let argumentValue be the value provided in argumentValues for
            the name argumentName.
         6. If argumentValue is a [1331]Variable:
              1. Let variableName be the name of argumentValue.
              2. Let hasValue be true if variableValues provides a value
                 for the name variableName.
              3. Let value be the value provided in variableValues for the
                 name variableName.
         7. Otherwise, let value be argumentValue.
         8. If hasValue is not true and defaultValue exists (including
            null):
              1. Add an entry to coercedValues named argumentName with the
                 value defaultValue.
         9. Otherwise if argumentType is a Non-Nullable type, and either
            hasValue is not true or value is null, raise a field error.
        10. Otherwise if hasValue is true:
              1. If value is null:
                   1. Add an entry to coercedValues named argumentName
                      with the value null.
              2. Otherwise, if argumentValue is a [1332]Variable:
                   1. Add an entry to coercedValues named argumentName
                      with the value value.
              3. Otherwise:
                   1. If value cannot be coerced according to the input
                      coercion rules of argumentType, raise a field error.
                   2. Let coercedValue be the result of coercing value
                      according to the input coercion rules of
                      argumentType.
                   3. Add an entry to coercedValues named argumentName
                      with the value coercedValue.
    6. Return coercedValues.

   [1333]Note Variable values are not coerced because they are expected to
   be coerced before executing the operation in
   [1334]CoerceVariableValues(), and valid operations must only allow
   usage of variables of appropriate types.

  [1335]6.4.2Value Resolution

   While nearly all of GraphQL execution can be described generically,
   ultimately the internal system exposing the GraphQL interface must
   provide values. This is exposed via ResolveFieldValue, which produces a
   value for a given field on a type for a real value.

   As an example, this might accept the objectType Person, the field
   "soulMate", and the objectValue representing John Lennon. It would be
   expected to yield the value representing Yoko Ono.

   [1336]ResolveFieldValue(objectType, objectValue, fieldName,
   argumentValues)
    1. Let resolver be the internal function provided by objectType for
       determining the resolved value of a field named fieldName.
    2. Return the result of calling resolver, providing objectValue and
       argumentValues.

   [1337]Note It is common for resolver to be asynchronous due to relying
   on reading an underlying database or networked service to produce a
   value. This necessitates the rest of a GraphQL executor to handle an
   asynchronous execution flow.

  [1338]6.4.3Value Completion

   After resolving the value for a field, it is completed by ensuring it
   adheres to the expected return type. If the return type is another
   Object type, then the field execution process continues recursively.

   [1339]CompleteValue(fieldType, fields, result, variableValues)
    1. If the fieldType is a Non-Null type:
         1. Let innerType be the inner type of fieldType.
         2. Let completedResult be the result of calling
            [1340]CompleteValue(innerType, fields, result,
            variableValues).
         3. If completedResult is null, raise a field error.
         4. Return completedResult.
    2. If result is null (or another internal value similar to null such
       as undefined), return null.
    3. If fieldType is a List type:
         1. If result is not a collection of values, raise a field error.
         2. Let innerType be the inner type of fieldType.
         3. Return a list where each list item is the result of calling
            [1341]CompleteValue(innerType, fields, resultItem,
            variableValues), where resultItem is each item in result.
    4. If fieldType is a Scalar or Enum type:
         1. Return the result of [1342]CoerceResult(fieldType, result).
    5. If fieldType is an Object, Interface, or Union type:
         1. If fieldType is an Object type.
              1. Let objectType be fieldType.
         2. Otherwise if fieldType is an Interface or Union type.
              1. Let objectType be [1343]ResolveAbstractType(fieldType,
                 result).
         3. Let subSelectionSet be the result of calling
            [1344]MergeSelectionSets(fields).
         4. Return the result of evaluating
            [1345]ExecuteSelectionSet(subSelectionSet, objectType, result,
            variableValues) normally (allowing for parallelization).

        [1346]Coercing Results

   The primary purpose of value completion is to ensure that the values
   returned by field resolvers are valid according to the GraphQL type
   system and a service's schema. This "dynamic type checking" allows
   GraphQL to provide consistent guarantees about returned types atop any
   service's internal runtime.

   See the Scalars [1347]Result Coercion and Serialization sub-section for
   more detailed information about how GraphQL's built-in scalars coerce
   result values.

   [1348]CoerceResult(leafType, value)
    1. Assert value is not null.
    2. Return the result of calling the internal method provided by the
       type system for determining the "result coercion" of leafType given
       the value value. This internal method must return a valid value for
       the type and not null. Otherwise throw a field error.

   [1349]Note If a field resolver returns null then it is handled within
   [1350]CompleteValue() before [1351]CoerceResult() is called. Therefore
   both the input and output of [1352]CoerceResult() must not be null.

        [1353]Resolving Abstract Types

   When completing a field with an abstract return type, that is an
   Interface or Union return type, first the abstract type must be
   resolved to a relevant Object type. This determination is made by the
   internal system using whatever means appropriate.

   [1354]Note A common method of determining the Object type for an
   objectValue in object-oriented environments, such as Java or C#, is to
   use the class name of the objectValue.

   [1355]ResolveAbstractType(abstractType, objectValue)
    1. Return the result of calling the internal method provided by the
       type system for determining the Object type of abstractType given
       the value objectValue.

        [1356]Merging Selection Sets

   When more than one field of the same name is executed in parallel,
   their selection sets are merged together when completing the value in
   order to continue execution of the sub-selection sets.

   An example operation illustrating parallel fields with the same name
   with sub-selections.
[1357]Example No. 195{
  me {
    firstName
  }
  me {
    lastName
  }
}

   After resolving the value for me, the selection sets are merged
   together so firstName and lastName can be resolved for one value.

   [1358]MergeSelectionSets(fields)
    1. Let selectionSet be an empty list.
    2. For each field in fields:
         1. Let fieldSelectionSet be the selection set of field.
         2. If fieldSelectionSet is null or empty, continue to the next
            field.
         3. Append all selections in fieldSelectionSet to selectionSet.
    3. Return selectionSet.

  [1359]6.4.4Handling Field Errors

   [1360]"Field errors" are raised from a particular field during value
   resolution or coercion. While these errors should be reported in the
   response, they are "handled" by producing a partial response.

   [1361]Note This is distinct from [1362]"request errors" which are
   raised before execution begins. If a request error is encountered,
   execution does not begin and no data is returned in the response.

   If a field error is raised while resolving a field, it is handled as
   though the field returned null, and the error must be added to the
   "errors" list in the response.

   If the result of resolving a field is null (either because the function
   to resolve the field returned null or because a field error was
   raised), and that field is of a Non-Null type, then a field error is
   raised. The error must be added to the "errors" list in the response.

   If the field returns null because of a field error which has already
   been added to the "errors" list in the response, the "errors" list must
   not be further affected. That is, only one error should be added to the
   errors list per field.

   Since Non-Null type fields cannot be null, field errors are propagated
   to be handled by the parent field. If the parent field may be null then
   it resolves to null, otherwise if it is a Non-Null type, the field
   error is further propagated to its parent field.

   If a List type wraps a Non-Null type, and one of the elements of that
   list resolves to null, then the entire list must resolve to null. If
   the List type is also wrapped in a Non-Null, the field error continues
   to propagate upwards.

   If all fields from the root of the request to the source of the field
   error return Non-Null types, then the "data" entry in the response
   should be null.

                                [1363]7Response

   When a GraphQL service receives a request, it must return a well-formed
   response. The service's response describes the result of executing the
   requested operation if successful, and describes any errors raised
   during the request.

   A response may contain both a partial response as well as any field
   errors in the case that a field error was raised on a field and was
   replaced with null.

[1364]7.1Response Format

   A response to a GraphQL request must be a map.

   If the request raised any errors, the response map must contain an
   entry with key errors. The value of this entry is described in the
   "Errors" section. If the request completed without raising any errors,
   this entry must not be present.

   If the request included execution, the response map must contain an
   entry with key data. The value of this entry is described in the "Data"
   section. If the request failed before execution, due to a syntax error,
   missing information, or validation error, this entry must not be
   present.

   The response map may also contain an entry with key extensions. This
   entry, if set, must have a map as its value. This entry is reserved for
   implementors to extend the protocol however they see fit, and hence
   there are no additional restrictions on its contents.

   To ensure future changes to the protocol do not break existing services
   and clients, the top level response map must not contain any entries
   other than the three described above.

   [1365]Note When errors is present in the response, it may be helpful
   for it to appear first when serialized to make it more clear when
   errors are present in a response during debugging.

  [1366]7.1.1Data

   The data entry in the response will be the result of the execution of
   the requested operation. If the operation was a query, this output will
   be an object of the query root operation type; if the operation was a
   mutation, this output will be an object of the mutation root operation
   type.

   If an error was raised before execution begins, the data entry should
   not be present in the result.

   If an error was raised during the execution that prevented a valid
   response, the data entry in the response should be null.

  [1367]7.1.2Errors

   The errors entry in the response is a non-empty list of errors, where
   each error is a map.

   If no errors were raised during the request, the errors entry should
   not be present in the result.

   If the data entry in the response is not present, the errors entry in
   the response must not be empty. It must contain at least one error. The
   errors it contains should indicate why no data was able to be returned.

   If the data entry in the response is present (including if it is the
   value null), the errors entry in the response may contain any field
   errors that were raised during execution. If field errors were raised
   during execution, it should contain those errors.

        [1368]Request errors

   Request errors are raised before execution begins. This may occur due
   to a parse grammar or validation error in the requested document, an
   inability to determine which operation to execute, or invalid input
   values for variables.

   Request errors are typically the fault of the requesting client.

   If a request error is raised, execution does not begin and the data
   entry in the response must not be present. The errors entry must
   include the error.

        [1369]Field errors

   Field errors are raised during execution from a particular field. This
   may occur due to an internal error during value resolution or failure
   to coerce the resulting value.

   Field errors are typically the fault of GraphQL service.

   If a field error is raised, execution attempts to continue and a
   partial result is produced (see [1370]Handling Field Errors). The data
   entry in the response must be present. The errors entry should include
   all raised field errors.

        [1371]Error result format

   Every error must contain an entry with the key message with a string
   description of the error intended for the developer as a guide to
   understand and correct the error.

   If an error can be associated to a particular point in the requested
   GraphQL document, it should contain an entry with the key locations
   with a list of locations, where each location is a map with the keys
   line and column, both positive numbers starting from 1 which describe
   the beginning of an associated syntax element.

   If an error can be associated to a particular field in the GraphQL
   result, it must contain an entry with the key path that details the
   path of the response field which experienced the error. This allows
   clients to identify whether a null result is intentional or caused by a
   runtime error.

   This field should be a list of path segments starting at the root of
   the response and ending with the field associated with the error. Path
   segments that represent fields should be strings, and path segments
   that represent list indices should be 0-indexed integers. If the error
   happens in an aliased field, the path to the error should use the
   aliased name, since it represents a path in the response, not in the
   request.

   For example, if fetching one of the friends' names fails in the
   following operation:
[1372]Example No. 196{
  hero(episode: $episode) {
    name
    heroFriends: friends {
      id
      name
    }
  }
}

   The response might look like:
[1373]Example No. 197{
  "errors": [
    {
      "message": "Name for character with ID 1002 could not be fetched.",
      "locations": [{ "line": 6, "column": 7 }],
      "path": ["hero", "heroFriends", 1, "name"]
    }
  ],
  "data": {
    "hero": {
      "name": "R2-D2",
      "heroFriends": [
        {
          "id": "1000",
          "name": "Luke Skywalker"
        },
        {
          "id": "1002",
          "name": null
        },
        {
          "id": "1003",
          "name": "Leia Organa"
        }
      ]
    }
  }
}

   If the field which experienced an error was declared as Non-Null, the
   null result will bubble up to the next nullable field. In that case,
   the path for the error should include the full path to the result field
   where the error was raised, even if that field is not present in the
   response.

   For example, if the name field from above had declared a Non-Null
   return type in the schema, the result would look different but the
   error reported would be the same:
[1374]Example No. 198{
  "errors": [
    {
      "message": "Name for character with ID 1002 could not be fetched.",
      "locations": [{ "line": 6, "column": 7 }],
      "path": ["hero", "heroFriends", 1, "name"]
    }
  ],
  "data": {
    "hero": {
      "name": "R2-D2",
      "heroFriends": [
        {
          "id": "1000",
          "name": "Luke Skywalker"
        },
        null,
        {
          "id": "1003",
          "name": "Leia Organa"
        }
      ]
    }
  }
}

   GraphQL services may provide an additional entry to errors with key
   extensions. This entry, if set, must have a map as its value. This
   entry is reserved for implementors to add additional information to
   errors however they see fit, and there are no additional restrictions
   on its contents.
[1375]Example No. 199{
  "errors": [
    {
      "message": "Name for character with ID 1002 could not be fetched.",
      "locations": [{ "line": 6, "column": 7 }],
      "path": ["hero", "heroFriends", 1, "name"],
      "extensions": {
        "code": "CAN_NOT_FETCH_BY_ID",
        "timestamp": "Fri Feb 9 14:33:09 UTC 2018"
      }
    }
  ]
}

   GraphQL services should not provide any additional entries to the error
   format since they could conflict with additional entries that may be
   added in future versions of this specification.

   [1376]Note Previous versions of this spec did not describe the
   extensions entry for error formatting. While non-specified entries are
   not violations, they are still discouraged.

[1377]Counter Example No. 200{
  "errors": [
    {
      "message": "Name for character with ID 1002 could not be fetched.",
      "locations": [{ "line": 6, "column": 7 }],
      "path": ["hero", "heroFriends", 1, "name"],
      "code": "CAN_NOT_FETCH_BY_ID",
      "timestamp": "Fri Feb 9 14:33:09 UTC 2018"
    }
  ]
}

[1378]7.2Serialization Format

   GraphQL does not require a specific serialization format. However,
   clients should use a serialization format that supports the major
   primitives in the GraphQL response. In particular, the serialization
   format must at least support representations of the following four
   primitives:
     * Map
     * List
     * String
     * Null

   A serialization format should also support the following primitives,
   each representing one of the common GraphQL scalar types, however a
   string or simpler primitive may be used as a substitute if any are not
   directly supported:
     * Boolean
     * Int
     * Float
     * Enum Value

   This is not meant to be an exhaustive list of what a serialization
   format may encode. For example custom scalars representing a Date,
   Time, URI, or number with a different precision may be represented in
   whichever relevant format a given serialization format may support.

  [1379]7.2.1JSON Serialization

   JSON is the most common serialization format for GraphQL. Though as
   mentioned above, GraphQL does not require a specific serialization
   format.

   When using JSON as a serialization of GraphQL responses, the following
   JSON values should be used to encode the related GraphQL values:

   GraphQL Value  JSON Value
   Map           Object
   List          Array
   Null          null
   String        String
   Boolean       true or false
   Int           Number
   Float         Number
   Enum Value    String

   [1380]Note For consistency and ease of notation, examples of responses
   are given in JSON format throughout this document.

  [1381]7.2.2Serialized Map Ordering

   Since the result of evaluating a selection set is ordered, the
   serialized Map of results should preserve this order by writing the map
   entries in the same order as those fields were requested as defined by
   selection set execution. Producing a serialized response where fields
   are represented in the same order in which they appear in the request
   improves human readability during debugging and enables more efficient
   parsing of responses if the order of properties can be anticipated.

   Serialization formats which represent an ordered map should preserve
   the order of requested fields as defined by [1382]CollectFields() in
   the Execution section. Serialization formats which only represent
   unordered maps but where order is still implicit in the serialization's
   textual order (such as JSON) should preserve the order of requested
   fields textually.

   For example, if the request was { name, age }, a GraphQL service
   responding in JSON should respond with { "name": "Mark", "age": 30 }
   and should not respond with { "age": 30, "name": "Mark" }.

   While JSON Objects are specified as an [1383]unordered collection of
   key-value pairs the pairs are represented in an ordered manner. In
   other words, while the JSON strings { "name": "Mark", "age": 30 } and {
   "age": 30, "name": "Mark" } encode the same value, they also have
   observably different property orderings.

   [1384]Note This does not violate the JSON spec, as clients may still
   interpret objects in the response as unordered Maps and arrive at a
   valid value.

                     [1385]AAppendix: Notation Conventions

   This specification document contains a number of notation conventions
   used to describe technical concepts such as language grammar and
   semantics as well as runtime algorithms.

   This appendix seeks to explain these notations in greater detail to
   avoid ambiguity.

[1386]A.1Context-Free Grammar

   A context-free grammar consists of a number of productions. Each
   production has an abstract symbol called a "non-terminal" as its
   left-hand side, and zero or more possible sequences of non-terminal
   symbols and or terminal characters as its right-hand side.

   Starting from a single goal non-terminal symbol, a context-free grammar
   describes a language: the set of possible sequences of characters that
   can be described by repeatedly replacing any non-terminal in the goal
   sequence with one of the sequences it is defined by, until all
   non-terminal symbols have been replaced by terminal characters.

   Terminals are represented in this document in a monospace font in two
   forms: a specific Unicode character or sequence of Unicode characters
   (ie. = or terminal), and prose typically describing a specific Unicode
   code-point "Space (U+0020)". Sequences of Unicode characters only
   appear in syntactic grammars and represent a [1387]Name token of that
   specific sequence.

   Non-terminal production rules are represented in this document using
   the following notation for a non-terminal with a single definition:

   [1388]NonTerminalWithSingleDefinition
   NonTerminalterminal

   While using the following notation for a production with a list of
   definitions:

   [1389]NonTerminalWithManyDefinitions
   OtherNonTerminalterminal
   terminal

   A definition may refer to itself, which describes repetitive sequences,
   for example:

   [1390]ListOfLetterA
   [1391]ListOfLetterAa
   a

[1392]A.2Lexical and Syntactical Grammar

   The GraphQL language is defined in a syntactic grammar where terminal
   symbols are tokens. Tokens are defined in a lexical grammar which
   matches patterns of source characters. The result of parsing a source
   text sequence of Unicode characters first produces a sequence of
   lexical tokens according to the lexical grammar which then produces
   abstract syntax tree (AST) according to the syntactical grammar.

   A lexical grammar production describes non-terminal "tokens" by
   patterns of terminal Unicode characters. No "whitespace" or other
   ignored characters may appear between any terminal Unicode characters
   in the lexical grammar production. A lexical grammar production is
   distinguished by a two colon :: definition.

   [1393]Word
   [1394]Letterlist

   A Syntactical grammar production describes non-terminal "rules" by
   patterns of terminal Tokens. [1395]WhiteSpace and other [1396]Ignored
   sequences may appear before or after any terminal [1397]Token. A
   syntactical grammar production is distinguished by a one colon :
   definition.

   [1398]Sentence
   [1399]Wordlist.

[1400]A.3Grammar Notation

   This specification uses some additional notation to describe common
   patterns, such as optional or repeated patterns, or parameterized
   alterations of the definition of a non-terminal. This section explains
   these short-hand notations and their expanded definitions in the
   context-free grammar.

        [1401]Constraints

   A grammar production may specify that certain expansions are not
   permitted by using the phrase "but not" and then indicating the
   expansions to be excluded.

   For example, the following production means that the non-terminal
   [1402]SafeWord may be replaced by any sequence of characters that could
   replace [1403]Word provided that the same sequence of characters could
   not replace SevenCarlinWords.

   [1404]SafeWord
   [1405]WordSevenCarlinWords

   A grammar may also list a number of restrictions after "but not"
   separated by "or".

   For example:

   [1406]NonBooleanName
   [1407]Nametruefalse

        [1408]Lookahead Restrictions

   A grammar production may specify that certain characters or tokens are
   not permitted to follow it by using the pattern NotAllowed. Lookahead
   restrictions are often used to remove ambiguity from the grammar.

   The following example makes it clear that [1409]Letterlist must be
   greedy, since [1410]Word cannot be followed by yet another
   [1411]Letter.

   [1412]Word
   [1413]Letterlist[1414]Letter

        [1415]Optionality and Lists

   A subscript suffix "Symbolopt" is shorthand for two possible sequences,
   one including that symbol and one excluding it.

   As an example:

   [1416]Sentence
   NounVerbAdverbopt

   is shorthand for

   [1417]Sentence
   NounVerbAdverb
   NounVerb

   A subscript suffix "Symbollist" is shorthand for a list of one or more
   of that symbol, represented as an additional recursive production.

   As an example:

   [1418]Book
   CoverPagelistCover

   is shorthand for

   [1419]Book
   Cover[1420]Page_listCover

   [1421]Page_list
   [1422]Page_listPage
   Page

        [1423]Parameterized Grammar Productions

   A symbol definition subscript suffix parameter in braces "SymbolParam"
   is shorthand for two symbol definitions, one appended with that
   parameter name, the other without. The same subscript suffix on a
   symbol is shorthand for that variant of the definition. If the
   parameter starts with "?", that form of the symbol is used if in a
   symbol definition with the same parameter. Some possible sequences can
   be included or excluded conditionally when respectively prefixed with
   "[+Param]" and "[~Param]".

   As an example:

   [1424]ExampleParam
   A
   BParam
   CParam
   ParamD
   ParamE

   is shorthand for

   [1425]Example
   A
   B_param
   C
   E

   [1426]Example_param
   A
   B_param
   C_param
   D

[1427]A.4Grammar Semantics

   This specification describes the semantic value of many grammar
   productions in the form of a list of algorithmic steps.

   For example, this describes how a parser should interpret a string
   literal:

   [1428]StringValue
   ""
    1. Return an empty Unicode character sequence.

   [1429]StringValue
   "[1430]StringCharacterlist"
    1. Return the Unicode character sequence of all [1431]StringCharacter
       Unicode character values.

[1432]A.5Algorithms

   This specification describes some algorithms used by the static and
   runtime semantics, they're defined in the form of a function-like
   syntax with the algorithm's name and the arguments it accepts along
   with a list of algorithmic steps to take in the order listed. Each step
   may establish references to other values, check various conditions,
   call other algorithms, and eventually return a value representing the
   outcome of the algorithm for the provided arguments.

   For example, the following example describes an algorithm named
   Fibonacci which accepts a single argument number. The algorithm's steps
   produce the next number in the Fibonacci sequence:

   [1433]Fibonacci(number)
    1. If number is 0:
         1. Return 1.
    2. If number is 1:
         1. Return 2.
    3. Let previousNumber be number - 1.
    4. Let previousPreviousNumber be number - 2.
    5. Return [1434]Fibonacci(previousNumber) +
       [1435]Fibonacci(previousPreviousNumber).

   [1436]Note Algorithms described in this document are written to be easy
   to understand. Implementers are encouraged to include equivalent but
   optimized implementations.

                        [1437]BAppendix: Grammar Summary

[1438]B.1Source Text

   [1439]SourceCharacter
   U+0009
   U+000A
   U+000D
   U+0020-U+FFFF

[1440]B.2Ignored Tokens

   [1441]Ignored
   [1442]UnicodeBOM
   [1443]WhiteSpace
   [1444]LineTerminator
   [1445]Comment
   [1446]Comma

   [1447]UnicodeBOM
   Byte Order Mark (U+FEFF)

   [1448]WhiteSpace
   Horizontal Tab (U+0009)
   Space (U+0020)

   [1449]LineTerminator
   New Line (U+000A)
   Carriage Return (U+000D)New Line (U+000A)
   Carriage Return (U+000D)New Line (U+000A)

   [1450]Comment
   #[1451]CommentCharlistopt[1452]CommentChar

   [1453]CommentChar
   [1454]SourceCharacter[1455]LineTerminator

   [1456]Comma
   ,

[1457]B.3Lexical Tokens

   [1458]Token
   [1459]Punctuator
   [1460]Name
   [1461]IntValue
   [1462]FloatValue
   [1463]StringValue

   [1464]Punctuator
   ! $ & ( ) ... : = @ [ ] { | }

   [1465]Name
   [1466]NameStart[1467]NameContinuelistopt[1468]NameContinue

   [1469]NameStart
   [1470]Letter
   _

   [1471]NameContinue
   [1472]Letter
   [1473]Digit
   _

   [1474]Letter
   A B C D E F G H I J K L M
   N O P Q R S T U V W X Y Z
   a b c d e f g h i j k l m
   n o p q r s t u v w x y z

   [1475]Digit
   0 1 2 3 4 5 6 7 8 9

   [1476]IntValue
   [1477]IntegerPart[1478]Digit.[1479]NameStart

   [1480]IntegerPart
   [1481]NegativeSignopt0
   [1482]NegativeSignopt[1483]NonZeroDigit[1484]Digitlistopt

   [1485]NegativeSign
   -

   [1486]NonZeroDigit
   [1487]Digit0

   [1488]FloatValue
   [1489]IntegerPart[1490]FractionalPart[1491]ExponentPart[1492]Digit.[149
   3]NameStart
   [1494]IntegerPart[1495]FractionalPart[1496]Digit.[1497]NameStart
   [1498]IntegerPart[1499]ExponentPart[1500]Digit.[1501]NameStart

   [1502]FractionalPart
   .[1503]Digitlist

   [1504]ExponentPart
   [1505]ExponentIndicator[1506]Signopt[1507]Digitlist

   [1508]ExponentIndicator
   e E

   [1509]Sign
   + -

   [1510]StringValue
   """
   "[1511]StringCharacterlist"
   """[1512]BlockStringCharacterlistopt"""

   [1513]StringCharacter
   [1514]SourceCharacter"\[1515]LineTerminator
   \u[1516]EscapedUnicode
   \[1517]EscapedCharacter

   [1518]EscapedUnicode
   /[0-9A-Fa-f]{4}/

   [1519]EscapedCharacter
   " \ / b f n r t

   [1520]BlockStringCharacter
   [1521]SourceCharacter"""\"""
   \"""

   [1522]Note Block string values are interpreted to exclude blank initial
   and trailing lines and uniform indentation with
   [1523]BlockStringValue().

[1524]B.4Document Syntax

   [1525]Document
   [1526]Definitionlist

   [1527]Definition
   [1528]ExecutableDefinition
   [1529]TypeSystemDefinitionOrExtension

   [1530]ExecutableDocument
   [1531]ExecutableDefinitionlist

   [1532]ExecutableDefinition
   [1533]OperationDefinition
   [1534]FragmentDefinition

   [1535]OperationDefinition
   [1536]OperationType[1537]Nameopt[1538]VariableDefinitionsopt[1539]Direc
   tivesopt[1540]SelectionSet
   [1541]SelectionSet

   [1542]OperationType
   query mutation subscription

   [1543]SelectionSet
   {[1544]Selectionlist}

   [1545]Selection
   [1546]Field
   [1547]FragmentSpread
   [1548]InlineFragment

   [1549]Field
   [1550]Aliasopt[1551]Name[1552]Argumentsopt[1553]Directivesopt[1554]Sele
   ctionSetopt

   [1555]Alias
   [1556]Name:

   [1557]ArgumentsConst
   ([1558]ArgumentConstlist)

   [1559]ArgumentConst
   [1560]Name:[1561]ValueConst

   [1562]FragmentSpread
   ...[1563]FragmentName[1564]Directivesopt

   [1565]InlineFragment
   ...[1566]TypeConditionopt[1567]Directivesopt[1568]SelectionSet

   [1569]FragmentDefinition
   fragment[1570]FragmentName[1571]TypeCondition[1572]Directivesopt[1573]S
   electionSet

   [1574]FragmentName
   [1575]Nameon

   [1576]TypeCondition
   on[1577]NamedType

   [1578]ValueConst
   Const[1579]Variable
   [1580]IntValue
   [1581]FloatValue
   [1582]StringValue
   [1583]BooleanValue
   [1584]NullValue
   [1585]EnumValue
   [1586]ListValueConst
   [1587]ObjectValueConst

   [1588]BooleanValue
   true false

   [1589]NullValue
   null

   [1590]EnumValue
   [1591]Nametruefalsenull

   [1592]ListValueConst
   []
   [[1593]ValueConstlist]

   [1594]ObjectValueConst
   {}
   {[1595]ObjectFieldConstlist}

   [1596]ObjectFieldConst
   [1597]Name:[1598]ValueConst

   [1599]VariableDefinitions
   ([1600]VariableDefinitionlist)

   [1601]VariableDefinition
   [1602]Variable:[1603]Type[1604]DefaultValueopt[1605]DirectivesConstopt

   [1606]Variable
   $[1607]Name

   [1608]DefaultValue
   =[1609]ValueConst

   [1610]Type
   [1611]NamedType
   [1612]ListType
   [1613]NonNullType

   [1614]NamedType
   [1615]Name

   [1616]ListType
   [[1617]Type]

   [1618]NonNullType
   [1619]NamedType!
   [1620]ListType!

   [1621]DirectivesConst
   [1622]DirectiveConstlist

   [1623]DirectiveConst
   @[1624]Name[1625]ArgumentsConstopt

   [1626]TypeSystemDocument
   [1627]TypeSystemDefinitionlist

   [1628]TypeSystemDefinition
   [1629]SchemaDefinition
   [1630]TypeDefinition
   [1631]DirectiveDefinition

   [1632]TypeSystemExtensionDocument
   [1633]TypeSystemDefinitionOrExtensionlist

   [1634]TypeSystemDefinitionOrExtension
   [1635]TypeSystemDefinition
   [1636]TypeSystemExtension

   [1637]TypeSystemExtension
   [1638]SchemaExtension
   [1639]TypeExtension

   [1640]SchemaDefinition
   [1641]Descriptionoptschema[1642]DirectivesConstopt{[1643]RootOperationT
   ypeDefinitionlist}

   [1644]SchemaExtension
   extendschema[1645]DirectivesConstopt{[1646]RootOperationTypeDefinitionl
   ist}
   extendschema[1647]DirectivesConst{

   [1648]RootOperationTypeDefinition
   [1649]OperationType:[1650]NamedType

   [1651]Description
   [1652]StringValue

   [1653]TypeDefinition
   [1654]ScalarTypeDefinition
   [1655]ObjectTypeDefinition
   [1656]InterfaceTypeDefinition
   [1657]UnionTypeDefinition
   [1658]EnumTypeDefinition
   [1659]InputObjectTypeDefinition

   [1660]TypeExtension
   [1661]ScalarTypeExtension
   [1662]ObjectTypeExtension
   [1663]InterfaceTypeExtension
   [1664]UnionTypeExtension
   [1665]EnumTypeExtension
   [1666]InputObjectTypeExtension

   [1667]ScalarTypeDefinition
   [1668]Descriptionoptscalar[1669]Name[1670]DirectivesConstopt

   [1671]ScalarTypeExtension
   extendscalar[1672]Name[1673]DirectivesConst

   [1674]ObjectTypeDefinition
   [1675]Descriptionopttype[1676]Name[1677]ImplementsInterfacesopt[1678]Di
   rectivesConstopt[1679]FieldsDefinition
   [1680]Descriptionopttype[1681]Name[1682]ImplementsInterfacesopt[1683]Di
   rectivesConstopt{

   [1684]ObjectTypeExtension
   extendtype[1685]Name[1686]ImplementsInterfacesopt[1687]DirectivesConsto
   pt[1688]FieldsDefinition
   extendtype[1689]Name[1690]ImplementsInterfacesopt[1691]DirectivesConst{
   extendtype[1692]Name[1693]ImplementsInterfaces{

   [1694]ImplementsInterfaces
   [1695]ImplementsInterfaces&[1696]NamedType
   implements&opt[1697]NamedType

   [1698]FieldsDefinition
   {[1699]FieldDefinitionlist}

   [1700]FieldDefinition
   [1701]Descriptionopt[1702]Name[1703]ArgumentsDefinitionopt:[1704]Type[1
   705]DirectivesConstopt

   [1706]ArgumentsDefinition
   ([1707]InputValueDefinitionlist)

   [1708]InputValueDefinition
   [1709]Descriptionopt[1710]Name:[1711]Type[1712]DefaultValueopt[1713]Dir
   ectivesConstopt

   [1714]InterfaceTypeDefinition
   [1715]Descriptionoptinterface[1716]Name[1717]ImplementsInterfacesopt[17
   18]DirectivesConstopt[1719]FieldsDefinition
   [1720]Descriptionoptinterface[1721]Name[1722]ImplementsInterfacesopt[17
   23]DirectivesConstopt{

   [1724]InterfaceTypeExtension
   extendinterface[1725]Name[1726]ImplementsInterfacesopt[1727]DirectivesC
   onstopt[1728]FieldsDefinition
   extendinterface[1729]Name[1730]ImplementsInterfacesopt[1731]DirectivesC
   onst{
   extendinterface[1732]Name[1733]ImplementsInterfaces{

   [1734]UnionTypeDefinition
   [1735]Descriptionoptunion[1736]Name[1737]DirectivesConstopt[1738]UnionM
   emberTypesopt

   [1739]UnionMemberTypes
   [1740]UnionMemberTypes|[1741]NamedType
   =|opt[1742]NamedType

   [1743]UnionTypeExtension
   extendunion[1744]Name[1745]DirectivesConstopt[1746]UnionMemberTypes
   extendunion[1747]Name[1748]DirectivesConst

   [1749]EnumTypeDefinition
   [1750]Descriptionoptenum[1751]Name[1752]DirectivesConstopt[1753]EnumVal
   uesDefinition
   [1754]Descriptionoptenum[1755]Name[1756]DirectivesConstopt{

   [1757]EnumValuesDefinition
   {[1758]EnumValueDefinitionlist}

   [1759]EnumValueDefinition
   [1760]Descriptionopt[1761]EnumValue[1762]DirectivesConstopt

   [1763]EnumTypeExtension
   extendenum[1764]Name[1765]DirectivesConstopt[1766]EnumValuesDefinition
   extendenum[1767]Name[1768]DirectivesConst{

   [1769]InputObjectTypeDefinition
   [1770]Descriptionoptinput[1771]Name[1772]DirectivesConstopt[1773]InputF
   ieldsDefinition
   [1774]Descriptionoptinput[1775]Name[1776]DirectivesConstopt{

   [1777]InputFieldsDefinition
   {[1778]InputValueDefinitionlist}

   [1779]InputObjectTypeExtension
   extendinput[1780]Name[1781]DirectivesConstopt[1782]InputFieldsDefinitio
   n
   extendinput[1783]Name[1784]DirectivesConst{

   [1785]DirectiveDefinition
   [1786]Descriptionoptdirective@[1787]Name[1788]ArgumentsDefinitionoptrep
   eatableopton[1789]DirectiveLocations

   [1790]DirectiveLocations
   [1791]DirectiveLocations|[1792]DirectiveLocation
   |opt[1793]DirectiveLocation

   [1794]DirectiveLocation
   [1795]ExecutableDirectiveLocation
   [1796]TypeSystemDirectiveLocation

   [1797]ExecutableDirectiveLocation
   QUERY
   MUTATION
   SUBSCRIPTION
   FIELD
   FRAGMENT_DEFINITION
   FRAGMENT_SPREAD
   INLINE_FRAGMENT
   VARIABLE_DEFINITION

   [1798]TypeSystemDirectiveLocation
   SCHEMA
   SCALAR
   OBJECT
   FIELD_DEFINITION
   ARGUMENT_DEFINITION
   INTERFACE
   UNION
   ENUM
   ENUM_VALUE
   INPUT_OBJECT
   INPUT_FIELD_DEFINITION

                                  [1799]§Index

    1. [1800]Alias
    2. [1801]AreTypesCompatible
    3. [1802]Argument
    4. [1803]Arguments
    5. [1804]ArgumentsDefinition
    6. [1805]BlockStringCharacter
    7. [1806]BlockStringValue
    8. [1807]BooleanValue
    9. [1808]built-in directive
   10. [1809]CoerceArgumentValues
   11. [1810]CoerceResult
   12. [1811]CoerceVariableValues
   13. [1812]CollectFields
   14. [1813]Comma
   15. [1814]Comment
   16. [1815]CommentChar
   17. [1816]CompleteValue
   18. [1817]CreateSourceEventStream
   19. [1818]custom directive
   20. [1819]DefaultValue
   21. [1820]Definition
   22. [1821]Description
   23. [1822]DetectFragmentCycles
   24. [1823]Digit
   25. [1824]Directive
   26. [1825]DirectiveDefinition
   27. [1826]DirectiveLocation
   28. [1827]DirectiveLocations
   29. [1828]Directives
   30. [1829]Document
   31. [1830]DoesFragmentTypeApply
   32. [1831]EnumTypeDefinition
   33. [1832]EnumTypeExtension
   34. [1833]EnumValue
   35. [1834]EnumValueDefinition
   36. [1835]EnumValuesDefinition
   37. [1836]EscapedCharacter
   38. [1837]EscapedUnicode
   39. [1838]ExecutableDefinition
   40. [1839]ExecutableDirectiveLocation
   41. [1840]ExecutableDocument
   42. [1841]ExecuteField
   43. [1842]ExecuteMutation
   44. [1843]ExecuteQuery
   45. [1844]ExecuteRequest
   46. [1845]ExecuteSelectionSet
   47. [1846]ExecuteSubscriptionEvent
   48. [1847]ExponentIndicator
   49. [1848]ExponentPart
   50. [1849]Field
   51. [1850]FieldDefinition
   52. [1851]FieldsDefinition
   53. [1852]FieldsInSetCanMerge
   54. [1853]FloatValue
   55. [1854]FractionalPart
   56. [1855]FragmentDefinition
   57. [1856]FragmentName
   58. [1857]FragmentSpread
   59. [1858]GetOperation
   60. [1859]GetPossibleTypes
   61. [1860]Ignored
   62. [1861]ImplementsInterfaces
   63. [1862]InlineFragment
   64. [1863]InputFieldsDefinition
   65. [1864]InputObjectTypeDefinition
   66. [1865]InputObjectTypeExtension
   67. [1866]InputValueDefinition
   68. [1867]IntegerPart
   69. [1868]InterfaceTypeDefinition
   70. [1869]InterfaceTypeExtension
   71. [1870]IntValue
   72. [1871]IsInputType
   73. [1872]IsOutputType
   74. [1873]IsValidImplementation
   75. [1874]IsValidImplementationFieldType
   76. [1875]IsVariableUsageAllowed
   77. [1876]Letter
   78. [1877]LineTerminator
   79. [1878]ListType
   80. [1879]ListValue
   81. [1880]MapSourceToResponseEvent
   82. [1881]MergeSelectionSets
   83. [1882]Name
   84. [1883]NameContinue
   85. [1884]NamedType
   86. [1885]NameStart
   87. [1886]NegativeSign
   88. [1887]NonNullType
   89. [1888]NonZeroDigit
   90. [1889]NullValue
   91. [1890]ObjectField
   92. [1891]ObjectTypeDefinition
   93. [1892]ObjectTypeExtension
   94. [1893]ObjectValue
   95. [1894]OperationDefinition
   96. [1895]OperationType
   97. [1896]Punctuator
   98. [1897]ResolveAbstractType
   99. [1898]ResolveFieldEventStream
   100. [1899]ResolveFieldValue
   101. [1900]RootOperationTypeDefinition
   102. [1901]SameResponseShape
   103. [1902]scalar specification URL
   104. [1903]ScalarTypeDefinition
   105. [1904]ScalarTypeExtension
   106. [1905]SchemaDefinition
   107. [1906]SchemaExtension
   108. [1907]Selection
   109. [1908]SelectionSet
   110. [1909]Sign
   111. [1910]SourceCharacter
   112. [1911]StringCharacter
   113. [1912]StringValue
   114. [1913]Subscribe
   115. [1914]Token
   116. [1915]Type
   117. [1916]TypeCondition
   118. [1917]TypeDefinition
   119. [1918]TypeExtension
   120. [1919]TypeSystemDefinition
   121. [1920]TypeSystemDefinitionOrExtension
   122. [1921]TypeSystemDirectiveLocation
   123. [1922]TypeSystemDocument
   124. [1923]TypeSystemExtension
   125. [1924]TypeSystemExtensionDocument
   126. [1925]UnicodeBOM
   127. [1926]UnionMemberTypes
   128. [1927]UnionTypeDefinition
   129. [1928]UnionTypeExtension
   130. [1929]Unsubscribe
   131. [1930]Value
   132. [1931]Variable
   133. [1932]VariableDefinition
   134. [1933]VariableDefinitions
   135. [1934]WhiteSpace

   Written in [1935]Spec Markdown.[ ]

   -HVN-

   [1936]GraphQL
    1. [1937]1Overview
    2. [1938]2Language [ ]
         1. [1939]2.1Source Text [ ]
              1. [1940]2.1.1Unicode
              2. [1941]2.1.2White Space
              3. [1942]2.1.3Line Terminators
              4. [1943]2.1.4Comments
              5. [1944]2.1.5Insignificant Commas
              6. [1945]2.1.6Lexical Tokens
              7. [1946]2.1.7Ignored Tokens
              8. [1947]2.1.8Punctuators
              9. [1948]2.1.9Names
         2. [1949]2.2Document
         3. [1950]2.3Operations
         4. [1951]2.4Selection Sets
         5. [1952]2.5Fields
         6. [1953]2.6Arguments
         7. [1954]2.7Field Alias
         8. [1955]2.8Fragments [ ]
              1. [1956]2.8.1Type Conditions
              2. [1957]2.8.2Inline Fragments
         9. [1958]2.9Input Values [ ]
              1. [1959]2.9.1Int Value
              2. [1960]2.9.2Float Value
              3. [1961]2.9.3Boolean Value
              4. [1962]2.9.4String Value
              5. [1963]2.9.5Null Value
              6. [1964]2.9.6Enum Value
              7. [1965]2.9.7List Value
              8. [1966]2.9.8Input Object Values
        10. [1967]2.10Variables
        11. [1968]2.11Type References
        12. [1969]2.12Directives
    3. [1970]3Type System [ ]
         1. [1971]3.1Type System Extensions
         2. [1972]3.2Descriptions
         3. [1973]3.3Schema [ ]
              1. [1974]3.3.1Root Operation Types
              2. [1975]3.3.2Schema Extension
         4. [1976]3.4Types [ ]
              1. [1977]3.4.1Wrapping Types
              2. [1978]3.4.2Input and Output Types
              3. [1979]3.4.3Type Extensions
         5. [1980]3.5Scalars [ ]
              1. [1981]3.5.1Int
              2. [1982]3.5.2Float
              3. [1983]3.5.3String
              4. [1984]3.5.4Boolean
              5. [1985]3.5.5ID
              6. [1986]3.5.6Scalar Extensions
         6. [1987]3.6Objects [ ]
              1. [1988]3.6.1Field Arguments
              2. [1989]3.6.2Field Deprecation
              3. [1990]3.6.3Object Extensions
         7. [1991]3.7Interfaces [ ]
              1. [1992]3.7.1Interface Extensions
         8. [1993]3.8Unions [ ]
              1. [1994]3.8.1Union Extensions
         9. [1995]3.9Enums [ ]
              1. [1996]3.9.1Enum Extensions
        10. [1997]3.10Input Objects [ ]
              1. [1998]3.10.1Input Object Extensions
        11. [1999]3.11List
        12. [2000]3.12Non-Null [ ]
              1. [2001]3.12.1Combining List and Non-Null
        13. [2002]3.13Directives [ ]
              1. [2003]3.13.1@skip
              2. [2004]3.13.2@include
              3. [2005]3.13.3@deprecated
              4. [2006]3.13.4@specifiedBy
    4. [2007]4Introspection [ ]
         1. [2008]4.1Type Name Introspection
         2. [2009]4.2Schema Introspection [ ]
              1. [2010]4.2.1The __Schema Type
              2. [2011]4.2.2The __Type Type
              3. [2012]4.2.3The __Field Type
              4. [2013]4.2.4The __InputValue Type
              5. [2014]4.2.5The __EnumValue Type
              6. [2015]4.2.6The __Directive Type
    5. [2016]5Validation [ ]
         1. [2017]5.1Documents [ ]
              1. [2018]5.1.1Executable Definitions
         2. [2019]5.2Operations [ ]
              1. [2020]5.2.1Named Operation Definitions [ ]
                   1. [2021]5.2.1.1Operation Name Uniqueness
              2. [2022]5.2.2Anonymous Operation Definitions [ ]
                   1. [2023]5.2.2.1Lone Anonymous Operation
              3. [2024]5.2.3Subscription Operation Definitions [ ]
                   1. [2025]5.2.3.1Single root field
         3. [2026]5.3Fields [ ]
              1. [2027]5.3.1Field Selections
              2. [2028]5.3.2Field Selection Merging
              3. [2029]5.3.3Leaf Field Selections
         4. [2030]5.4Arguments [ ]
              1. [2031]5.4.1Argument Names
              2. [2032]5.4.2Argument Uniqueness [ ]
                   1. [2033]5.4.2.1Required Arguments
         5. [2034]5.5Fragments [ ]
              1. [2035]5.5.1Fragment Declarations [ ]
                   1. [2036]5.5.1.1Fragment Name Uniqueness
                   2. [2037]5.5.1.2Fragment Spread Type Existence
                   3. [2038]5.5.1.3Fragments On Composite Types
                   4. [2039]5.5.1.4Fragments Must Be Used
              2. [2040]5.5.2Fragment Spreads [ ]
                   1. [2041]5.5.2.1Fragment spread target defined
                   2. [2042]5.5.2.2Fragment spreads must not form cycles
                   3. [2043]5.5.2.3Fragment spread is possible [ ]
                        1. [2044]5.5.2.3.1Object Spreads In Object Scope
                        2. [2045]5.5.2.3.2Abstract Spreads in Object Scope
                        3. [2046]5.5.2.3.3Object Spreads In Abstract Scope
                        4. [2047]5.5.2.3.4Abstract Spreads in Abstract
                           Scope
         6. [2048]5.6Values [ ]
              1. [2049]5.6.1Values of Correct Type
              2. [2050]5.6.2Input Object Field Names
              3. [2051]5.6.3Input Object Field Uniqueness
              4. [2052]5.6.4Input Object Required Fields
         7. [2053]5.7Directives [ ]
              1. [2054]5.7.1Directives Are Defined
              2. [2055]5.7.2Directives Are In Valid Locations
              3. [2056]5.7.3Directives Are Unique Per Location
         8. [2057]5.8Variables [ ]
              1. [2058]5.8.1Variable Uniqueness
              2. [2059]5.8.2Variables Are Input Types
              3. [2060]5.8.3All Variable Uses Defined
              4. [2061]5.8.4All Variables Used
              5. [2062]5.8.5All Variable Usages are Allowed
    6. [2063]6Execution [ ]
         1. [2064]6.1Executing Requests [ ]
              1. [2065]6.1.1Validating Requests
              2. [2066]6.1.2Coercing Variable Values
         2. [2067]6.2Executing Operations [ ]
              1. [2068]6.2.1Query
              2. [2069]6.2.2Mutation
              3. [2070]6.2.3Subscription [ ]
                   1. [2071]6.2.3.1Source Stream
                   2. [2072]6.2.3.2Response Stream
                   3. [2073]6.2.3.3Unsubscribe
         3. [2074]6.3Executing Selection Sets [ ]
              1. [2075]6.3.1Normal and Serial Execution
              2. [2076]6.3.2Field Collection
         4. [2077]6.4Executing Fields [ ]
              1. [2078]6.4.1Coercing Field Arguments
              2. [2079]6.4.2Value Resolution
              3. [2080]6.4.3Value Completion
              4. [2081]6.4.4Handling Field Errors
    7. [2082]7Response [ ]
         1. [2083]7.1Response Format [ ]
              1. [2084]7.1.1Data
              2. [2085]7.1.2Errors
         2. [2086]7.2Serialization Format [ ]
              1. [2087]7.2.1JSON Serialization
              2. [2088]7.2.2Serialized Map Ordering
    8. [2089]AAppendix: Notation Conventions [ ]
         1. [2090]A.1Context-Free Grammar
         2. [2091]A.2Lexical and Syntactical Grammar
         3. [2092]A.3Grammar Notation
         4. [2093]A.4Grammar Semantics
         5. [2094]A.5Algorithms
    9. [2095]BAppendix: Grammar Summary [ ]
         1. [2096]B.1Source Text
         2. [2097]B.2Ignored Tokens
         3. [2098]B.3Lexical Tokens
         4. [2099]B.4Document Syntax
   10. [2100]§Index

References

   1. https://spec.graphql.org/October2021/#sec-Introduction
   2. https://graphql.org/foundation/
   3. https://graphql.org/community/
   4. https://graphql.org/foundation/join/#graphql-foundation
   5. https://github.com/graphql/graphql-spec/releases
   6. https://spec.graphql.org/draft
   7. https://spec.graphql.org/October2021/#sec-Copyright-notice
   8. https://spec.graphql.org/October2021/#sec-Licensing
   9. https://www.jointdevelopment.org/
  10. https://github.com/graphql/graphql-wg
  11. https://technical-charter.graphql.org/
  12. http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0
  13. https://opensource.org/licenses/MIT
  14. https://creativecommons.org/publicdomain/zero/1.0/
  15. https://spec.graphql.org/October2021/#sec-Conformance
  16. https://tools.ietf.org/html/rfc2119
  17. https://spec.graphql.org/October2021/#sec-Conforming-Algorithms
  18. https://spec.graphql.org/October2021/#sec-Appendix-Notation-Conventions
  19. https://spec.graphql.org/October2021/#sec-Non-Normative-Portions
  20. https://spec.graphql.org/October2021/#example-fed99
  21. https://spec.graphql.org/October2021/#example-881bd
  22. https://spec.graphql.org/October2021/#note-c0129
  23. https://spec.graphql.org/October2021/#sec-Overview
  24. https://spec.graphql.org/October2021/#sec-Language
  25. https://spec.graphql.org/October2021/#sec-Language.Source-Text
  26. https://spec.graphql.org/October2021/#sec-Unicode
  27. https://spec.graphql.org/October2021/#sec-White-Space
  28. https://spec.graphql.org/October2021/#sec-Line-Terminators
  29. https://spec.graphql.org/October2021/#sec-Comments
  30. https://spec.graphql.org/October2021/#sec-Insignificant-Commas
  31. https://spec.graphql.org/October2021/#sec-Language.Source-Text.Lexical-Tokens
  32. https://spec.graphql.org/October2021/#sec-Language.Source-Text.Ignored-Tokens
  33. https://spec.graphql.org/October2021/#sec-Punctuators
  34. https://spec.graphql.org/October2021/#sec-Names
  35. https://spec.graphql.org/October2021/#sec-Document
  36. https://spec.graphql.org/October2021/#sec-Language.Operations
  37. https://spec.graphql.org/October2021/#sec-Selection-Sets
  38. https://spec.graphql.org/October2021/#sec-Language.Fields
  39. https://spec.graphql.org/October2021/#sec-Language.Arguments
  40. https://spec.graphql.org/October2021/#sec-Field-Alias
  41. https://spec.graphql.org/October2021/#sec-Language.Fragments
  42. https://spec.graphql.org/October2021/#sec-Type-Conditions
  43. https://spec.graphql.org/October2021/#sec-Inline-Fragments
  44. https://spec.graphql.org/October2021/#sec-Input-Values
  45. https://spec.graphql.org/October2021/#sec-Int-Value
  46. https://spec.graphql.org/October2021/#sec-Float-Value
  47. https://spec.graphql.org/October2021/#sec-Boolean-Value
  48. https://spec.graphql.org/October2021/#sec-String-Value
  49. https://spec.graphql.org/October2021/#sec-Null-Value
  50. https://spec.graphql.org/October2021/#sec-Enum-Value
  51. https://spec.graphql.org/October2021/#sec-List-Value
  52. https://spec.graphql.org/October2021/#sec-Input-Object-Values
  53. https://spec.graphql.org/October2021/#sec-Language.Variables
  54. https://spec.graphql.org/October2021/#sec-Type-References
  55. https://spec.graphql.org/October2021/#sec-Language.Directives
  56. https://spec.graphql.org/October2021/#sec-Type-System
  57. https://spec.graphql.org/October2021/#sec-Type-System-Extensions
  58. https://spec.graphql.org/October2021/#sec-Descriptions
  59. https://spec.graphql.org/October2021/#sec-Schema
  60. https://spec.graphql.org/October2021/#sec-Root-Operation-Types
  61. https://spec.graphql.org/October2021/#sec-Schema-Extension
  62. https://spec.graphql.org/October2021/#sec-Types
  63. https://spec.graphql.org/October2021/#sec-Wrapping-Types
  64. https://spec.graphql.org/October2021/#sec-Input-and-Output-Types
  65. https://spec.graphql.org/October2021/#sec-Type-Extensions
  66. https://spec.graphql.org/October2021/#sec-Scalars
  67. https://spec.graphql.org/October2021/#sec-Int
  68. https://spec.graphql.org/October2021/#sec-Float
  69. https://spec.graphql.org/October2021/#sec-String
  70. https://spec.graphql.org/October2021/#sec-Boolean
  71. https://spec.graphql.org/October2021/#sec-ID
  72. https://spec.graphql.org/October2021/#sec-Scalar-Extensions
  73. https://spec.graphql.org/October2021/#sec-Objects
  74. https://spec.graphql.org/October2021/#sec-Field-Arguments
  75. https://spec.graphql.org/October2021/#sec-Field-Deprecation
  76. https://spec.graphql.org/October2021/#sec-Object-Extensions
  77. https://spec.graphql.org/October2021/#sec-Interfaces
  78. https://spec.graphql.org/October2021/#sec-Interface-Extensions
  79. https://spec.graphql.org/October2021/#sec-Unions
  80. https://spec.graphql.org/October2021/#sec-Union-Extensions
  81. https://spec.graphql.org/October2021/#sec-Enums
  82. https://spec.graphql.org/October2021/#sec-Enum-Extensions
  83. https://spec.graphql.org/October2021/#sec-Input-Objects
  84. https://spec.graphql.org/October2021/#sec-Input-Object-Extensions
  85. https://spec.graphql.org/October2021/#sec-List
  86. https://spec.graphql.org/October2021/#sec-Non-Null
  87. https://spec.graphql.org/October2021/#sec-Combining-List-and-Non-Null
  88. https://spec.graphql.org/October2021/#sec-Type-System.Directives
  89. https://spec.graphql.org/October2021/#sec--skip
  90. https://spec.graphql.org/October2021/#sec--include
  91. https://spec.graphql.org/October2021/#sec--deprecated
  92. https://spec.graphql.org/October2021/#sec--specifiedBy
  93. https://spec.graphql.org/October2021/#sec-Introspection
  94. https://spec.graphql.org/October2021/#sec-Type-Name-Introspection
  95. https://spec.graphql.org/October2021/#sec-Schema-Introspection
  96. https://spec.graphql.org/October2021/#sec-The-__Schema-Type
  97. https://spec.graphql.org/October2021/#sec-The-__Type-Type
  98. https://spec.graphql.org/October2021/#sec-The-__Field-Type
  99. https://spec.graphql.org/October2021/#sec-The-__InputValue-Type
 100. https://spec.graphql.org/October2021/#sec-The-__EnumValue-Type
 101. https://spec.graphql.org/October2021/#sec-The-__Directive-Type
 102. https://spec.graphql.org/October2021/#sec-Validation
 103. https://spec.graphql.org/October2021/#sec-Documents
 104. https://spec.graphql.org/October2021/#sec-Executable-Definitions
 105. https://spec.graphql.org/October2021/#sec-Validation.Operations
 106. https://spec.graphql.org/October2021/#sec-Named-Operation-Definitions
 107. https://spec.graphql.org/October2021/#sec-Operation-Name-Uniqueness
 108. https://spec.graphql.org/October2021/#sec-Anonymous-Operation-Definitions
 109. https://spec.graphql.org/October2021/#sec-Lone-Anonymous-Operation
 110. https://spec.graphql.org/October2021/#sec-Subscription-Operation-Definitions
 111. https://spec.graphql.org/October2021/#sec-Single-root-field
 112. https://spec.graphql.org/October2021/#sec-Validation.Fields
 113. https://spec.graphql.org/October2021/#sec-Field-Selections
 114. https://spec.graphql.org/October2021/#sec-Field-Selection-Merging
 115. https://spec.graphql.org/October2021/#sec-Leaf-Field-Selections
 116. https://spec.graphql.org/October2021/#sec-Validation.Arguments
 117. https://spec.graphql.org/October2021/#sec-Argument-Names
 118. https://spec.graphql.org/October2021/#sec-Argument-Uniqueness
 119. https://spec.graphql.org/October2021/#sec-Required-Arguments
 120. https://spec.graphql.org/October2021/#sec-Validation.Fragments
 121. https://spec.graphql.org/October2021/#sec-Fragment-Declarations
 122. https://spec.graphql.org/October2021/#sec-Fragment-Name-Uniqueness
 123. https://spec.graphql.org/October2021/#sec-Fragment-Spread-Type-Existence
 124. https://spec.graphql.org/October2021/#sec-Fragments-On-Composite-Types
 125. https://spec.graphql.org/October2021/#sec-Fragments-Must-Be-Used
 126. https://spec.graphql.org/October2021/#sec-Fragment-Spreads
 127. https://spec.graphql.org/October2021/#sec-Fragment-spread-target-defined
 128. https://spec.graphql.org/October2021/#sec-Fragment-spreads-must-not-form-cycles
 129. https://spec.graphql.org/October2021/#sec-Fragment-spread-is-possible
 130. https://spec.graphql.org/October2021/#sec-Object-Spreads-In-Object-Scope
 131. https://spec.graphql.org/October2021/#sec-Abstract-Spreads-in-Object-Scope
 132. https://spec.graphql.org/October2021/#sec-Object-Spreads-In-Abstract-Scope
 133. https://spec.graphql.org/October2021/#sec-Abstract-Spreads-in-Abstract-Scope
 134. https://spec.graphql.org/October2021/#sec-Values
 135. https://spec.graphql.org/October2021/#sec-Values-of-Correct-Type
 136. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Names
 137. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Uniqueness
 138. https://spec.graphql.org/October2021/#sec-Input-Object-Required-Fields
 139. https://spec.graphql.org/October2021/#sec-Validation.Directives
 140. https://spec.graphql.org/October2021/#sec-Directives-Are-Defined
 141. https://spec.graphql.org/October2021/#sec-Directives-Are-In-Valid-Locations
 142. https://spec.graphql.org/October2021/#sec-Directives-Are-Unique-Per-Location
 143. https://spec.graphql.org/October2021/#sec-Validation.Variables
 144. https://spec.graphql.org/October2021/#sec-Variable-Uniqueness
 145. https://spec.graphql.org/October2021/#sec-Variables-Are-Input-Types
 146. https://spec.graphql.org/October2021/#sec-All-Variable-Uses-Defined
 147. https://spec.graphql.org/October2021/#sec-All-Variables-Used
 148. https://spec.graphql.org/October2021/#sec-All-Variable-Usages-are-Allowed
 149. https://spec.graphql.org/October2021/#sec-Execution
 150. https://spec.graphql.org/October2021/#sec-Executing-Requests
 151. https://spec.graphql.org/October2021/#sec-Validating-Requests
 152. https://spec.graphql.org/October2021/#sec-Coercing-Variable-Values
 153. https://spec.graphql.org/October2021/#sec-Executing-Operations
 154. https://spec.graphql.org/October2021/#sec-Query
 155. https://spec.graphql.org/October2021/#sec-Mutation
 156. https://spec.graphql.org/October2021/#sec-Subscription
 157. https://spec.graphql.org/October2021/#sec-Source-Stream
 158. https://spec.graphql.org/October2021/#sec-Response-Stream
 159. https://spec.graphql.org/October2021/#sec-Unsubscribe
 160. https://spec.graphql.org/October2021/#sec-Executing-Selection-Sets
 161. https://spec.graphql.org/October2021/#sec-Normal-and-Serial-Execution
 162. https://spec.graphql.org/October2021/#sec-Field-Collection
 163. https://spec.graphql.org/October2021/#sec-Executing-Fields
 164. https://spec.graphql.org/October2021/#sec-Coercing-Field-Arguments
 165. https://spec.graphql.org/October2021/#sec-Value-Resolution
 166. https://spec.graphql.org/October2021/#sec-Value-Completion
 167. https://spec.graphql.org/October2021/#sec-Handling-Field-Errors
 168. https://spec.graphql.org/October2021/#sec-Response
 169. https://spec.graphql.org/October2021/#sec-Response-Format
 170. https://spec.graphql.org/October2021/#sec-Data
 171. https://spec.graphql.org/October2021/#sec-Errors
 172. https://spec.graphql.org/October2021/#sec-Serialization-Format
 173. https://spec.graphql.org/October2021/#sec-JSON-Serialization
 174. https://spec.graphql.org/October2021/#sec-Serialized-Map-Ordering
 175. https://spec.graphql.org/October2021/#sec-Appendix-Notation-Conventions
 176. https://spec.graphql.org/October2021/#sec-Context-Free-Grammar
 177. https://spec.graphql.org/October2021/#sec-Lexical-and-Syntactical-Grammar
 178. https://spec.graphql.org/October2021/#sec-Grammar-Notation
 179. https://spec.graphql.org/October2021/#sec-Grammar-Semantics
 180. https://spec.graphql.org/October2021/#sec-Algorithms
 181. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary
 182. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Source-Text
 183. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Ignored-Tokens
 184. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Lexical-Tokens
 185. https://spec.graphql.org/October2021/#sec-Document-Syntax
 186. https://spec.graphql.org/October2021/#index
 187. https://spec.graphql.org/October2021/#sec-Overview
 188. https://spec.graphql.org/October2021/#example-85684
 189. https://spec.graphql.org/October2021/#example-90fe6
 190. https://spec.graphql.org/October2021/#sec-Language
 191. https://spec.graphql.org/October2021/#SourceCharacter
 192. https://spec.graphql.org/October2021/#Token
 193. https://spec.graphql.org/October2021/#Ignored
 194. https://spec.graphql.org/October2021/#Ignored
 195. https://spec.graphql.org/October2021/#Document
 196. https://spec.graphql.org/October2021/#note-e800c
 197. https://spec.graphql.org/October2021/#sec-Appendix-Notation-Conventions
 198. https://spec.graphql.org/October2021/#sec-Language.Lexical-Analysis-Syntactic-Parse
 199. https://spec.graphql.org/October2021/#Token
 200. https://spec.graphql.org/October2021/#Ignored
 201. https://spec.graphql.org/October2021/#Document
 202. https://spec.graphql.org/October2021/#IntValue
 203. https://spec.graphql.org/October2021/#Digit
 204. https://spec.graphql.org/October2021/#Digit
 205. https://spec.graphql.org/October2021/#Digit
 206. https://spec.graphql.org/October2021/#WhiteSpace
 207. https://spec.graphql.org/October2021/#Ignored
 208. https://spec.graphql.org/October2021/#note-ba22f
 209. https://en.wikipedia.org/wiki/Maximal_munch
 210. https://spec.graphql.org/October2021/#sec-Language.Source-Text
 211. https://spec.graphql.org/October2021/#SourceCharacter
 212. https://unicode.org/standard/standard.html
 213. https://spec.graphql.org/October2021/#note-3e8b0
 214. https://spec.graphql.org/October2021/#StringValue
 215. https://spec.graphql.org/October2021/#Comment
 216. https://spec.graphql.org/October2021/#sec-Unicode
 217. https://spec.graphql.org/October2021/#UnicodeBOM
 218. https://spec.graphql.org/October2021/#sec-White-Space
 219. https://spec.graphql.org/October2021/#WhiteSpace
 220. https://spec.graphql.org/October2021/#Comment
 221. https://spec.graphql.org/October2021/#note-e49cd
 222. https://spec.graphql.org/October2021/#sec-Line-Terminators
 223. https://spec.graphql.org/October2021/#LineTerminator
 224. https://spec.graphql.org/October2021/#note-2b19e
 225. https://spec.graphql.org/October2021/#LineTerminator
 226. https://spec.graphql.org/October2021/#sec-Comments
 227. https://spec.graphql.org/October2021/#Comment
 228. https://spec.graphql.org/October2021/#CommentChar
 229. https://spec.graphql.org/October2021/#CommentChar
 230. https://spec.graphql.org/October2021/#CommentChar
 231. https://spec.graphql.org/October2021/#SourceCharacter
 232. https://spec.graphql.org/October2021/#LineTerminator
 233. https://spec.graphql.org/October2021/#SourceCharacter
 234. https://spec.graphql.org/October2021/#LineTerminator
 235. https://spec.graphql.org/October2021/#LineTerminator
 236. https://spec.graphql.org/October2021/#Ignored
 237. https://spec.graphql.org/October2021/#LineTerminator
 238. https://spec.graphql.org/October2021/#sec-Insignificant-Commas
 239. https://spec.graphql.org/October2021/#Comma
 240. https://spec.graphql.org/October2021/#sec-Language.Source-Text.Lexical-Tokens
 241. https://spec.graphql.org/October2021/#Token
 242. https://spec.graphql.org/October2021/#Punctuator
 243. https://spec.graphql.org/October2021/#Name
 244. https://spec.graphql.org/October2021/#IntValue
 245. https://spec.graphql.org/October2021/#FloatValue
 246. https://spec.graphql.org/October2021/#StringValue
 247. https://spec.graphql.org/October2021/#Ignored
 248. https://spec.graphql.org/October2021/#sec-Language.Source-Text.Ignored-Tokens
 249. https://spec.graphql.org/October2021/#Ignored
 250. https://spec.graphql.org/October2021/#UnicodeBOM
 251. https://spec.graphql.org/October2021/#WhiteSpace
 252. https://spec.graphql.org/October2021/#LineTerminator
 253. https://spec.graphql.org/October2021/#Comment
 254. https://spec.graphql.org/October2021/#Comma
 255. https://spec.graphql.org/October2021/#Ignored
 256. https://spec.graphql.org/October2021/#Ignored
 257. https://spec.graphql.org/October2021/#SourceCharacter
 258. https://spec.graphql.org/October2021/#Ignored
 259. https://spec.graphql.org/October2021/#Token
 260. https://spec.graphql.org/October2021/#StringValue
 261. https://spec.graphql.org/October2021/#Ignored
 262. https://spec.graphql.org/October2021/#Token
 263. https://spec.graphql.org/October2021/#FloatValue
 264. https://spec.graphql.org/October2021/#sec-Punctuators
 265. https://spec.graphql.org/October2021/#Punctuator
 266. https://spec.graphql.org/October2021/#sec-Names
 267. https://spec.graphql.org/October2021/#Name
 268. https://spec.graphql.org/October2021/#NameStart
 269. https://spec.graphql.org/October2021/#NameContinue
 270. https://spec.graphql.org/October2021/#NameContinue
 271. https://spec.graphql.org/October2021/#NameStart
 272. https://spec.graphql.org/October2021/#Letter
 273. https://spec.graphql.org/October2021/#NameContinue
 274. https://spec.graphql.org/October2021/#Letter
 275. https://spec.graphql.org/October2021/#Digit
 276. https://spec.graphql.org/October2021/#Letter
 277. https://spec.graphql.org/October2021/#Digit
 278. https://spec.graphql.org/October2021/#Name
 279. https://spec.graphql.org/October2021/#NameContinue
 280. https://spec.graphql.org/October2021/#Name
 281. https://spec.graphql.org/October2021/#NameContinue
 282. https://spec.graphql.org/October2021/#note-46408
 283. https://spec.graphql.org/October2021/#SourceCharacter
 284. https://spec.graphql.org/October2021/#sec-Names.Reserved-Names
 285. https://spec.graphql.org/October2021/#Name
 286. https://spec.graphql.org/October2021/#sec-Introspection
 287. https://spec.graphql.org/October2021/#sec-Document
 288. https://spec.graphql.org/October2021/#Document
 289. https://spec.graphql.org/October2021/#Definition
 290. https://spec.graphql.org/October2021/#Definition
 291. https://spec.graphql.org/October2021/#ExecutableDefinition
 292. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
 293. https://spec.graphql.org/October2021/#ExecutableDocument
 294. https://spec.graphql.org/October2021/#ExecutableDefinition
 295. https://spec.graphql.org/October2021/#ExecutableDefinition
 296. https://spec.graphql.org/October2021/#OperationDefinition
 297. https://spec.graphql.org/October2021/#FragmentDefinition
 298. https://spec.graphql.org/October2021/#ExecutableDocument
 299. https://spec.graphql.org/October2021/#OperationDefinition
 300. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
 301. https://spec.graphql.org/October2021/#ExecutableDocument
 302. https://spec.graphql.org/October2021/#OperationDefinition
 303. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
 304. https://spec.graphql.org/October2021/#sec-Language.Operations
 305. https://spec.graphql.org/October2021/#OperationDefinition
 306. https://spec.graphql.org/October2021/#OperationType
 307. https://spec.graphql.org/October2021/#Name
 308. https://spec.graphql.org/October2021/#VariableDefinitions
 309. https://spec.graphql.org/October2021/#Directives
 310. https://spec.graphql.org/October2021/#SelectionSet
 311. https://spec.graphql.org/October2021/#SelectionSet
 312. https://spec.graphql.org/October2021/#OperationType
 313. https://spec.graphql.org/October2021/#example-ed6a8
 314. https://spec.graphql.org/October2021/#sec-Language.Operations.Query-shorthand
 315. https://spec.graphql.org/October2021/#example-63b18
 316. https://spec.graphql.org/October2021/#note-5e20f
 317. https://spec.graphql.org/October2021/#sec-Selection-Sets
 318. https://spec.graphql.org/October2021/#SelectionSet
 319. https://spec.graphql.org/October2021/#Selection
 320. https://spec.graphql.org/October2021/#Selection
 321. https://spec.graphql.org/October2021/#Field
 322. https://spec.graphql.org/October2021/#FragmentSpread
 323. https://spec.graphql.org/October2021/#InlineFragment
 324. https://spec.graphql.org/October2021/#example-21649
 325. https://spec.graphql.org/October2021/#sec-Language.Fields
 326. https://spec.graphql.org/October2021/#Field
 327. https://spec.graphql.org/October2021/#Alias
 328. https://spec.graphql.org/October2021/#Name
 329. https://spec.graphql.org/October2021/#Arguments
 330. https://spec.graphql.org/October2021/#Directives
 331. https://spec.graphql.org/October2021/#SelectionSet
 332. https://spec.graphql.org/October2021/#example-100a3
 333. https://spec.graphql.org/October2021/#example-e1984
 334. https://spec.graphql.org/October2021/#sec-Language.Arguments
 335. https://spec.graphql.org/October2021/#Arguments
 336. https://spec.graphql.org/October2021/#Argument
 337. https://spec.graphql.org/October2021/#Argument
 338. https://spec.graphql.org/October2021/#Name
 339. https://spec.graphql.org/October2021/#Value
 340. https://spec.graphql.org/October2021/#example-1a865
 341. https://spec.graphql.org/October2021/#example-34b2d
 342. https://spec.graphql.org/October2021/#sec-Language.Arguments.Arguments-are-unordered
 343. https://spec.graphql.org/October2021/#example-7eba7
 344. https://spec.graphql.org/October2021/#example-c93a3
 345. https://spec.graphql.org/October2021/#sec-Field-Alias
 346. https://spec.graphql.org/October2021/#Alias
 347. https://spec.graphql.org/October2021/#Name
 348. https://spec.graphql.org/October2021/#example-34435
 349. https://spec.graphql.org/October2021/#example-6e98a
 350. https://spec.graphql.org/October2021/#example-27d2f
 351. https://spec.graphql.org/October2021/#example-768a2
 352. https://spec.graphql.org/October2021/#sec-Language.Fragments
 353. https://spec.graphql.org/October2021/#FragmentSpread
 354. https://spec.graphql.org/October2021/#FragmentName
 355. https://spec.graphql.org/October2021/#Directives
 356. https://spec.graphql.org/October2021/#FragmentDefinition
 357. https://spec.graphql.org/October2021/#FragmentName
 358. https://spec.graphql.org/October2021/#TypeCondition
 359. https://spec.graphql.org/October2021/#Directives
 360. https://spec.graphql.org/October2021/#SelectionSet
 361. https://spec.graphql.org/October2021/#FragmentName
 362. https://spec.graphql.org/October2021/#Name
 363. https://spec.graphql.org/October2021/#example-bcf38
 364. https://spec.graphql.org/October2021/#example-72b4e
 365. https://spec.graphql.org/October2021/#example-fb6c3
 366. https://spec.graphql.org/October2021/#sec-Type-Conditions
 367. https://spec.graphql.org/October2021/#TypeCondition
 368. https://spec.graphql.org/October2021/#NamedType
 369. https://spec.graphql.org/October2021/#example-80138
 370. https://spec.graphql.org/October2021/#example-883a1
 371. https://spec.graphql.org/October2021/#sec-Inline-Fragments
 372. https://spec.graphql.org/October2021/#InlineFragment
 373. https://spec.graphql.org/October2021/#TypeCondition
 374. https://spec.graphql.org/October2021/#Directives
 375. https://spec.graphql.org/October2021/#SelectionSet
 376. https://spec.graphql.org/October2021/#example-10b94
 377. https://spec.graphql.org/October2021/#example-77377
 378. https://spec.graphql.org/October2021/#sec-Input-Values
 379. https://spec.graphql.org/October2021/#Value
 380. https://spec.graphql.org/October2021/#Variable
 381. https://spec.graphql.org/October2021/#IntValue
 382. https://spec.graphql.org/October2021/#FloatValue
 383. https://spec.graphql.org/October2021/#StringValue
 384. https://spec.graphql.org/October2021/#BooleanValue
 385. https://spec.graphql.org/October2021/#NullValue
 386. https://spec.graphql.org/October2021/#EnumValue
 387. https://spec.graphql.org/October2021/#ListValue
 388. https://spec.graphql.org/October2021/#ObjectValue
 389. https://spec.graphql.org/October2021/#DefaultValue
 390. https://spec.graphql.org/October2021/#sec-Int-Value
 391. https://spec.graphql.org/October2021/#IntValue
 392. https://spec.graphql.org/October2021/#IntegerPart
 393. https://spec.graphql.org/October2021/#Digit
 394. https://spec.graphql.org/October2021/#NameStart
 395. https://spec.graphql.org/October2021/#IntegerPart
 396. https://spec.graphql.org/October2021/#NegativeSign
 397. https://spec.graphql.org/October2021/#NegativeSign
 398. https://spec.graphql.org/October2021/#NonZeroDigit
 399. https://spec.graphql.org/October2021/#Digit
 400. https://spec.graphql.org/October2021/#NegativeSign
 401. https://spec.graphql.org/October2021/#NonZeroDigit
 402. https://spec.graphql.org/October2021/#Digit
 403. https://spec.graphql.org/October2021/#IntValue
 404. https://spec.graphql.org/October2021/#IntValue
 405. https://spec.graphql.org/October2021/#Digit
 406. https://spec.graphql.org/October2021/#IntValue
 407. https://spec.graphql.org/October2021/#Digit
 408. https://spec.graphql.org/October2021/#IntValue
 409. https://spec.graphql.org/October2021/#NameStart
 410. https://spec.graphql.org/October2021/#ExponentIndicator
 411. https://spec.graphql.org/October2021/#FloatValue
 412. https://spec.graphql.org/October2021/#NameStart
 413. https://spec.graphql.org/October2021/#sec-Float-Value
 414. https://spec.graphql.org/October2021/#FloatValue
 415. https://spec.graphql.org/October2021/#IntegerPart
 416. https://spec.graphql.org/October2021/#FractionalPart
 417. https://spec.graphql.org/October2021/#ExponentPart
 418. https://spec.graphql.org/October2021/#Digit
 419. https://spec.graphql.org/October2021/#NameStart
 420. https://spec.graphql.org/October2021/#IntegerPart
 421. https://spec.graphql.org/October2021/#FractionalPart
 422. https://spec.graphql.org/October2021/#Digit
 423. https://spec.graphql.org/October2021/#NameStart
 424. https://spec.graphql.org/October2021/#IntegerPart
 425. https://spec.graphql.org/October2021/#ExponentPart
 426. https://spec.graphql.org/October2021/#Digit
 427. https://spec.graphql.org/October2021/#NameStart
 428. https://spec.graphql.org/October2021/#FractionalPart
 429. https://spec.graphql.org/October2021/#Digit
 430. https://spec.graphql.org/October2021/#ExponentPart
 431. https://spec.graphql.org/October2021/#ExponentIndicator
 432. https://spec.graphql.org/October2021/#Sign
 433. https://spec.graphql.org/October2021/#Digit
 434. https://spec.graphql.org/October2021/#ExponentIndicator
 435. https://spec.graphql.org/October2021/#Sign
 436. https://spec.graphql.org/October2021/#FloatValue
 437. https://spec.graphql.org/October2021/#IntValue
 438. https://spec.graphql.org/October2021/#FloatValue
 439. https://spec.graphql.org/October2021/#Digit
 440. https://spec.graphql.org/October2021/#FloatValue
 441. https://spec.graphql.org/October2021/#Digit
 442. https://spec.graphql.org/October2021/#FloatValue
 443. https://spec.graphql.org/October2021/#FloatValue
 444. https://spec.graphql.org/October2021/#NameStart
 445. https://spec.graphql.org/October2021/#note-dea61
 446. https://spec.graphql.org/October2021/#IntValue
 447. https://spec.graphql.org/October2021/#FloatValue
 448. https://spec.graphql.org/October2021/#NameStart
 449. https://spec.graphql.org/October2021/#sec-Boolean-Value
 450. https://spec.graphql.org/October2021/#BooleanValue
 451. https://spec.graphql.org/October2021/#sec-String-Value
 452. https://spec.graphql.org/October2021/#StringValue
 453. https://spec.graphql.org/October2021/#StringCharacter
 454. https://spec.graphql.org/October2021/#BlockStringCharacter
 455. https://spec.graphql.org/October2021/#StringCharacter
 456. https://spec.graphql.org/October2021/#SourceCharacter
 457. https://spec.graphql.org/October2021/#LineTerminator
 458. https://spec.graphql.org/October2021/#EscapedUnicode
 459. https://spec.graphql.org/October2021/#EscapedCharacter
 460. https://spec.graphql.org/October2021/#EscapedUnicode
 461. https://spec.graphql.org/October2021/#EscapedCharacter
 462. https://spec.graphql.org/October2021/#BlockStringCharacter
 463. https://spec.graphql.org/October2021/#SourceCharacter
 464. https://spec.graphql.org/October2021/#SourceCharacter
 465. https://spec.graphql.org/October2021/#sec-String-Value.Block-Strings
 466. https://spec.graphql.org/October2021/#SourceCharacter
 467. https://spec.graphql.org/October2021/#BlockStringValue()
 468. https://spec.graphql.org/October2021/#example-fe73f
 469. https://spec.graphql.org/October2021/#example-c6521
 470. https://spec.graphql.org/October2021/#example-8e831
 471. https://spec.graphql.org/October2021/#example-b874e
 472. https://spec.graphql.org/October2021/#note-65771
 473. https://spec.graphql.org/October2021/#sec-String-Value.Semantics
 474. https://spec.graphql.org/October2021/#StringValue
 475. https://spec.graphql.org/October2021/#StringValue
 476. https://spec.graphql.org/October2021/#StringCharacter
 477. https://spec.graphql.org/October2021/#StringCharacter
 478. https://spec.graphql.org/October2021/#StringCharacter
 479. https://spec.graphql.org/October2021/#SourceCharacter
 480. https://spec.graphql.org/October2021/#LineTerminator
 481. https://spec.graphql.org/October2021/#SourceCharacter
 482. https://spec.graphql.org/October2021/#StringCharacter
 483. https://spec.graphql.org/October2021/#EscapedUnicode
 484. https://spec.graphql.org/October2021/#EscapedUnicode
 485. https://spec.graphql.org/October2021/#StringCharacter
 486. https://spec.graphql.org/October2021/#EscapedCharacter
 487. https://spec.graphql.org/October2021/#EscapedCharacter
 488. https://spec.graphql.org/October2021/#StringValue
 489. https://spec.graphql.org/October2021/#BlockStringCharacter
 490. https://spec.graphql.org/October2021/#BlockStringCharacter
 491. https://spec.graphql.org/October2021/#BlockStringValue()
 492. https://spec.graphql.org/October2021/#BlockStringCharacter
 493. https://spec.graphql.org/October2021/#SourceCharacter
 494. https://spec.graphql.org/October2021/#SourceCharacter
 495. https://spec.graphql.org/October2021/#BlockStringCharacter
 496. https://spec.graphql.org/October2021/#BlockStringValue()
 497. https://spec.graphql.org/October2021/#LineTerminator
 498. https://spec.graphql.org/October2021/#WhiteSpace
 499. https://spec.graphql.org/October2021/#WhiteSpace
 500. https://spec.graphql.org/October2021/#WhiteSpace
 501. https://spec.graphql.org/October2021/#sec-Null-Value
 502. https://spec.graphql.org/October2021/#NullValue
 503. https://spec.graphql.org/October2021/#example-1c7eb
 504. https://spec.graphql.org/October2021/#note-eab9b
 505. https://spec.graphql.org/October2021/#sec-Enum-Value
 506. https://spec.graphql.org/October2021/#EnumValue
 507. https://spec.graphql.org/October2021/#Name
 508. https://spec.graphql.org/October2021/#sec-List-Value
 509. https://spec.graphql.org/October2021/#ListValue
 510. https://spec.graphql.org/October2021/#Value
 511. https://spec.graphql.org/October2021/#sec-List-Value.Semantics
 512. https://spec.graphql.org/October2021/#ListValue
 513. https://spec.graphql.org/October2021/#ListValue
 514. https://spec.graphql.org/October2021/#Value
 515. https://spec.graphql.org/October2021/#Value
 516. https://spec.graphql.org/October2021/#Value
 517. https://spec.graphql.org/October2021/#sec-Input-Object-Values
 518. https://spec.graphql.org/October2021/#ObjectValue
 519. https://spec.graphql.org/October2021/#ObjectField
 520. https://spec.graphql.org/October2021/#ObjectField
 521. https://spec.graphql.org/October2021/#Name
 522. https://spec.graphql.org/October2021/#Value
 523. https://spec.graphql.org/October2021/#sec-Input-Object-Values.Input-object-fields-are-unordered
 524. https://spec.graphql.org/October2021/#example-09646
 525. https://spec.graphql.org/October2021/#example-6ebee
 526. https://spec.graphql.org/October2021/#sec-Input-Object-Values.Semantics
 527. https://spec.graphql.org/October2021/#ObjectValue
 528. https://spec.graphql.org/October2021/#ObjectValue
 529. https://spec.graphql.org/October2021/#ObjectField
 530. https://spec.graphql.org/October2021/#ObjectField
 531. https://spec.graphql.org/October2021/#Name
 532. https://spec.graphql.org/October2021/#Value
 533. https://spec.graphql.org/October2021/#sec-Language.Variables
 534. https://spec.graphql.org/October2021/#Variable
 535. https://spec.graphql.org/October2021/#Name
 536. https://spec.graphql.org/October2021/#VariableDefinitions
 537. https://spec.graphql.org/October2021/#VariableDefinition
 538. https://spec.graphql.org/October2021/#VariableDefinition
 539. https://spec.graphql.org/October2021/#Variable
 540. https://spec.graphql.org/October2021/#Type
 541. https://spec.graphql.org/October2021/#DefaultValue
 542. https://spec.graphql.org/October2021/#Directives
 543. https://spec.graphql.org/October2021/#DefaultValue
 544. https://spec.graphql.org/October2021/#Value
 545. https://spec.graphql.org/October2021/#DefaultValue
 546. https://spec.graphql.org/October2021/#Variable
 547. https://spec.graphql.org/October2021/#example-7f690
 548. https://spec.graphql.org/October2021/#example-98958
 549. https://spec.graphql.org/October2021/#sec-Language.Variables.Variable-use-within-Fragments
 550. https://spec.graphql.org/October2021/#sec-All-Variable-Uses-Defined
 551. https://spec.graphql.org/October2021/#sec-Type-References
 552. https://spec.graphql.org/October2021/#Type
 553. https://spec.graphql.org/October2021/#NamedType
 554. https://spec.graphql.org/October2021/#ListType
 555. https://spec.graphql.org/October2021/#NonNullType
 556. https://spec.graphql.org/October2021/#NamedType
 557. https://spec.graphql.org/October2021/#Name
 558. https://spec.graphql.org/October2021/#ListType
 559. https://spec.graphql.org/October2021/#Type
 560. https://spec.graphql.org/October2021/#NonNullType
 561. https://spec.graphql.org/October2021/#NamedType
 562. https://spec.graphql.org/October2021/#ListType
 563. https://spec.graphql.org/October2021/#sec-Type-References.Semantics
 564. https://spec.graphql.org/October2021/#Type
 565. https://spec.graphql.org/October2021/#Name
 566. https://spec.graphql.org/October2021/#Name
 567. https://spec.graphql.org/October2021/#Type
 568. https://spec.graphql.org/October2021/#Type
 569. https://spec.graphql.org/October2021/#Type
 570. https://spec.graphql.org/October2021/#Type
 571. https://spec.graphql.org/October2021/#Type
 572. https://spec.graphql.org/October2021/#Type
 573. https://spec.graphql.org/October2021/#sec-Language.Directives
 574. https://spec.graphql.org/October2021/#Directives
 575. https://spec.graphql.org/October2021/#Directive
 576. https://spec.graphql.org/October2021/#Directive
 577. https://spec.graphql.org/October2021/#Name
 578. https://spec.graphql.org/October2021/#Arguments
 579. https://spec.graphql.org/October2021/#custom-directive
 580. https://spec.graphql.org/October2021/#sec-Language.Directives.Directive-order-is-significant
 581. https://spec.graphql.org/October2021/#example-2a4f9
 582. https://spec.graphql.org/October2021/#example-c1f24
 583. https://spec.graphql.org/October2021/#sec-Type-System
 584. https://spec.graphql.org/October2021/#TypeSystemDocument
 585. https://spec.graphql.org/October2021/#TypeSystemDefinition
 586. https://spec.graphql.org/October2021/#TypeSystemDefinition
 587. https://spec.graphql.org/October2021/#SchemaDefinition
 588. https://spec.graphql.org/October2021/#TypeDefinition
 589. https://spec.graphql.org/October2021/#DirectiveDefinition
 590. https://en.wikipedia.org/wiki/Interface_description_language
 591. https://spec.graphql.org/October2021/#TypeSystemDefinition
 592. https://spec.graphql.org/October2021/#TypeSystemDocument
 593. https://spec.graphql.org/October2021/#ExecutableDefinition
 594. https://spec.graphql.org/October2021/#TypeSystemExtension
 595. https://spec.graphql.org/October2021/#note-d5e8e
 596. https://spec.graphql.org/October2021/#sec-Type-System-Extensions
 597. https://spec.graphql.org/October2021/#TypeSystemExtensionDocument
 598. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
 599. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
 600. https://spec.graphql.org/October2021/#TypeSystemDefinition
 601. https://spec.graphql.org/October2021/#TypeSystemExtension
 602. https://spec.graphql.org/October2021/#TypeSystemExtension
 603. https://spec.graphql.org/October2021/#SchemaExtension
 604. https://spec.graphql.org/October2021/#TypeExtension
 605. https://spec.graphql.org/October2021/#TypeSystemExtensionDocument
 606. https://spec.graphql.org/October2021/#ExecutableDefinition
 607. https://spec.graphql.org/October2021/#sec-Descriptions
 608. https://spec.graphql.org/October2021/#Description
 609. https://spec.graphql.org/October2021/#StringValue
 610. https://commonmark.org/
 611. https://spec.graphql.org/October2021/#Description
 612. https://spec.graphql.org/October2021/#example-916f4
 613. https://spec.graphql.org/October2021/#sec-Schema
 614. https://spec.graphql.org/October2021/#SchemaDefinition
 615. https://spec.graphql.org/October2021/#Description
 616. https://spec.graphql.org/October2021/#Directives
 617. https://spec.graphql.org/October2021/#RootOperationTypeDefinition
 618. https://spec.graphql.org/October2021/#RootOperationTypeDefinition
 619. https://spec.graphql.org/October2021/#OperationType
 620. https://spec.graphql.org/October2021/#NamedType
 621. https://spec.graphql.org/October2021/#sec-Root-Operation-Types
 622. https://spec.graphql.org/October2021/#example-081b4
 623. https://spec.graphql.org/October2021/#example-50137
 624. https://spec.graphql.org/October2021/#example-d1ed8
 625. https://spec.graphql.org/October2021/#example-e2969
 626. https://spec.graphql.org/October2021/#sec-Root-Operation-Types.Default-Root-Operation-Type-Names
 627. https://spec.graphql.org/October2021/#example-9d70f
 628. https://spec.graphql.org/October2021/#sec-Schema-Extension
 629. https://spec.graphql.org/October2021/#SchemaExtension
 630. https://spec.graphql.org/October2021/#Directives
 631. https://spec.graphql.org/October2021/#RootOperationTypeDefinition
 632. https://spec.graphql.org/October2021/#Directives
 633. https://spec.graphql.org/October2021/#note-c9cd2
 634. https://spec.graphql.org/October2021/#sec-Schema-Extension.Schema-Validation
 635. https://spec.graphql.org/October2021/#sec-Types
 636. https://spec.graphql.org/October2021/#TypeDefinition
 637. https://spec.graphql.org/October2021/#ScalarTypeDefinition
 638. https://spec.graphql.org/October2021/#ObjectTypeDefinition
 639. https://spec.graphql.org/October2021/#InterfaceTypeDefinition
 640. https://spec.graphql.org/October2021/#UnionTypeDefinition
 641. https://spec.graphql.org/October2021/#EnumTypeDefinition
 642. https://spec.graphql.org/October2021/#InputObjectTypeDefinition
 643. https://spec.graphql.org/October2021/#sec-Wrapping-Types
 644. https://spec.graphql.org/October2021/#sec-Input-and-Output-Types
 645. https://spec.graphql.org/October2021/#IsInputType()
 646. https://spec.graphql.org/October2021/#IsOutputType()
 647. https://spec.graphql.org/October2021/#sec-Type-Extensions
 648. https://spec.graphql.org/October2021/#TypeExtension
 649. https://spec.graphql.org/October2021/#ScalarTypeExtension
 650. https://spec.graphql.org/October2021/#ObjectTypeExtension
 651. https://spec.graphql.org/October2021/#InterfaceTypeExtension
 652. https://spec.graphql.org/October2021/#UnionTypeExtension
 653. https://spec.graphql.org/October2021/#EnumTypeExtension
 654. https://spec.graphql.org/October2021/#InputObjectTypeExtension
 655. https://spec.graphql.org/October2021/#sec-Scalars
 656. https://spec.graphql.org/October2021/#ScalarTypeDefinition
 657. https://spec.graphql.org/October2021/#Description
 658. https://spec.graphql.org/October2021/#Name
 659. https://spec.graphql.org/October2021/#Directives
 660. https://spec.graphql.org/October2021/#sec-Scalars.Built-in-Scalars
 661. https://spec.graphql.org/October2021/#sec-Scalars.Custom-Scalars
 662. https://tools.ietf.org/html/rfc4122
 663. https://spec.graphql.org/October2021/#scalar-specification-url
 664. https://spec.graphql.org/October2021/#scalar-specification-url
 665. https://spec.graphql.org/October2021/#example-9e6a3
 666. https://spec.graphql.org/October2021/#scalar-specification-url
 667. https://spec.graphql.org/October2021/#scalar-specification-url
 668. https://spec.graphql.org/October2021/#scalar-specification-url
 669. https://spec.graphql.org/October2021/#note-b68f7
 670. https://spec.graphql.org/October2021/#sec-Scalars.Result-Coercion-and-Serialization
 671. https://spec.graphql.org/October2021/#sec-Errors.Field-errors
 672. https://spec.graphql.org/October2021/#sec-Serialization-Format
 673. https://spec.graphql.org/October2021/#sec-Scalars.Input-Coercion
 674. https://spec.graphql.org/October2021/#sec-Errors.Request-errors
 675. https://spec.graphql.org/October2021/#sec-Int
 676. https://spec.graphql.org/October2021/#sec-Int.Result-Coercion
 677. https://spec.graphql.org/October2021/#sec-Int.Input-Coercion
 678. https://spec.graphql.org/October2021/#note-0770a
 679. https://spec.graphql.org/October2021/#sec-Float
 680. https://en.wikipedia.org/wiki/IEEE_floating_point
 681. https://spec.graphql.org/October2021/#sec-Float.Result-Coercion
 682. https://spec.graphql.org/October2021/#sec-Float.Input-Coercion
 683. https://spec.graphql.org/October2021/#sec-String
 684. https://spec.graphql.org/October2021/#sec-String.Result-Coercion
 685. https://spec.graphql.org/October2021/#sec-String.Input-Coercion
 686. https://spec.graphql.org/October2021/#sec-Boolean
 687. https://spec.graphql.org/October2021/#sec-Boolean.Result-Coercion
 688. https://spec.graphql.org/October2021/#sec-Boolean.Input-Coercion
 689. https://spec.graphql.org/October2021/#sec-ID
 690. https://spec.graphql.org/October2021/#sec-ID.Result-Coercion
 691. https://en.wikipedia.org/wiki/Globally_unique_identifier
 692. https://spec.graphql.org/October2021/#sec-ID.Input-Coercion
 693. https://spec.graphql.org/October2021/#sec-Scalar-Extensions
 694. https://spec.graphql.org/October2021/#ScalarTypeExtension
 695. https://spec.graphql.org/October2021/#Name
 696. https://spec.graphql.org/October2021/#Directives
 697. https://spec.graphql.org/October2021/#sec-Scalar-Extensions.Type-Validation
 698. https://spec.graphql.org/October2021/#sec-Objects
 699. https://spec.graphql.org/October2021/#ObjectTypeDefinition
 700. https://spec.graphql.org/October2021/#Description
 701. https://spec.graphql.org/October2021/#Name
 702. https://spec.graphql.org/October2021/#ImplementsInterfaces
 703. https://spec.graphql.org/October2021/#Directives
 704. https://spec.graphql.org/October2021/#FieldsDefinition
 705. https://spec.graphql.org/October2021/#Description
 706. https://spec.graphql.org/October2021/#Name
 707. https://spec.graphql.org/October2021/#ImplementsInterfaces
 708. https://spec.graphql.org/October2021/#Directives
 709. https://spec.graphql.org/October2021/#ImplementsInterfaces
 710. https://spec.graphql.org/October2021/#ImplementsInterfaces
 711. https://spec.graphql.org/October2021/#NamedType
 712. https://spec.graphql.org/October2021/#NamedType
 713. https://spec.graphql.org/October2021/#FieldsDefinition
 714. https://spec.graphql.org/October2021/#FieldDefinition
 715. https://spec.graphql.org/October2021/#FieldDefinition
 716. https://spec.graphql.org/October2021/#Description
 717. https://spec.graphql.org/October2021/#Name
 718. https://spec.graphql.org/October2021/#ArgumentsDefinition
 719. https://spec.graphql.org/October2021/#Type
 720. https://spec.graphql.org/October2021/#Directives
 721. https://spec.graphql.org/October2021/#example-ccb01
 722. https://spec.graphql.org/October2021/#example-1743a
 723. https://spec.graphql.org/October2021/#example-71184
 724. https://spec.graphql.org/October2021/#example-3964f
 725. https://spec.graphql.org/October2021/#example-600a0
 726. https://spec.graphql.org/October2021/#example-49198
 727. https://spec.graphql.org/October2021/#example-729a1
 728. https://spec.graphql.org/October2021/#example-bb999
 729. https://spec.graphql.org/October2021/#example-352cc
 730. https://spec.graphql.org/October2021/#sec-Objects.Field-Ordering
 731. https://spec.graphql.org/October2021/#CollectFields()
 732. https://spec.graphql.org/October2021/#example-7924b
 733. https://spec.graphql.org/October2021/#example-1455b
 734. https://spec.graphql.org/October2021/#example-70ded
 735. https://spec.graphql.org/October2021/#example-2e0e9
 736. https://spec.graphql.org/October2021/#example-50762
 737. https://spec.graphql.org/October2021/#example-dd904
 738. https://spec.graphql.org/October2021/#sec-Objects.Result-Coercion
 739. https://spec.graphql.org/October2021/#sec-Objects.Input-Coercion
 740. https://spec.graphql.org/October2021/#sec-Objects.Type-Validation
 741. https://spec.graphql.org/October2021/#IsOutputType()
 742. https://spec.graphql.org/October2021/#IsInputType()
 743. https://spec.graphql.org/October2021/#IsValidImplementation()
 744. https://spec.graphql.org/October2021/#IsValidImplementation()
 745. https://spec.graphql.org/October2021/#IsValidImplementationFieldType()
 746. https://spec.graphql.org/October2021/#IsValidImplementationFieldType()
 747. https://spec.graphql.org/October2021/#IsValidImplementationFieldType()
 748. https://spec.graphql.org/October2021/#IsValidImplementationFieldType()
 749. https://spec.graphql.org/October2021/#sec-Field-Arguments
 750. https://spec.graphql.org/October2021/#ArgumentsDefinition
 751. https://spec.graphql.org/October2021/#InputValueDefinition
 752. https://spec.graphql.org/October2021/#InputValueDefinition
 753. https://spec.graphql.org/October2021/#Description
 754. https://spec.graphql.org/October2021/#Name
 755. https://spec.graphql.org/October2021/#Type
 756. https://spec.graphql.org/October2021/#DefaultValue
 757. https://spec.graphql.org/October2021/#Directives
 758. https://spec.graphql.org/October2021/#example-fb0d5
 759. https://spec.graphql.org/October2021/#example-81f19
 760. https://spec.graphql.org/October2021/#example-31f7a
 761. https://spec.graphql.org/October2021/#sec-Field-Deprecation
 762. https://spec.graphql.org/October2021/#example-013ef
 763. https://spec.graphql.org/October2021/#sec-Object-Extensions
 764. https://spec.graphql.org/October2021/#ObjectTypeExtension
 765. https://spec.graphql.org/October2021/#Name
 766. https://spec.graphql.org/October2021/#ImplementsInterfaces
 767. https://spec.graphql.org/October2021/#Directives
 768. https://spec.graphql.org/October2021/#FieldsDefinition
 769. https://spec.graphql.org/October2021/#Name
 770. https://spec.graphql.org/October2021/#ImplementsInterfaces
 771. https://spec.graphql.org/October2021/#Directives
 772. https://spec.graphql.org/October2021/#Name
 773. https://spec.graphql.org/October2021/#ImplementsInterfaces
 774. https://spec.graphql.org/October2021/#example-8bda7
 775. https://spec.graphql.org/October2021/#example-605bd
 776. https://spec.graphql.org/October2021/#sec-Object-Extensions.Type-Validation
 777. https://spec.graphql.org/October2021/#sec-Interfaces
 778. https://spec.graphql.org/October2021/#InterfaceTypeDefinition
 779. https://spec.graphql.org/October2021/#Description
 780. https://spec.graphql.org/October2021/#Name
 781. https://spec.graphql.org/October2021/#ImplementsInterfaces
 782. https://spec.graphql.org/October2021/#Directives
 783. https://spec.graphql.org/October2021/#FieldsDefinition
 784. https://spec.graphql.org/October2021/#Description
 785. https://spec.graphql.org/October2021/#Name
 786. https://spec.graphql.org/October2021/#ImplementsInterfaces
 787. https://spec.graphql.org/October2021/#Directives
 788. https://spec.graphql.org/October2021/#example-ab5e5
 789. https://spec.graphql.org/October2021/#example-00227
 790. https://spec.graphql.org/October2021/#example-bc3fd
 791. https://spec.graphql.org/October2021/#example-0c812
 792. https://spec.graphql.org/October2021/#example-47576
 793. https://spec.graphql.org/October2021/#sec-Interfaces.Interfaces-Implementing-Interfaces
 794. https://spec.graphql.org/October2021/#example-ba6cb
 795. https://spec.graphql.org/October2021/#example-4c7ed
 796. https://spec.graphql.org/October2021/#example-9b199
 797. https://spec.graphql.org/October2021/#sec-Interfaces.Result-Coercion
 798. https://spec.graphql.org/October2021/#sec-Interfaces.Input-Coercion
 799. https://spec.graphql.org/October2021/#sec-Interfaces.Type-Validation
 800. https://spec.graphql.org/October2021/#IsOutputType()
 801. https://spec.graphql.org/October2021/#IsInputType()
 802. https://spec.graphql.org/October2021/#IsValidImplementation()
 803. https://spec.graphql.org/October2021/#sec-Interface-Extensions
 804. https://spec.graphql.org/October2021/#InterfaceTypeExtension
 805. https://spec.graphql.org/October2021/#Name
 806. https://spec.graphql.org/October2021/#ImplementsInterfaces
 807. https://spec.graphql.org/October2021/#Directives
 808. https://spec.graphql.org/October2021/#FieldsDefinition
 809. https://spec.graphql.org/October2021/#Name
 810. https://spec.graphql.org/October2021/#ImplementsInterfaces
 811. https://spec.graphql.org/October2021/#Directives
 812. https://spec.graphql.org/October2021/#Name
 813. https://spec.graphql.org/October2021/#ImplementsInterfaces
 814. https://spec.graphql.org/October2021/#example-9d45f
 815. https://spec.graphql.org/October2021/#example-02d28
 816. https://spec.graphql.org/October2021/#sec-Interface-Extensions.Type-Validation
 817. https://spec.graphql.org/October2021/#sec-Unions
 818. https://spec.graphql.org/October2021/#UnionTypeDefinition
 819. https://spec.graphql.org/October2021/#Description
 820. https://spec.graphql.org/October2021/#Name
 821. https://spec.graphql.org/October2021/#Directives
 822. https://spec.graphql.org/October2021/#UnionMemberTypes
 823. https://spec.graphql.org/October2021/#UnionMemberTypes
 824. https://spec.graphql.org/October2021/#UnionMemberTypes
 825. https://spec.graphql.org/October2021/#NamedType
 826. https://spec.graphql.org/October2021/#NamedType
 827. https://spec.graphql.org/October2021/#example-255de
 828. https://spec.graphql.org/October2021/#example-38dc1
 829. https://spec.graphql.org/October2021/#example-f8163
 830. https://spec.graphql.org/October2021/#example-0fbc6
 831. https://spec.graphql.org/October2021/#sec-Unions.Result-Coercion
 832. https://spec.graphql.org/October2021/#sec-Unions.Input-Coercion
 833. https://spec.graphql.org/October2021/#sec-Unions.Type-Validation
 834. https://spec.graphql.org/October2021/#sec-Union-Extensions
 835. https://spec.graphql.org/October2021/#UnionTypeExtension
 836. https://spec.graphql.org/October2021/#Name
 837. https://spec.graphql.org/October2021/#Directives
 838. https://spec.graphql.org/October2021/#UnionMemberTypes
 839. https://spec.graphql.org/October2021/#Name
 840. https://spec.graphql.org/October2021/#Directives
 841. https://spec.graphql.org/October2021/#sec-Union-Extensions.Type-Validation
 842. https://spec.graphql.org/October2021/#sec-Enums
 843. https://spec.graphql.org/October2021/#EnumTypeDefinition
 844. https://spec.graphql.org/October2021/#Description
 845. https://spec.graphql.org/October2021/#Name
 846. https://spec.graphql.org/October2021/#Directives
 847. https://spec.graphql.org/October2021/#EnumValuesDefinition
 848. https://spec.graphql.org/October2021/#Description
 849. https://spec.graphql.org/October2021/#Name
 850. https://spec.graphql.org/October2021/#Directives
 851. https://spec.graphql.org/October2021/#EnumValuesDefinition
 852. https://spec.graphql.org/October2021/#EnumValueDefinition
 853. https://spec.graphql.org/October2021/#EnumValueDefinition
 854. https://spec.graphql.org/October2021/#Description
 855. https://spec.graphql.org/October2021/#EnumValue
 856. https://spec.graphql.org/October2021/#Directives
 857. https://spec.graphql.org/October2021/#example-36555
 858. https://spec.graphql.org/October2021/#sec-Enums.Result-Coercion
 859. https://spec.graphql.org/October2021/#sec-Enums.Input-Coercion
 860. https://github.com/edn-format/edn
 861. https://spec.graphql.org/October2021/#sec-Enums.Type-Validation
 862. https://spec.graphql.org/October2021/#sec-Enum-Extensions
 863. https://spec.graphql.org/October2021/#EnumTypeExtension
 864. https://spec.graphql.org/October2021/#Name
 865. https://spec.graphql.org/October2021/#Directives
 866. https://spec.graphql.org/October2021/#EnumValuesDefinition
 867. https://spec.graphql.org/October2021/#Name
 868. https://spec.graphql.org/October2021/#Directives
 869. https://spec.graphql.org/October2021/#sec-Enum-Extensions.Type-Validation
 870. https://spec.graphql.org/October2021/#sec-Input-Objects
 871. https://spec.graphql.org/October2021/#InputObjectTypeDefinition
 872. https://spec.graphql.org/October2021/#Description
 873. https://spec.graphql.org/October2021/#Name
 874. https://spec.graphql.org/October2021/#Directives
 875. https://spec.graphql.org/October2021/#InputFieldsDefinition
 876. https://spec.graphql.org/October2021/#Description
 877. https://spec.graphql.org/October2021/#Name
 878. https://spec.graphql.org/October2021/#Directives
 879. https://spec.graphql.org/October2021/#InputFieldsDefinition
 880. https://spec.graphql.org/October2021/#InputValueDefinition
 881. https://spec.graphql.org/October2021/#example-45e4e
 882. https://spec.graphql.org/October2021/#note-7a6d2
 883. https://spec.graphql.org/October2021/#ObjectTypeDefinition
 884. https://spec.graphql.org/October2021/#sec-Input-Objects.Circular-References
 885. https://spec.graphql.org/October2021/#example-e9cda
 886. https://spec.graphql.org/October2021/#example-2f832
 887. https://spec.graphql.org/October2021/#example-e70c9
 888. https://spec.graphql.org/October2021/#example-31c9f
 889. https://spec.graphql.org/October2021/#sec-Input-Objects.Result-Coercion
 890. https://spec.graphql.org/October2021/#sec-Input-Objects.Input-Coercion
 891. https://spec.graphql.org/October2021/#example-704b8
 892. https://spec.graphql.org/October2021/#sec-Input-Objects.Type-Validation
 893. https://spec.graphql.org/October2021/#IsInputType()
 894. https://spec.graphql.org/October2021/#sec-Input-Object-Extensions
 895. https://spec.graphql.org/October2021/#InputObjectTypeExtension
 896. https://spec.graphql.org/October2021/#Name
 897. https://spec.graphql.org/October2021/#Directives
 898. https://spec.graphql.org/October2021/#InputFieldsDefinition
 899. https://spec.graphql.org/October2021/#Name
 900. https://spec.graphql.org/October2021/#Directives
 901. https://spec.graphql.org/October2021/#sec-Input-Object-Extensions.Type-Validation
 902. https://spec.graphql.org/October2021/#sec-List
 903. https://spec.graphql.org/October2021/#sec-List.Result-Coercion
 904. https://spec.graphql.org/October2021/#note-6f554
 905. https://spec.graphql.org/October2021/#sec-Handling-Field-Errors
 906. https://spec.graphql.org/October2021/#sec-List.Input-Coercion
 907. https://spec.graphql.org/October2021/#sec-Non-Null
 908. https://spec.graphql.org/October2021/#sec-Non-Null.Nullable-vs-Optional
 909. https://spec.graphql.org/October2021/#sec-Non-Null.Result-Coercion
 910. https://spec.graphql.org/October2021/#note-ad65b
 911. https://spec.graphql.org/October2021/#sec-Non-Null.Input-Coercion
 912. https://spec.graphql.org/October2021/#example-32bbf
 913. https://spec.graphql.org/October2021/#example-da489
 914. https://spec.graphql.org/October2021/#example-6d129
 915. https://spec.graphql.org/October2021/#note-97a45
 916. https://spec.graphql.org/October2021/#sec-Non-Null.Type-Validation
 917. https://spec.graphql.org/October2021/#sec-Combining-List-and-Non-Null
 918. https://spec.graphql.org/October2021/#sec-Type-System.Directives
 919. https://spec.graphql.org/October2021/#DirectiveDefinition
 920. https://spec.graphql.org/October2021/#Description
 921. https://spec.graphql.org/October2021/#Name
 922. https://spec.graphql.org/October2021/#ArgumentsDefinition
 923. https://spec.graphql.org/October2021/#DirectiveLocations
 924. https://spec.graphql.org/October2021/#DirectiveLocations
 925. https://spec.graphql.org/October2021/#DirectiveLocations
 926. https://spec.graphql.org/October2021/#DirectiveLocation
 927. https://spec.graphql.org/October2021/#DirectiveLocation
 928. https://spec.graphql.org/October2021/#DirectiveLocation
 929. https://spec.graphql.org/October2021/#ExecutableDirectiveLocation
 930. https://spec.graphql.org/October2021/#TypeSystemDirectiveLocation
 931. https://spec.graphql.org/October2021/#ExecutableDirectiveLocation
 932. https://spec.graphql.org/October2021/#TypeSystemDirectiveLocation
 933. https://spec.graphql.org/October2021/#sec-Type-System.Directives.Built-in-Directives
 934. https://spec.graphql.org/October2021/#built-in-directive
 935. https://spec.graphql.org/October2021/#built-in-directive
 936. https://spec.graphql.org/October2021/#built-in-directive
 937. https://spec.graphql.org/October2021/#sec-Type-System.Directives.Custom-Directives
 938. https://spec.graphql.org/October2021/#custom-directive
 939. https://spec.graphql.org/October2021/#note-39239
 940. https://spec.graphql.org/October2021/#custom-directive
 941. https://spec.graphql.org/October2021/#built-in-directive
 942. https://spec.graphql.org/October2021/#custom-directive
 943. https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md
 944. https://spec.graphql.org/October2021/#example-060af
 945. https://spec.graphql.org/October2021/#example-79697
 946. https://spec.graphql.org/October2021/#example-c3a06
 947. https://spec.graphql.org/October2021/#example-67869
 948. https://spec.graphql.org/October2021/#example-79945
 949. https://spec.graphql.org/October2021/#note-921fb
 950. https://spec.graphql.org/October2021/#sec-Type-System.Directives.Validation
 951. https://spec.graphql.org/October2021/#IsInputType()
 952. https://spec.graphql.org/October2021/#sec--skip
 953. https://spec.graphql.org/October2021/#built-in-directive
 954. https://spec.graphql.org/October2021/#example-cb6b7
 955. https://spec.graphql.org/October2021/#sec--include
 956. https://spec.graphql.org/October2021/#built-in-directive
 957. https://spec.graphql.org/October2021/#example-aa3a0
 958. https://spec.graphql.org/October2021/#note-f3059
 959. https://spec.graphql.org/October2021/#sec--deprecated
 960. https://spec.graphql.org/October2021/#built-in-directive
 961. https://commonmark.org/
 962. https://spec.graphql.org/October2021/#example-d0cdc
 963. https://spec.graphql.org/October2021/#sec--specifiedBy
 964. https://spec.graphql.org/October2021/#built-in-directive
 965. https://spec.graphql.org/October2021/#scalar-specification-url
 966. https://spec.graphql.org/October2021/#sec-Scalars.Custom-Scalars
 967. https://spec.graphql.org/October2021/#example-e5b0d
 968. https://spec.graphql.org/October2021/#sec-Introspection
 969. https://spec.graphql.org/October2021/#example-3005e
 970. https://spec.graphql.org/October2021/#example-2efd3
 971. https://spec.graphql.org/October2021/#example-47d72
 972. https://spec.graphql.org/October2021/#sec-Introspection.Reserved-Names
 973. https://spec.graphql.org/October2021/#Name
 974. https://spec.graphql.org/October2021/#sec-Type-Name-Introspection
 975. https://spec.graphql.org/October2021/#note-bc213
 976. https://spec.graphql.org/October2021/#sec-Schema-Introspection
 977. https://spec.graphql.org/October2021/#sec-Schema-Introspection.First-Class-Documentation
 978. https://commonmark.org/
 979. https://spec.graphql.org/October2021/#sec-Schema-Introspection.Deprecation
 980. https://spec.graphql.org/October2021/#sec-Schema-Introspection.Schema-Introspection-Schema
 981. https://spec.graphql.org/October2021/#sec-The-__Schema-Type
 982. https://spec.graphql.org/October2021/#sec-The-__Type-Type
 983. https://spec.graphql.org/October2021/#sec-The-__Type-Type.Scalar
 984. https://spec.graphql.org/October2021/#sec-Scalars.Custom-Scalars
 985. https://spec.graphql.org/October2021/#scalar-specification-url
 986. https://spec.graphql.org/October2021/#sec-The-__Type-Type.Object
 987. https://spec.graphql.org/October2021/#sec-The-__Type-Type.Union
 988. https://spec.graphql.org/October2021/#sec-The-__Type-Type.Interface
 989. https://spec.graphql.org/October2021/#sec-The-__Type-Type.Enum
 990. https://spec.graphql.org/October2021/#sec-The-__Type-Type.Input-Object
 991. https://spec.graphql.org/October2021/#example-a0e6d
 992. https://spec.graphql.org/October2021/#sec-The-__Type-Type.List
 993. https://spec.graphql.org/October2021/#sec-The-__Type-Type.Non-Null
 994. https://spec.graphql.org/October2021/#sec-The-__Field-Type
 995. https://spec.graphql.org/October2021/#sec-The-__InputValue-Type
 996. https://spec.graphql.org/October2021/#sec-The-__EnumValue-Type
 997. https://spec.graphql.org/October2021/#sec-The-__Directive-Type
 998. https://spec.graphql.org/October2021/#built-in-directive
 999. https://spec.graphql.org/October2021/#custom-directive
1000. https://spec.graphql.org/October2021/#sec-Validation
1001. https://spec.graphql.org/October2021/#sec-Validation.Type-system-evolution
1002. https://spec.graphql.org/October2021/#sec-Validation.Examples
1003. https://spec.graphql.org/October2021/#example-19f2a
1004. https://spec.graphql.org/October2021/#sec-Documents
1005. https://spec.graphql.org/October2021/#sec-Executable-Definitions
1006. https://spec.graphql.org/October2021/#sec-Executable-Definitions.Formal-Specification
1007. https://spec.graphql.org/October2021/#ExecutableDefinition
1008. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
1009. https://spec.graphql.org/October2021/#sec-Executable-Definitions.Explanatory-Text
1010. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
1011. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
1012. https://spec.graphql.org/October2021/#example-12752
1013. https://spec.graphql.org/October2021/#sec-Validation.Operations
1014. https://spec.graphql.org/October2021/#sec-Named-Operation-Definitions
1015. https://spec.graphql.org/October2021/#sec-Operation-Name-Uniqueness
1016. https://spec.graphql.org/October2021/#sec-Operation-Name-Uniqueness.Formal-Specification
1017. https://spec.graphql.org/October2021/#sec-Operation-Name-Uniqueness.Explanatory-Text
1018. https://spec.graphql.org/October2021/#example-069e1
1019. https://spec.graphql.org/October2021/#example-5e409
1020. https://spec.graphql.org/October2021/#example-77c2e
1021. https://spec.graphql.org/October2021/#sec-Anonymous-Operation-Definitions
1022. https://spec.graphql.org/October2021/#sec-Lone-Anonymous-Operation
1023. https://spec.graphql.org/October2021/#sec-Lone-Anonymous-Operation.Formal-Specification
1024. https://spec.graphql.org/October2021/#sec-Lone-Anonymous-Operation.Explanatory-Text
1025. https://spec.graphql.org/October2021/#example-be853
1026. https://spec.graphql.org/October2021/#example-44b85
1027. https://spec.graphql.org/October2021/#sec-Subscription-Operation-Definitions
1028. https://spec.graphql.org/October2021/#sec-Single-root-field
1029. https://spec.graphql.org/October2021/#sec-Single-root-field.Formal-Specification
1030. https://spec.graphql.org/October2021/#CollectFields()
1031. https://spec.graphql.org/October2021/#sec-Single-root-field.Explanatory-Text
1032. https://spec.graphql.org/October2021/#example-5bbc3
1033. https://spec.graphql.org/October2021/#example-13061
1034. https://spec.graphql.org/October2021/#example-3997d
1035. https://spec.graphql.org/October2021/#example-18466
1036. https://spec.graphql.org/October2021/#example-a8fa1
1037. https://spec.graphql.org/October2021/#note-80ec0
1038. https://spec.graphql.org/October2021/#GetOperation()
1039. https://spec.graphql.org/October2021/#sec-Validation.Fields
1040. https://spec.graphql.org/October2021/#sec-Field-Selections
1041. https://spec.graphql.org/October2021/#sec-Field-Selections.Formal-Specification
1042. https://spec.graphql.org/October2021/#sec-Field-Selections.Explanatory-Text
1043. https://spec.graphql.org/October2021/#example-48706
1044. https://spec.graphql.org/October2021/#example-d34e0
1045. https://spec.graphql.org/October2021/#example-db33b
1046. https://spec.graphql.org/October2021/#example-245fa
1047. https://spec.graphql.org/October2021/#example-252ad
1048. https://spec.graphql.org/October2021/#sec-Field-Selection-Merging
1049. https://spec.graphql.org/October2021/#sec-Field-Selection-Merging.Formal-Specification
1050. https://spec.graphql.org/October2021/#FieldsInSetCanMerge()
1051. https://spec.graphql.org/October2021/#FieldsInSetCanMerge()
1052. https://spec.graphql.org/October2021/#SameResponseShape()
1053. https://spec.graphql.org/October2021/#FieldsInSetCanMerge()
1054. https://spec.graphql.org/October2021/#SameResponseShape()
1055. https://spec.graphql.org/October2021/#SameResponseShape()
1056. https://spec.graphql.org/October2021/#sec-Field-Selection-Merging.Explanatory-Text
1057. https://spec.graphql.org/October2021/#MergeSelectionSets()
1058. https://spec.graphql.org/October2021/#CollectFields()
1059. https://spec.graphql.org/October2021/#example-4e10c
1060. https://spec.graphql.org/October2021/#example-a2230
1061. https://spec.graphql.org/October2021/#example-b6369
1062. https://spec.graphql.org/October2021/#example-00fbf
1063. https://spec.graphql.org/October2021/#example-a8406
1064. https://spec.graphql.org/October2021/#example-54e3d
1065. https://spec.graphql.org/October2021/#sec-Leaf-Field-Selections
1066. https://spec.graphql.org/October2021/#sec-Leaf-Field-Selections.Formal-Specification
1067. https://spec.graphql.org/October2021/#sec-Leaf-Field-Selections.Explanatory-Text
1068. https://spec.graphql.org/October2021/#example-e23c5
1069. https://spec.graphql.org/October2021/#example-13b69
1070. https://spec.graphql.org/October2021/#example-9bada
1071. https://spec.graphql.org/October2021/#example-d68ee
1072. https://spec.graphql.org/October2021/#sec-Validation.Arguments
1073. https://spec.graphql.org/October2021/#sec-Argument-Names
1074. https://spec.graphql.org/October2021/#sec-Argument-Names.Formal-Specification
1075. https://spec.graphql.org/October2021/#sec-Argument-Names.Explanatory-Text
1076. https://spec.graphql.org/October2021/#example-dfd15
1077. https://spec.graphql.org/October2021/#example-d5639
1078. https://spec.graphql.org/October2021/#example-df41e
1079. https://spec.graphql.org/October2021/#example-73706
1080. https://spec.graphql.org/October2021/#example-bda7e
1081. https://spec.graphql.org/October2021/#sec-Argument-Uniqueness
1082. https://spec.graphql.org/October2021/#sec-Argument-Uniqueness.Formal-Specification
1083. https://spec.graphql.org/October2021/#sec-Required-Arguments
1084. https://spec.graphql.org/October2021/#sec-Required-Arguments.Explanatory-Text
1085. https://spec.graphql.org/October2021/#example-503bd
1086. https://spec.graphql.org/October2021/#example-1f1d2
1087. https://spec.graphql.org/October2021/#example-f12a1
1088. https://spec.graphql.org/October2021/#example-0bc81
1089. https://spec.graphql.org/October2021/#sec-Validation.Fragments
1090. https://spec.graphql.org/October2021/#sec-Fragment-Declarations
1091. https://spec.graphql.org/October2021/#sec-Fragment-Name-Uniqueness
1092. https://spec.graphql.org/October2021/#sec-Fragment-Name-Uniqueness.Formal-Specification
1093. https://spec.graphql.org/October2021/#sec-Fragment-Name-Uniqueness.Explanatory-Text
1094. https://spec.graphql.org/October2021/#example-3703b
1095. https://spec.graphql.org/October2021/#example-2c3e3
1096. https://spec.graphql.org/October2021/#sec-Fragment-Spread-Type-Existence
1097. https://spec.graphql.org/October2021/#sec-Fragment-Spread-Type-Existence.Formal-Specification
1098. https://spec.graphql.org/October2021/#sec-Fragment-Spread-Type-Existence.Explanatory-Text
1099. https://spec.graphql.org/October2021/#example-1b2da
1100. https://spec.graphql.org/October2021/#example-463f6
1101. https://spec.graphql.org/October2021/#sec-Fragments-On-Composite-Types
1102. https://spec.graphql.org/October2021/#sec-Fragments-On-Composite-Types.Formal-Specification
1103. https://spec.graphql.org/October2021/#sec-Fragments-On-Composite-Types.Explanatory-Text
1104. https://spec.graphql.org/October2021/#example-3c8d4
1105. https://spec.graphql.org/October2021/#example-4d5e5
1106. https://spec.graphql.org/October2021/#sec-Fragments-Must-Be-Used
1107. https://spec.graphql.org/October2021/#sec-Fragments-Must-Be-Used.Formal-Specification
1108. https://spec.graphql.org/October2021/#sec-Fragments-Must-Be-Used.Explanatory-Text
1109. https://spec.graphql.org/October2021/#example-9e1e3
1110. https://spec.graphql.org/October2021/#sec-Fragment-Spreads
1111. https://spec.graphql.org/October2021/#sec-Fragment-spread-target-defined
1112. https://spec.graphql.org/October2021/#sec-Fragment-spread-target-defined.Formal-Specification
1113. https://spec.graphql.org/October2021/#sec-Fragment-spread-target-defined.Explanatory-Text
1114. https://spec.graphql.org/October2021/#example-28421
1115. https://spec.graphql.org/October2021/#sec-Fragment-spreads-must-not-form-cycles
1116. https://spec.graphql.org/October2021/#sec-Fragment-spreads-must-not-form-cycles.Formal-Specification
1117. https://spec.graphql.org/October2021/#DetectFragmentCycles()
1118. https://spec.graphql.org/October2021/#DetectFragmentCycles()
1119. https://spec.graphql.org/October2021/#DetectFragmentCycles()
1120. https://spec.graphql.org/October2021/#sec-Fragment-spreads-must-not-form-cycles.Explanatory-Text
1121. https://spec.graphql.org/October2021/#example-9ceb4
1122. https://spec.graphql.org/October2021/#example-08734
1123. https://spec.graphql.org/October2021/#example-cd11c
1124. https://spec.graphql.org/October2021/#sec-Fragment-spread-is-possible
1125. https://spec.graphql.org/October2021/#sec-Fragment-spread-is-possible.Formal-Specification
1126. https://spec.graphql.org/October2021/#GetPossibleTypes()
1127. https://spec.graphql.org/October2021/#GetPossibleTypes()
1128. https://spec.graphql.org/October2021/#GetPossibleTypes()
1129. https://spec.graphql.org/October2021/#sec-Fragment-spread-is-possible.Explanatory-Text
1130. https://spec.graphql.org/October2021/#sec-Object-Spreads-In-Object-Scope
1131. https://spec.graphql.org/October2021/#example-0fc38
1132. https://spec.graphql.org/October2021/#example-4d411
1133. https://spec.graphql.org/October2021/#sec-Abstract-Spreads-in-Object-Scope
1134. https://spec.graphql.org/October2021/#example-2c8d0
1135. https://spec.graphql.org/October2021/#example-41843
1136. https://spec.graphql.org/October2021/#sec-Object-Spreads-In-Abstract-Scope
1137. https://spec.graphql.org/October2021/#example-85110
1138. https://spec.graphql.org/October2021/#example-a8dcc
1139. https://spec.graphql.org/October2021/#sec-Abstract-Spreads-in-Abstract-Scope
1140. https://spec.graphql.org/October2021/#example-dc875
1141. https://spec.graphql.org/October2021/#example-c9c63
1142. https://spec.graphql.org/October2021/#sec-Abstract-Spreads-in-Abstract-Scope.Interface-Spreads-in-implemented-Interface-Scope
1143. https://spec.graphql.org/October2021/#example-bc12a
1144. https://spec.graphql.org/October2021/#sec-Values
1145. https://spec.graphql.org/October2021/#sec-Values-of-Correct-Type
1146. https://spec.graphql.org/October2021/#sec-Values-of-Correct-Type.Formal-Specification
1147. https://spec.graphql.org/October2021/#sec-Values-of-Correct-Type.Explanatory-Text
1148. https://spec.graphql.org/October2021/#example-7ee0e
1149. https://spec.graphql.org/October2021/#example-3a7c1
1150. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Names
1151. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Names.Formal-Specification
1152. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Names.Explanatory-Text
1153. https://spec.graphql.org/October2021/#example-a940b
1154. https://spec.graphql.org/October2021/#example-1a5f6
1155. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Uniqueness
1156. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Uniqueness.Formal-Specification
1157. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Uniqueness.Explanatory-Text
1158. https://spec.graphql.org/October2021/#example-5d541
1159. https://spec.graphql.org/October2021/#sec-Input-Object-Required-Fields
1160. https://spec.graphql.org/October2021/#sec-Input-Object-Required-Fields.Formal-Specification
1161. https://spec.graphql.org/October2021/#sec-Input-Object-Required-Fields.Explanatory-Text
1162. https://spec.graphql.org/October2021/#sec-Validation.Directives
1163. https://spec.graphql.org/October2021/#sec-Directives-Are-Defined
1164. https://spec.graphql.org/October2021/#sec-Directives-Are-Defined.Formal-Specification
1165. https://spec.graphql.org/October2021/#sec-Directives-Are-Defined.Explanatory-Text
1166. https://spec.graphql.org/October2021/#sec-Directives-Are-In-Valid-Locations
1167. https://spec.graphql.org/October2021/#sec-Directives-Are-In-Valid-Locations.Formal-Specification
1168. https://spec.graphql.org/October2021/#sec-Directives-Are-In-Valid-Locations.Explanatory-Text
1169. https://spec.graphql.org/October2021/#example-55f3f
1170. https://spec.graphql.org/October2021/#sec-Directives-Are-Unique-Per-Location
1171. https://spec.graphql.org/October2021/#sec-Directives-Are-Unique-Per-Location.Formal-Specification
1172. https://spec.graphql.org/October2021/#sec-Directives-Are-Unique-Per-Location.Explanatory-Text
1173. https://spec.graphql.org/October2021/#example-b2e6c
1174. https://spec.graphql.org/October2021/#example-c5ee9
1175. https://spec.graphql.org/October2021/#sec-Validation.Variables
1176. https://spec.graphql.org/October2021/#sec-Variable-Uniqueness
1177. https://spec.graphql.org/October2021/#sec-Variable-Uniqueness.Formal-Specification
1178. https://spec.graphql.org/October2021/#sec-Variable-Uniqueness.Explanatory-Text
1179. https://spec.graphql.org/October2021/#example-abc9c
1180. https://spec.graphql.org/October2021/#example-54c93
1181. https://spec.graphql.org/October2021/#sec-Variables-Are-Input-Types
1182. https://spec.graphql.org/October2021/#sec-Variables-Are-Input-Types.Formal-Specification
1183. https://spec.graphql.org/October2021/#IsInputType()
1184. https://spec.graphql.org/October2021/#sec-Variables-Are-Input-Types.Explanatory-Text
1185. https://spec.graphql.org/October2021/#example-ce150
1186. https://spec.graphql.org/October2021/#example-a4255
1187. https://spec.graphql.org/October2021/#example-aeba9
1188. https://spec.graphql.org/October2021/#sec-All-Variable-Uses-Defined
1189. https://spec.graphql.org/October2021/#sec-All-Variable-Uses-Defined.Formal-Specification
1190. https://spec.graphql.org/October2021/#sec-All-Variable-Uses-Defined.Explanatory-Text
1191. https://spec.graphql.org/October2021/#example-38119
1192. https://spec.graphql.org/October2021/#example-5ba94
1193. https://spec.graphql.org/October2021/#example-559c2
1194. https://spec.graphql.org/October2021/#example-93d3e
1195. https://spec.graphql.org/October2021/#example-ee7be
1196. https://spec.graphql.org/October2021/#example-d601e
1197. https://spec.graphql.org/October2021/#example-2b284
1198. https://spec.graphql.org/October2021/#sec-All-Variables-Used
1199. https://spec.graphql.org/October2021/#sec-All-Variables-Used.Formal-Specification
1200. https://spec.graphql.org/October2021/#sec-All-Variables-Used.Explanatory-Text
1201. https://spec.graphql.org/October2021/#example-464b6
1202. https://spec.graphql.org/October2021/#example-6d4bb
1203. https://spec.graphql.org/October2021/#example-a30e2
1204. https://spec.graphql.org/October2021/#example-e647f
1205. https://spec.graphql.org/October2021/#sec-All-Variable-Usages-are-Allowed
1206. https://spec.graphql.org/October2021/#sec-All-Variable-Usages-are-Allowed.Formal-Specification
1207. https://spec.graphql.org/October2021/#VariableDefinition
1208. https://spec.graphql.org/October2021/#IsVariableUsageAllowed()
1209. https://spec.graphql.org/October2021/#IsVariableUsageAllowed()
1210. https://spec.graphql.org/October2021/#Argument
1211. https://spec.graphql.org/October2021/#ObjectField
1212. https://spec.graphql.org/October2021/#ListValue
1213. https://spec.graphql.org/October2021/#Argument
1214. https://spec.graphql.org/October2021/#ObjectField
1215. https://spec.graphql.org/October2021/#AreTypesCompatible()
1216. https://spec.graphql.org/October2021/#AreTypesCompatible()
1217. https://spec.graphql.org/October2021/#AreTypesCompatible()
1218. https://spec.graphql.org/October2021/#AreTypesCompatible()
1219. https://spec.graphql.org/October2021/#AreTypesCompatible()
1220. https://spec.graphql.org/October2021/#AreTypesCompatible()
1221. https://spec.graphql.org/October2021/#sec-All-Variable-Usages-are-Allowed.Explanatory-Text
1222. https://spec.graphql.org/October2021/#example-2028e
1223. https://spec.graphql.org/October2021/#example-8d369
1224. https://spec.graphql.org/October2021/#example-ed727
1225. https://spec.graphql.org/October2021/#example-c5959
1226. https://spec.graphql.org/October2021/#example-64255
1227. https://spec.graphql.org/October2021/#sec-All-Variable-Usages-are-Allowed.Allowing-optional-variables-when-default-values-exist
1228. https://spec.graphql.org/October2021/#example-0877c
1229. https://spec.graphql.org/October2021/#example-d24d9
1230. https://spec.graphql.org/October2021/#note-f0f28
1231. https://spec.graphql.org/October2021/#sec-Execution
1232. https://spec.graphql.org/October2021/#Document
1233. https://spec.graphql.org/October2021/#OperationDefinition
1234. https://spec.graphql.org/October2021/#FragmentDefinition
1235. https://spec.graphql.org/October2021/#ExecuteRequest()
1236. https://spec.graphql.org/October2021/#sec-Executing-Requests
1237. https://spec.graphql.org/October2021/#Document
1238. https://spec.graphql.org/October2021/#ExecuteRequest()
1239. https://spec.graphql.org/October2021/#GetOperation()
1240. https://spec.graphql.org/October2021/#CoerceVariableValues()
1241. https://spec.graphql.org/October2021/#ExecuteQuery()
1242. https://spec.graphql.org/October2021/#ExecuteMutation()
1243. https://spec.graphql.org/October2021/#Subscribe()
1244. https://spec.graphql.org/October2021/#GetOperation()
1245. https://spec.graphql.org/October2021/#sec-Validating-Requests
1246. https://spec.graphql.org/October2021/#sec-Coercing-Variable-Values
1247. https://spec.graphql.org/October2021/#CoerceVariableValues()
1248. https://spec.graphql.org/October2021/#IsInputType()
1249. https://spec.graphql.org/October2021/#note-38e04
1250. https://spec.graphql.org/October2021/#CoerceArgumentValues()
1251. https://spec.graphql.org/October2021/#sec-Executing-Operations
1252. https://spec.graphql.org/October2021/#sec-Query
1253. https://spec.graphql.org/October2021/#ExecuteQuery()
1254. https://spec.graphql.org/October2021/#ExecuteSelectionSet()
1255. https://spec.graphql.org/October2021/#sec-Mutation
1256. https://spec.graphql.org/October2021/#ExecuteMutation()
1257. https://spec.graphql.org/October2021/#ExecuteSelectionSet()
1258. https://spec.graphql.org/October2021/#sec-Subscription
1259. https://spec.graphql.org/October2021/#Subscribe()
1260. https://spec.graphql.org/October2021/#CreateSourceEventStream()
1261. https://spec.graphql.org/October2021/#MapSourceToResponseEvent()
1262. https://spec.graphql.org/October2021/#note-79d56
1263. https://spec.graphql.org/October2021/#Subscribe()
1264. https://spec.graphql.org/October2021/#ExecuteSubscriptionEvent()
1265. https://spec.graphql.org/October2021/#example-2a5f0
1266. https://spec.graphql.org/October2021/#example-a4629
1267. https://spec.graphql.org/October2021/#sec-Subscription.Event-Streams
1268. https://spec.graphql.org/October2021/#sec-Subscription.Supporting-Subscriptions-at-Scale
1269. https://spec.graphql.org/October2021/#sec-Subscription.Delivery-Agnostic
1270. https://spec.graphql.org/October2021/#sec-Source-Stream
1271. https://spec.graphql.org/October2021/#CreateSourceEventStream()
1272. https://spec.graphql.org/October2021/#CollectFields()
1273. https://spec.graphql.org/October2021/#CoerceArgumentValues()
1274. https://spec.graphql.org/October2021/#ResolveFieldEventStream()
1275. https://spec.graphql.org/October2021/#ResolveFieldEventStream()
1276. https://spec.graphql.org/October2021/#note-5869a
1277. https://spec.graphql.org/October2021/#ResolveFieldEventStream()
1278. https://spec.graphql.org/October2021/#ResolveFieldValue()
1279. https://spec.graphql.org/October2021/#sec-Response-Stream
1280. https://spec.graphql.org/October2021/#MapSourceToResponseEvent()
1281. https://spec.graphql.org/October2021/#ExecuteSubscriptionEvent()
1282. https://spec.graphql.org/October2021/#ExecuteSubscriptionEvent()
1283. https://spec.graphql.org/October2021/#ExecuteSelectionSet()
1284. https://spec.graphql.org/October2021/#note-5fb9c
1285. https://spec.graphql.org/October2021/#ExecuteSubscriptionEvent()
1286. https://spec.graphql.org/October2021/#ExecuteQuery()
1287. https://spec.graphql.org/October2021/#sec-Unsubscribe
1288. https://spec.graphql.org/October2021/#Unsubscribe()
1289. https://spec.graphql.org/October2021/#sec-Executing-Selection-Sets
1290. https://spec.graphql.org/October2021/#ExecuteSelectionSet()
1291. https://spec.graphql.org/October2021/#CollectFields()
1292. https://spec.graphql.org/October2021/#ExecuteField()
1293. https://spec.graphql.org/October2021/#note-b8f81
1294. https://spec.graphql.org/October2021/#sec-Executing-Selection-Sets.Errors-and-Non-Null-Fields
1295. https://spec.graphql.org/October2021/#ExecuteSelectionSet()
1296. https://spec.graphql.org/October2021/#note-4dd38
1297. https://spec.graphql.org/October2021/#sec-Handling-Field-Errors
1298. https://spec.graphql.org/October2021/#sec-Normal-and-Serial-Execution
1299. https://spec.graphql.org/October2021/#example-65e7d
1300. https://spec.graphql.org/October2021/#example-33b6a
1301. https://spec.graphql.org/October2021/#ExecuteField()
1302. https://spec.graphql.org/October2021/#CompleteValue()
1303. https://spec.graphql.org/October2021/#ExecuteField()
1304. https://spec.graphql.org/October2021/#CompleteValue()
1305. https://spec.graphql.org/October2021/#example-c91a3
1306. https://spec.graphql.org/October2021/#example-1d82c
1307. https://spec.graphql.org/October2021/#sec-Field-Collection
1308. https://spec.graphql.org/October2021/#CollectFields()
1309. https://spec.graphql.org/October2021/#example-fdbb7
1310. https://spec.graphql.org/October2021/#CollectFields()
1311. https://spec.graphql.org/October2021/#CollectFields()
1312. https://spec.graphql.org/October2021/#Field
1313. https://spec.graphql.org/October2021/#FragmentSpread
1314. https://spec.graphql.org/October2021/#DoesFragmentTypeApply()
1315. https://spec.graphql.org/October2021/#CollectFields()
1316. https://spec.graphql.org/October2021/#InlineFragment
1317. https://spec.graphql.org/October2021/#DoesFragmentTypeApply()
1318. https://spec.graphql.org/October2021/#CollectFields()
1319. https://spec.graphql.org/October2021/#DoesFragmentTypeApply()
1320. https://spec.graphql.org/October2021/#note-f1a76
1321. https://spec.graphql.org/October2021/#CollectFields()
1322. https://spec.graphql.org/October2021/#sec-Executing-Fields
1323. https://spec.graphql.org/October2021/#ExecuteField()
1324. https://spec.graphql.org/October2021/#CoerceArgumentValues()
1325. https://spec.graphql.org/October2021/#ResolveFieldValue()
1326. https://spec.graphql.org/October2021/#CompleteValue()
1327. https://spec.graphql.org/October2021/#sec-Coercing-Field-Arguments
1328. https://spec.graphql.org/October2021/#Value
1329. https://spec.graphql.org/October2021/#Variable
1330. https://spec.graphql.org/October2021/#CoerceArgumentValues()
1331. https://spec.graphql.org/October2021/#Variable
1332. https://spec.graphql.org/October2021/#Variable
1333. https://spec.graphql.org/October2021/#note-65769
1334. https://spec.graphql.org/October2021/#CoerceVariableValues()
1335. https://spec.graphql.org/October2021/#sec-Value-Resolution
1336. https://spec.graphql.org/October2021/#ResolveFieldValue()
1337. https://spec.graphql.org/October2021/#note-7bf5f
1338. https://spec.graphql.org/October2021/#sec-Value-Completion
1339. https://spec.graphql.org/October2021/#CompleteValue()
1340. https://spec.graphql.org/October2021/#CompleteValue()
1341. https://spec.graphql.org/October2021/#CompleteValue()
1342. https://spec.graphql.org/October2021/#CoerceResult()
1343. https://spec.graphql.org/October2021/#ResolveAbstractType()
1344. https://spec.graphql.org/October2021/#MergeSelectionSets()
1345. https://spec.graphql.org/October2021/#ExecuteSelectionSet()
1346. https://spec.graphql.org/October2021/#sec-Value-Completion.Coercing-Results
1347. https://spec.graphql.org/October2021/#sec-Scalars.Result-Coercion-and-Serialization
1348. https://spec.graphql.org/October2021/#CoerceResult()
1349. https://spec.graphql.org/October2021/#note-5bde4
1350. https://spec.graphql.org/October2021/#CompleteValue()
1351. https://spec.graphql.org/October2021/#CoerceResult()
1352. https://spec.graphql.org/October2021/#CoerceResult()
1353. https://spec.graphql.org/October2021/#sec-Value-Completion.Resolving-Abstract-Types
1354. https://spec.graphql.org/October2021/#note-5ee58
1355. https://spec.graphql.org/October2021/#ResolveAbstractType()
1356. https://spec.graphql.org/October2021/#sec-Value-Completion.Merging-Selection-Sets
1357. https://spec.graphql.org/October2021/#example-77852
1358. https://spec.graphql.org/October2021/#MergeSelectionSets()
1359. https://spec.graphql.org/October2021/#sec-Handling-Field-Errors
1360. https://spec.graphql.org/October2021/#sec-Errors.Field-errors
1361. https://spec.graphql.org/October2021/#note-c78be
1362. https://spec.graphql.org/October2021/#sec-Errors.Request-errors
1363. https://spec.graphql.org/October2021/#sec-Response
1364. https://spec.graphql.org/October2021/#sec-Response-Format
1365. https://spec.graphql.org/October2021/#note-6f005
1366. https://spec.graphql.org/October2021/#sec-Data
1367. https://spec.graphql.org/October2021/#sec-Errors
1368. https://spec.graphql.org/October2021/#sec-Errors.Request-errors
1369. https://spec.graphql.org/October2021/#sec-Errors.Field-errors
1370. https://spec.graphql.org/October2021/#sec-Handling-Field-Errors
1371. https://spec.graphql.org/October2021/#sec-Errors.Error-result-format
1372. https://spec.graphql.org/October2021/#example-bc485
1373. https://spec.graphql.org/October2021/#example-072c4
1374. https://spec.graphql.org/October2021/#example-c18ef
1375. https://spec.graphql.org/October2021/#example-8b658
1376. https://spec.graphql.org/October2021/#note-5c13b
1377. https://spec.graphql.org/October2021/#example-78af4
1378. https://spec.graphql.org/October2021/#sec-Serialization-Format
1379. https://spec.graphql.org/October2021/#sec-JSON-Serialization
1380. https://spec.graphql.org/October2021/#note-786e2
1381. https://spec.graphql.org/October2021/#sec-Serialized-Map-Ordering
1382. https://spec.graphql.org/October2021/#CollectFields()
1383. https://tools.ietf.org/html/rfc7159#section-4
1384. https://spec.graphql.org/October2021/#note-4bb20
1385. https://spec.graphql.org/October2021/#sec-Appendix-Notation-Conventions
1386. https://spec.graphql.org/October2021/#sec-Context-Free-Grammar
1387. https://spec.graphql.org/October2021/#Name
1388. https://spec.graphql.org/October2021/#NonTerminalWithSingleDefinition
1389. https://spec.graphql.org/October2021/#NonTerminalWithManyDefinitions
1390. https://spec.graphql.org/October2021/#ListOfLetterA
1391. https://spec.graphql.org/October2021/#ListOfLetterA
1392. https://spec.graphql.org/October2021/#sec-Lexical-and-Syntactical-Grammar
1393. https://spec.graphql.org/October2021/#Word
1394. https://spec.graphql.org/October2021/#Letter
1395. https://spec.graphql.org/October2021/#WhiteSpace
1396. https://spec.graphql.org/October2021/#Ignored
1397. https://spec.graphql.org/October2021/#Token
1398. https://spec.graphql.org/October2021/#Sentence
1399. https://spec.graphql.org/October2021/#Word
1400. https://spec.graphql.org/October2021/#sec-Grammar-Notation
1401. https://spec.graphql.org/October2021/#sec-Grammar-Notation.Constraints
1402. https://spec.graphql.org/October2021/#SafeWord
1403. https://spec.graphql.org/October2021/#Word
1404. https://spec.graphql.org/October2021/#SafeWord
1405. https://spec.graphql.org/October2021/#Word
1406. https://spec.graphql.org/October2021/#NonBooleanName
1407. https://spec.graphql.org/October2021/#Name
1408. https://spec.graphql.org/October2021/#sec-Grammar-Notation.Lookahead-Restrictions
1409. https://spec.graphql.org/October2021/#Letter
1410. https://spec.graphql.org/October2021/#Word
1411. https://spec.graphql.org/October2021/#Letter
1412. https://spec.graphql.org/October2021/#Word
1413. https://spec.graphql.org/October2021/#Letter
1414. https://spec.graphql.org/October2021/#Letter
1415. https://spec.graphql.org/October2021/#sec-Grammar-Notation.Optionality-and-Lists
1416. https://spec.graphql.org/October2021/#Sentence
1417. https://spec.graphql.org/October2021/#Sentence
1418. https://spec.graphql.org/October2021/#Book
1419. https://spec.graphql.org/October2021/#Book
1420. https://spec.graphql.org/October2021/#Page_list
1421. https://spec.graphql.org/October2021/#Page_list
1422. https://spec.graphql.org/October2021/#Page_list
1423. https://spec.graphql.org/October2021/#sec-Grammar-Notation.Parameterized-Grammar-Productions
1424. https://spec.graphql.org/October2021/#Example
1425. https://spec.graphql.org/October2021/#Example
1426. https://spec.graphql.org/October2021/#Example_param
1427. https://spec.graphql.org/October2021/#sec-Grammar-Semantics
1428. https://spec.graphql.org/October2021/#StringValue
1429. https://spec.graphql.org/October2021/#StringValue
1430. https://spec.graphql.org/October2021/#StringCharacter
1431. https://spec.graphql.org/October2021/#StringCharacter
1432. https://spec.graphql.org/October2021/#sec-Algorithms
1433. https://spec.graphql.org/October2021/#Fibonacci()
1434. https://spec.graphql.org/October2021/#Fibonacci()
1435. https://spec.graphql.org/October2021/#Fibonacci()
1436. https://spec.graphql.org/October2021/#note-edb29
1437. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary
1438. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Source-Text
1439. https://spec.graphql.org/October2021/#SourceCharacter
1440. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Ignored-Tokens
1441. https://spec.graphql.org/October2021/#Ignored
1442. https://spec.graphql.org/October2021/#UnicodeBOM
1443. https://spec.graphql.org/October2021/#WhiteSpace
1444. https://spec.graphql.org/October2021/#LineTerminator
1445. https://spec.graphql.org/October2021/#Comment
1446. https://spec.graphql.org/October2021/#Comma
1447. https://spec.graphql.org/October2021/#UnicodeBOM
1448. https://spec.graphql.org/October2021/#WhiteSpace
1449. https://spec.graphql.org/October2021/#LineTerminator
1450. https://spec.graphql.org/October2021/#Comment
1451. https://spec.graphql.org/October2021/#CommentChar
1452. https://spec.graphql.org/October2021/#CommentChar
1453. https://spec.graphql.org/October2021/#CommentChar
1454. https://spec.graphql.org/October2021/#SourceCharacter
1455. https://spec.graphql.org/October2021/#LineTerminator
1456. https://spec.graphql.org/October2021/#Comma
1457. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Lexical-Tokens
1458. https://spec.graphql.org/October2021/#Token
1459. https://spec.graphql.org/October2021/#Punctuator
1460. https://spec.graphql.org/October2021/#Name
1461. https://spec.graphql.org/October2021/#IntValue
1462. https://spec.graphql.org/October2021/#FloatValue
1463. https://spec.graphql.org/October2021/#StringValue
1464. https://spec.graphql.org/October2021/#Punctuator
1465. https://spec.graphql.org/October2021/#Name
1466. https://spec.graphql.org/October2021/#NameStart
1467. https://spec.graphql.org/October2021/#NameContinue
1468. https://spec.graphql.org/October2021/#NameContinue
1469. https://spec.graphql.org/October2021/#NameStart
1470. https://spec.graphql.org/October2021/#Letter
1471. https://spec.graphql.org/October2021/#NameContinue
1472. https://spec.graphql.org/October2021/#Letter
1473. https://spec.graphql.org/October2021/#Digit
1474. https://spec.graphql.org/October2021/#Letter
1475. https://spec.graphql.org/October2021/#Digit
1476. https://spec.graphql.org/October2021/#IntValue
1477. https://spec.graphql.org/October2021/#IntegerPart
1478. https://spec.graphql.org/October2021/#Digit
1479. https://spec.graphql.org/October2021/#NameStart
1480. https://spec.graphql.org/October2021/#IntegerPart
1481. https://spec.graphql.org/October2021/#NegativeSign
1482. https://spec.graphql.org/October2021/#NegativeSign
1483. https://spec.graphql.org/October2021/#NonZeroDigit
1484. https://spec.graphql.org/October2021/#Digit
1485. https://spec.graphql.org/October2021/#NegativeSign
1486. https://spec.graphql.org/October2021/#NonZeroDigit
1487. https://spec.graphql.org/October2021/#Digit
1488. https://spec.graphql.org/October2021/#FloatValue
1489. https://spec.graphql.org/October2021/#IntegerPart
1490. https://spec.graphql.org/October2021/#FractionalPart
1491. https://spec.graphql.org/October2021/#ExponentPart
1492. https://spec.graphql.org/October2021/#Digit
1493. https://spec.graphql.org/October2021/#NameStart
1494. https://spec.graphql.org/October2021/#IntegerPart
1495. https://spec.graphql.org/October2021/#FractionalPart
1496. https://spec.graphql.org/October2021/#Digit
1497. https://spec.graphql.org/October2021/#NameStart
1498. https://spec.graphql.org/October2021/#IntegerPart
1499. https://spec.graphql.org/October2021/#ExponentPart
1500. https://spec.graphql.org/October2021/#Digit
1501. https://spec.graphql.org/October2021/#NameStart
1502. https://spec.graphql.org/October2021/#FractionalPart
1503. https://spec.graphql.org/October2021/#Digit
1504. https://spec.graphql.org/October2021/#ExponentPart
1505. https://spec.graphql.org/October2021/#ExponentIndicator
1506. https://spec.graphql.org/October2021/#Sign
1507. https://spec.graphql.org/October2021/#Digit
1508. https://spec.graphql.org/October2021/#ExponentIndicator
1509. https://spec.graphql.org/October2021/#Sign
1510. https://spec.graphql.org/October2021/#StringValue
1511. https://spec.graphql.org/October2021/#StringCharacter
1512. https://spec.graphql.org/October2021/#BlockStringCharacter
1513. https://spec.graphql.org/October2021/#StringCharacter
1514. https://spec.graphql.org/October2021/#SourceCharacter
1515. https://spec.graphql.org/October2021/#LineTerminator
1516. https://spec.graphql.org/October2021/#EscapedUnicode
1517. https://spec.graphql.org/October2021/#EscapedCharacter
1518. https://spec.graphql.org/October2021/#EscapedUnicode
1519. https://spec.graphql.org/October2021/#EscapedCharacter
1520. https://spec.graphql.org/October2021/#BlockStringCharacter
1521. https://spec.graphql.org/October2021/#SourceCharacter
1522. https://spec.graphql.org/October2021/#note-5ad29
1523. https://spec.graphql.org/October2021/#BlockStringValue()
1524. https://spec.graphql.org/October2021/#sec-Document-Syntax
1525. https://spec.graphql.org/October2021/#Document
1526. https://spec.graphql.org/October2021/#Definition
1527. https://spec.graphql.org/October2021/#Definition
1528. https://spec.graphql.org/October2021/#ExecutableDefinition
1529. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
1530. https://spec.graphql.org/October2021/#ExecutableDocument
1531. https://spec.graphql.org/October2021/#ExecutableDefinition
1532. https://spec.graphql.org/October2021/#ExecutableDefinition
1533. https://spec.graphql.org/October2021/#OperationDefinition
1534. https://spec.graphql.org/October2021/#FragmentDefinition
1535. https://spec.graphql.org/October2021/#OperationDefinition
1536. https://spec.graphql.org/October2021/#OperationType
1537. https://spec.graphql.org/October2021/#Name
1538. https://spec.graphql.org/October2021/#VariableDefinitions
1539. https://spec.graphql.org/October2021/#Directives
1540. https://spec.graphql.org/October2021/#SelectionSet
1541. https://spec.graphql.org/October2021/#SelectionSet
1542. https://spec.graphql.org/October2021/#OperationType
1543. https://spec.graphql.org/October2021/#SelectionSet
1544. https://spec.graphql.org/October2021/#Selection
1545. https://spec.graphql.org/October2021/#Selection
1546. https://spec.graphql.org/October2021/#Field
1547. https://spec.graphql.org/October2021/#FragmentSpread
1548. https://spec.graphql.org/October2021/#InlineFragment
1549. https://spec.graphql.org/October2021/#Field
1550. https://spec.graphql.org/October2021/#Alias
1551. https://spec.graphql.org/October2021/#Name
1552. https://spec.graphql.org/October2021/#Arguments
1553. https://spec.graphql.org/October2021/#Directives
1554. https://spec.graphql.org/October2021/#SelectionSet
1555. https://spec.graphql.org/October2021/#Alias
1556. https://spec.graphql.org/October2021/#Name
1557. https://spec.graphql.org/October2021/#Arguments
1558. https://spec.graphql.org/October2021/#Argument
1559. https://spec.graphql.org/October2021/#Argument
1560. https://spec.graphql.org/October2021/#Name
1561. https://spec.graphql.org/October2021/#Value
1562. https://spec.graphql.org/October2021/#FragmentSpread
1563. https://spec.graphql.org/October2021/#FragmentName
1564. https://spec.graphql.org/October2021/#Directives
1565. https://spec.graphql.org/October2021/#InlineFragment
1566. https://spec.graphql.org/October2021/#TypeCondition
1567. https://spec.graphql.org/October2021/#Directives
1568. https://spec.graphql.org/October2021/#SelectionSet
1569. https://spec.graphql.org/October2021/#FragmentDefinition
1570. https://spec.graphql.org/October2021/#FragmentName
1571. https://spec.graphql.org/October2021/#TypeCondition
1572. https://spec.graphql.org/October2021/#Directives
1573. https://spec.graphql.org/October2021/#SelectionSet
1574. https://spec.graphql.org/October2021/#FragmentName
1575. https://spec.graphql.org/October2021/#Name
1576. https://spec.graphql.org/October2021/#TypeCondition
1577. https://spec.graphql.org/October2021/#NamedType
1578. https://spec.graphql.org/October2021/#Value
1579. https://spec.graphql.org/October2021/#Variable
1580. https://spec.graphql.org/October2021/#IntValue
1581. https://spec.graphql.org/October2021/#FloatValue
1582. https://spec.graphql.org/October2021/#StringValue
1583. https://spec.graphql.org/October2021/#BooleanValue
1584. https://spec.graphql.org/October2021/#NullValue
1585. https://spec.graphql.org/October2021/#EnumValue
1586. https://spec.graphql.org/October2021/#ListValue
1587. https://spec.graphql.org/October2021/#ObjectValue
1588. https://spec.graphql.org/October2021/#BooleanValue
1589. https://spec.graphql.org/October2021/#NullValue
1590. https://spec.graphql.org/October2021/#EnumValue
1591. https://spec.graphql.org/October2021/#Name
1592. https://spec.graphql.org/October2021/#ListValue
1593. https://spec.graphql.org/October2021/#Value
1594. https://spec.graphql.org/October2021/#ObjectValue
1595. https://spec.graphql.org/October2021/#ObjectField
1596. https://spec.graphql.org/October2021/#ObjectField
1597. https://spec.graphql.org/October2021/#Name
1598. https://spec.graphql.org/October2021/#Value
1599. https://spec.graphql.org/October2021/#VariableDefinitions
1600. https://spec.graphql.org/October2021/#VariableDefinition
1601. https://spec.graphql.org/October2021/#VariableDefinition
1602. https://spec.graphql.org/October2021/#Variable
1603. https://spec.graphql.org/October2021/#Type
1604. https://spec.graphql.org/October2021/#DefaultValue
1605. https://spec.graphql.org/October2021/#Directives
1606. https://spec.graphql.org/October2021/#Variable
1607. https://spec.graphql.org/October2021/#Name
1608. https://spec.graphql.org/October2021/#DefaultValue
1609. https://spec.graphql.org/October2021/#Value
1610. https://spec.graphql.org/October2021/#Type
1611. https://spec.graphql.org/October2021/#NamedType
1612. https://spec.graphql.org/October2021/#ListType
1613. https://spec.graphql.org/October2021/#NonNullType
1614. https://spec.graphql.org/October2021/#NamedType
1615. https://spec.graphql.org/October2021/#Name
1616. https://spec.graphql.org/October2021/#ListType
1617. https://spec.graphql.org/October2021/#Type
1618. https://spec.graphql.org/October2021/#NonNullType
1619. https://spec.graphql.org/October2021/#NamedType
1620. https://spec.graphql.org/October2021/#ListType
1621. https://spec.graphql.org/October2021/#Directives
1622. https://spec.graphql.org/October2021/#Directive
1623. https://spec.graphql.org/October2021/#Directive
1624. https://spec.graphql.org/October2021/#Name
1625. https://spec.graphql.org/October2021/#Arguments
1626. https://spec.graphql.org/October2021/#TypeSystemDocument
1627. https://spec.graphql.org/October2021/#TypeSystemDefinition
1628. https://spec.graphql.org/October2021/#TypeSystemDefinition
1629. https://spec.graphql.org/October2021/#SchemaDefinition
1630. https://spec.graphql.org/October2021/#TypeDefinition
1631. https://spec.graphql.org/October2021/#DirectiveDefinition
1632. https://spec.graphql.org/October2021/#TypeSystemExtensionDocument
1633. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
1634. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
1635. https://spec.graphql.org/October2021/#TypeSystemDefinition
1636. https://spec.graphql.org/October2021/#TypeSystemExtension
1637. https://spec.graphql.org/October2021/#TypeSystemExtension
1638. https://spec.graphql.org/October2021/#SchemaExtension
1639. https://spec.graphql.org/October2021/#TypeExtension
1640. https://spec.graphql.org/October2021/#SchemaDefinition
1641. https://spec.graphql.org/October2021/#Description
1642. https://spec.graphql.org/October2021/#Directives
1643. https://spec.graphql.org/October2021/#RootOperationTypeDefinition
1644. https://spec.graphql.org/October2021/#SchemaExtension
1645. https://spec.graphql.org/October2021/#Directives
1646. https://spec.graphql.org/October2021/#RootOperationTypeDefinition
1647. https://spec.graphql.org/October2021/#Directives
1648. https://spec.graphql.org/October2021/#RootOperationTypeDefinition
1649. https://spec.graphql.org/October2021/#OperationType
1650. https://spec.graphql.org/October2021/#NamedType
1651. https://spec.graphql.org/October2021/#Description
1652. https://spec.graphql.org/October2021/#StringValue
1653. https://spec.graphql.org/October2021/#TypeDefinition
1654. https://spec.graphql.org/October2021/#ScalarTypeDefinition
1655. https://spec.graphql.org/October2021/#ObjectTypeDefinition
1656. https://spec.graphql.org/October2021/#InterfaceTypeDefinition
1657. https://spec.graphql.org/October2021/#UnionTypeDefinition
1658. https://spec.graphql.org/October2021/#EnumTypeDefinition
1659. https://spec.graphql.org/October2021/#InputObjectTypeDefinition
1660. https://spec.graphql.org/October2021/#TypeExtension
1661. https://spec.graphql.org/October2021/#ScalarTypeExtension
1662. https://spec.graphql.org/October2021/#ObjectTypeExtension
1663. https://spec.graphql.org/October2021/#InterfaceTypeExtension
1664. https://spec.graphql.org/October2021/#UnionTypeExtension
1665. https://spec.graphql.org/October2021/#EnumTypeExtension
1666. https://spec.graphql.org/October2021/#InputObjectTypeExtension
1667. https://spec.graphql.org/October2021/#ScalarTypeDefinition
1668. https://spec.graphql.org/October2021/#Description
1669. https://spec.graphql.org/October2021/#Name
1670. https://spec.graphql.org/October2021/#Directives
1671. https://spec.graphql.org/October2021/#ScalarTypeExtension
1672. https://spec.graphql.org/October2021/#Name
1673. https://spec.graphql.org/October2021/#Directives
1674. https://spec.graphql.org/October2021/#ObjectTypeDefinition
1675. https://spec.graphql.org/October2021/#Description
1676. https://spec.graphql.org/October2021/#Name
1677. https://spec.graphql.org/October2021/#ImplementsInterfaces
1678. https://spec.graphql.org/October2021/#Directives
1679. https://spec.graphql.org/October2021/#FieldsDefinition
1680. https://spec.graphql.org/October2021/#Description
1681. https://spec.graphql.org/October2021/#Name
1682. https://spec.graphql.org/October2021/#ImplementsInterfaces
1683. https://spec.graphql.org/October2021/#Directives
1684. https://spec.graphql.org/October2021/#ObjectTypeExtension
1685. https://spec.graphql.org/October2021/#Name
1686. https://spec.graphql.org/October2021/#ImplementsInterfaces
1687. https://spec.graphql.org/October2021/#Directives
1688. https://spec.graphql.org/October2021/#FieldsDefinition
1689. https://spec.graphql.org/October2021/#Name
1690. https://spec.graphql.org/October2021/#ImplementsInterfaces
1691. https://spec.graphql.org/October2021/#Directives
1692. https://spec.graphql.org/October2021/#Name
1693. https://spec.graphql.org/October2021/#ImplementsInterfaces
1694. https://spec.graphql.org/October2021/#ImplementsInterfaces
1695. https://spec.graphql.org/October2021/#ImplementsInterfaces
1696. https://spec.graphql.org/October2021/#NamedType
1697. https://spec.graphql.org/October2021/#NamedType
1698. https://spec.graphql.org/October2021/#FieldsDefinition
1699. https://spec.graphql.org/October2021/#FieldDefinition
1700. https://spec.graphql.org/October2021/#FieldDefinition
1701. https://spec.graphql.org/October2021/#Description
1702. https://spec.graphql.org/October2021/#Name
1703. https://spec.graphql.org/October2021/#ArgumentsDefinition
1704. https://spec.graphql.org/October2021/#Type
1705. https://spec.graphql.org/October2021/#Directives
1706. https://spec.graphql.org/October2021/#ArgumentsDefinition
1707. https://spec.graphql.org/October2021/#InputValueDefinition
1708. https://spec.graphql.org/October2021/#InputValueDefinition
1709. https://spec.graphql.org/October2021/#Description
1710. https://spec.graphql.org/October2021/#Name
1711. https://spec.graphql.org/October2021/#Type
1712. https://spec.graphql.org/October2021/#DefaultValue
1713. https://spec.graphql.org/October2021/#Directives
1714. https://spec.graphql.org/October2021/#InterfaceTypeDefinition
1715. https://spec.graphql.org/October2021/#Description
1716. https://spec.graphql.org/October2021/#Name
1717. https://spec.graphql.org/October2021/#ImplementsInterfaces
1718. https://spec.graphql.org/October2021/#Directives
1719. https://spec.graphql.org/October2021/#FieldsDefinition
1720. https://spec.graphql.org/October2021/#Description
1721. https://spec.graphql.org/October2021/#Name
1722. https://spec.graphql.org/October2021/#ImplementsInterfaces
1723. https://spec.graphql.org/October2021/#Directives
1724. https://spec.graphql.org/October2021/#InterfaceTypeExtension
1725. https://spec.graphql.org/October2021/#Name
1726. https://spec.graphql.org/October2021/#ImplementsInterfaces
1727. https://spec.graphql.org/October2021/#Directives
1728. https://spec.graphql.org/October2021/#FieldsDefinition
1729. https://spec.graphql.org/October2021/#Name
1730. https://spec.graphql.org/October2021/#ImplementsInterfaces
1731. https://spec.graphql.org/October2021/#Directives
1732. https://spec.graphql.org/October2021/#Name
1733. https://spec.graphql.org/October2021/#ImplementsInterfaces
1734. https://spec.graphql.org/October2021/#UnionTypeDefinition
1735. https://spec.graphql.org/October2021/#Description
1736. https://spec.graphql.org/October2021/#Name
1737. https://spec.graphql.org/October2021/#Directives
1738. https://spec.graphql.org/October2021/#UnionMemberTypes
1739. https://spec.graphql.org/October2021/#UnionMemberTypes
1740. https://spec.graphql.org/October2021/#UnionMemberTypes
1741. https://spec.graphql.org/October2021/#NamedType
1742. https://spec.graphql.org/October2021/#NamedType
1743. https://spec.graphql.org/October2021/#UnionTypeExtension
1744. https://spec.graphql.org/October2021/#Name
1745. https://spec.graphql.org/October2021/#Directives
1746. https://spec.graphql.org/October2021/#UnionMemberTypes
1747. https://spec.graphql.org/October2021/#Name
1748. https://spec.graphql.org/October2021/#Directives
1749. https://spec.graphql.org/October2021/#EnumTypeDefinition
1750. https://spec.graphql.org/October2021/#Description
1751. https://spec.graphql.org/October2021/#Name
1752. https://spec.graphql.org/October2021/#Directives
1753. https://spec.graphql.org/October2021/#EnumValuesDefinition
1754. https://spec.graphql.org/October2021/#Description
1755. https://spec.graphql.org/October2021/#Name
1756. https://spec.graphql.org/October2021/#Directives
1757. https://spec.graphql.org/October2021/#EnumValuesDefinition
1758. https://spec.graphql.org/October2021/#EnumValueDefinition
1759. https://spec.graphql.org/October2021/#EnumValueDefinition
1760. https://spec.graphql.org/October2021/#Description
1761. https://spec.graphql.org/October2021/#EnumValue
1762. https://spec.graphql.org/October2021/#Directives
1763. https://spec.graphql.org/October2021/#EnumTypeExtension
1764. https://spec.graphql.org/October2021/#Name
1765. https://spec.graphql.org/October2021/#Directives
1766. https://spec.graphql.org/October2021/#EnumValuesDefinition
1767. https://spec.graphql.org/October2021/#Name
1768. https://spec.graphql.org/October2021/#Directives
1769. https://spec.graphql.org/October2021/#InputObjectTypeDefinition
1770. https://spec.graphql.org/October2021/#Description
1771. https://spec.graphql.org/October2021/#Name
1772. https://spec.graphql.org/October2021/#Directives
1773. https://spec.graphql.org/October2021/#InputFieldsDefinition
1774. https://spec.graphql.org/October2021/#Description
1775. https://spec.graphql.org/October2021/#Name
1776. https://spec.graphql.org/October2021/#Directives
1777. https://spec.graphql.org/October2021/#InputFieldsDefinition
1778. https://spec.graphql.org/October2021/#InputValueDefinition
1779. https://spec.graphql.org/October2021/#InputObjectTypeExtension
1780. https://spec.graphql.org/October2021/#Name
1781. https://spec.graphql.org/October2021/#Directives
1782. https://spec.graphql.org/October2021/#InputFieldsDefinition
1783. https://spec.graphql.org/October2021/#Name
1784. https://spec.graphql.org/October2021/#Directives
1785. https://spec.graphql.org/October2021/#DirectiveDefinition
1786. https://spec.graphql.org/October2021/#Description
1787. https://spec.graphql.org/October2021/#Name
1788. https://spec.graphql.org/October2021/#ArgumentsDefinition
1789. https://spec.graphql.org/October2021/#DirectiveLocations
1790. https://spec.graphql.org/October2021/#DirectiveLocations
1791. https://spec.graphql.org/October2021/#DirectiveLocations
1792. https://spec.graphql.org/October2021/#DirectiveLocation
1793. https://spec.graphql.org/October2021/#DirectiveLocation
1794. https://spec.graphql.org/October2021/#DirectiveLocation
1795. https://spec.graphql.org/October2021/#ExecutableDirectiveLocation
1796. https://spec.graphql.org/October2021/#TypeSystemDirectiveLocation
1797. https://spec.graphql.org/October2021/#ExecutableDirectiveLocation
1798. https://spec.graphql.org/October2021/#TypeSystemDirectiveLocation
1799. https://spec.graphql.org/October2021/#index
1800. https://spec.graphql.org/October2021/#Alias
1801. https://spec.graphql.org/October2021/#AreTypesCompatible()
1802. https://spec.graphql.org/October2021/#Argument
1803. https://spec.graphql.org/October2021/#Arguments
1804. https://spec.graphql.org/October2021/#ArgumentsDefinition
1805. https://spec.graphql.org/October2021/#BlockStringCharacter
1806. https://spec.graphql.org/October2021/#BlockStringValue()
1807. https://spec.graphql.org/October2021/#BooleanValue
1808. https://spec.graphql.org/October2021/#built-in-directive
1809. https://spec.graphql.org/October2021/#CoerceArgumentValues()
1810. https://spec.graphql.org/October2021/#CoerceResult()
1811. https://spec.graphql.org/October2021/#CoerceVariableValues()
1812. https://spec.graphql.org/October2021/#CollectFields()
1813. https://spec.graphql.org/October2021/#Comma
1814. https://spec.graphql.org/October2021/#Comment
1815. https://spec.graphql.org/October2021/#CommentChar
1816. https://spec.graphql.org/October2021/#CompleteValue()
1817. https://spec.graphql.org/October2021/#CreateSourceEventStream()
1818. https://spec.graphql.org/October2021/#custom-directive
1819. https://spec.graphql.org/October2021/#DefaultValue
1820. https://spec.graphql.org/October2021/#Definition
1821. https://spec.graphql.org/October2021/#Description
1822. https://spec.graphql.org/October2021/#DetectFragmentCycles()
1823. https://spec.graphql.org/October2021/#Digit
1824. https://spec.graphql.org/October2021/#Directive
1825. https://spec.graphql.org/October2021/#DirectiveDefinition
1826. https://spec.graphql.org/October2021/#DirectiveLocation
1827. https://spec.graphql.org/October2021/#DirectiveLocations
1828. https://spec.graphql.org/October2021/#Directives
1829. https://spec.graphql.org/October2021/#Document
1830. https://spec.graphql.org/October2021/#DoesFragmentTypeApply()
1831. https://spec.graphql.org/October2021/#EnumTypeDefinition
1832. https://spec.graphql.org/October2021/#EnumTypeExtension
1833. https://spec.graphql.org/October2021/#EnumValue
1834. https://spec.graphql.org/October2021/#EnumValueDefinition
1835. https://spec.graphql.org/October2021/#EnumValuesDefinition
1836. https://spec.graphql.org/October2021/#EscapedCharacter
1837. https://spec.graphql.org/October2021/#EscapedUnicode
1838. https://spec.graphql.org/October2021/#ExecutableDefinition
1839. https://spec.graphql.org/October2021/#ExecutableDirectiveLocation
1840. https://spec.graphql.org/October2021/#ExecutableDocument
1841. https://spec.graphql.org/October2021/#ExecuteField()
1842. https://spec.graphql.org/October2021/#ExecuteMutation()
1843. https://spec.graphql.org/October2021/#ExecuteQuery()
1844. https://spec.graphql.org/October2021/#ExecuteRequest()
1845. https://spec.graphql.org/October2021/#ExecuteSelectionSet()
1846. https://spec.graphql.org/October2021/#ExecuteSubscriptionEvent()
1847. https://spec.graphql.org/October2021/#ExponentIndicator
1848. https://spec.graphql.org/October2021/#ExponentPart
1849. https://spec.graphql.org/October2021/#Field
1850. https://spec.graphql.org/October2021/#FieldDefinition
1851. https://spec.graphql.org/October2021/#FieldsDefinition
1852. https://spec.graphql.org/October2021/#FieldsInSetCanMerge()
1853. https://spec.graphql.org/October2021/#FloatValue
1854. https://spec.graphql.org/October2021/#FractionalPart
1855. https://spec.graphql.org/October2021/#FragmentDefinition
1856. https://spec.graphql.org/October2021/#FragmentName
1857. https://spec.graphql.org/October2021/#FragmentSpread
1858. https://spec.graphql.org/October2021/#GetOperation()
1859. https://spec.graphql.org/October2021/#GetPossibleTypes()
1860. https://spec.graphql.org/October2021/#Ignored
1861. https://spec.graphql.org/October2021/#ImplementsInterfaces
1862. https://spec.graphql.org/October2021/#InlineFragment
1863. https://spec.graphql.org/October2021/#InputFieldsDefinition
1864. https://spec.graphql.org/October2021/#InputObjectTypeDefinition
1865. https://spec.graphql.org/October2021/#InputObjectTypeExtension
1866. https://spec.graphql.org/October2021/#InputValueDefinition
1867. https://spec.graphql.org/October2021/#IntegerPart
1868. https://spec.graphql.org/October2021/#InterfaceTypeDefinition
1869. https://spec.graphql.org/October2021/#InterfaceTypeExtension
1870. https://spec.graphql.org/October2021/#IntValue
1871. https://spec.graphql.org/October2021/#IsInputType()
1872. https://spec.graphql.org/October2021/#IsOutputType()
1873. https://spec.graphql.org/October2021/#IsValidImplementation()
1874. https://spec.graphql.org/October2021/#IsValidImplementationFieldType()
1875. https://spec.graphql.org/October2021/#IsVariableUsageAllowed()
1876. https://spec.graphql.org/October2021/#Letter
1877. https://spec.graphql.org/October2021/#LineTerminator
1878. https://spec.graphql.org/October2021/#ListType
1879. https://spec.graphql.org/October2021/#ListValue
1880. https://spec.graphql.org/October2021/#MapSourceToResponseEvent()
1881. https://spec.graphql.org/October2021/#MergeSelectionSets()
1882. https://spec.graphql.org/October2021/#Name
1883. https://spec.graphql.org/October2021/#NameContinue
1884. https://spec.graphql.org/October2021/#NamedType
1885. https://spec.graphql.org/October2021/#NameStart
1886. https://spec.graphql.org/October2021/#NegativeSign
1887. https://spec.graphql.org/October2021/#NonNullType
1888. https://spec.graphql.org/October2021/#NonZeroDigit
1889. https://spec.graphql.org/October2021/#NullValue
1890. https://spec.graphql.org/October2021/#ObjectField
1891. https://spec.graphql.org/October2021/#ObjectTypeDefinition
1892. https://spec.graphql.org/October2021/#ObjectTypeExtension
1893. https://spec.graphql.org/October2021/#ObjectValue
1894. https://spec.graphql.org/October2021/#OperationDefinition
1895. https://spec.graphql.org/October2021/#OperationType
1896. https://spec.graphql.org/October2021/#Punctuator
1897. https://spec.graphql.org/October2021/#ResolveAbstractType()
1898. https://spec.graphql.org/October2021/#ResolveFieldEventStream()
1899. https://spec.graphql.org/October2021/#ResolveFieldValue()
1900. https://spec.graphql.org/October2021/#RootOperationTypeDefinition
1901. https://spec.graphql.org/October2021/#SameResponseShape()
1902. https://spec.graphql.org/October2021/#scalar-specification-url
1903. https://spec.graphql.org/October2021/#ScalarTypeDefinition
1904. https://spec.graphql.org/October2021/#ScalarTypeExtension
1905. https://spec.graphql.org/October2021/#SchemaDefinition
1906. https://spec.graphql.org/October2021/#SchemaExtension
1907. https://spec.graphql.org/October2021/#Selection
1908. https://spec.graphql.org/October2021/#SelectionSet
1909. https://spec.graphql.org/October2021/#Sign
1910. https://spec.graphql.org/October2021/#SourceCharacter
1911. https://spec.graphql.org/October2021/#StringCharacter
1912. https://spec.graphql.org/October2021/#StringValue
1913. https://spec.graphql.org/October2021/#Subscribe()
1914. https://spec.graphql.org/October2021/#Token
1915. https://spec.graphql.org/October2021/#Type
1916. https://spec.graphql.org/October2021/#TypeCondition
1917. https://spec.graphql.org/October2021/#TypeDefinition
1918. https://spec.graphql.org/October2021/#TypeExtension
1919. https://spec.graphql.org/October2021/#TypeSystemDefinition
1920. https://spec.graphql.org/October2021/#TypeSystemDefinitionOrExtension
1921. https://spec.graphql.org/October2021/#TypeSystemDirectiveLocation
1922. https://spec.graphql.org/October2021/#TypeSystemDocument
1923. https://spec.graphql.org/October2021/#TypeSystemExtension
1924. https://spec.graphql.org/October2021/#TypeSystemExtensionDocument
1925. https://spec.graphql.org/October2021/#UnicodeBOM
1926. https://spec.graphql.org/October2021/#UnionMemberTypes
1927. https://spec.graphql.org/October2021/#UnionTypeDefinition
1928. https://spec.graphql.org/October2021/#UnionTypeExtension
1929. https://spec.graphql.org/October2021/#Unsubscribe()
1930. https://spec.graphql.org/October2021/#Value
1931. https://spec.graphql.org/October2021/#Variable
1932. https://spec.graphql.org/October2021/#VariableDefinition
1933. https://spec.graphql.org/October2021/#VariableDefinitions
1934. https://spec.graphql.org/October2021/#WhiteSpace
1935. https://spec-md.com/
1936. https://spec.graphql.org/October2021/
1937. https://spec.graphql.org/October2021/#sec-Overview
1938. https://spec.graphql.org/October2021/#sec-Language
1939. https://spec.graphql.org/October2021/#sec-Language.Source-Text
1940. https://spec.graphql.org/October2021/#sec-Unicode
1941. https://spec.graphql.org/October2021/#sec-White-Space
1942. https://spec.graphql.org/October2021/#sec-Line-Terminators
1943. https://spec.graphql.org/October2021/#sec-Comments
1944. https://spec.graphql.org/October2021/#sec-Insignificant-Commas
1945. https://spec.graphql.org/October2021/#sec-Language.Source-Text.Lexical-Tokens
1946. https://spec.graphql.org/October2021/#sec-Language.Source-Text.Ignored-Tokens
1947. https://spec.graphql.org/October2021/#sec-Punctuators
1948. https://spec.graphql.org/October2021/#sec-Names
1949. https://spec.graphql.org/October2021/#sec-Document
1950. https://spec.graphql.org/October2021/#sec-Language.Operations
1951. https://spec.graphql.org/October2021/#sec-Selection-Sets
1952. https://spec.graphql.org/October2021/#sec-Language.Fields
1953. https://spec.graphql.org/October2021/#sec-Language.Arguments
1954. https://spec.graphql.org/October2021/#sec-Field-Alias
1955. https://spec.graphql.org/October2021/#sec-Language.Fragments
1956. https://spec.graphql.org/October2021/#sec-Type-Conditions
1957. https://spec.graphql.org/October2021/#sec-Inline-Fragments
1958. https://spec.graphql.org/October2021/#sec-Input-Values
1959. https://spec.graphql.org/October2021/#sec-Int-Value
1960. https://spec.graphql.org/October2021/#sec-Float-Value
1961. https://spec.graphql.org/October2021/#sec-Boolean-Value
1962. https://spec.graphql.org/October2021/#sec-String-Value
1963. https://spec.graphql.org/October2021/#sec-Null-Value
1964. https://spec.graphql.org/October2021/#sec-Enum-Value
1965. https://spec.graphql.org/October2021/#sec-List-Value
1966. https://spec.graphql.org/October2021/#sec-Input-Object-Values
1967. https://spec.graphql.org/October2021/#sec-Language.Variables
1968. https://spec.graphql.org/October2021/#sec-Type-References
1969. https://spec.graphql.org/October2021/#sec-Language.Directives
1970. https://spec.graphql.org/October2021/#sec-Type-System
1971. https://spec.graphql.org/October2021/#sec-Type-System-Extensions
1972. https://spec.graphql.org/October2021/#sec-Descriptions
1973. https://spec.graphql.org/October2021/#sec-Schema
1974. https://spec.graphql.org/October2021/#sec-Root-Operation-Types
1975. https://spec.graphql.org/October2021/#sec-Schema-Extension
1976. https://spec.graphql.org/October2021/#sec-Types
1977. https://spec.graphql.org/October2021/#sec-Wrapping-Types
1978. https://spec.graphql.org/October2021/#sec-Input-and-Output-Types
1979. https://spec.graphql.org/October2021/#sec-Type-Extensions
1980. https://spec.graphql.org/October2021/#sec-Scalars
1981. https://spec.graphql.org/October2021/#sec-Int
1982. https://spec.graphql.org/October2021/#sec-Float
1983. https://spec.graphql.org/October2021/#sec-String
1984. https://spec.graphql.org/October2021/#sec-Boolean
1985. https://spec.graphql.org/October2021/#sec-ID
1986. https://spec.graphql.org/October2021/#sec-Scalar-Extensions
1987. https://spec.graphql.org/October2021/#sec-Objects
1988. https://spec.graphql.org/October2021/#sec-Field-Arguments
1989. https://spec.graphql.org/October2021/#sec-Field-Deprecation
1990. https://spec.graphql.org/October2021/#sec-Object-Extensions
1991. https://spec.graphql.org/October2021/#sec-Interfaces
1992. https://spec.graphql.org/October2021/#sec-Interface-Extensions
1993. https://spec.graphql.org/October2021/#sec-Unions
1994. https://spec.graphql.org/October2021/#sec-Union-Extensions
1995. https://spec.graphql.org/October2021/#sec-Enums
1996. https://spec.graphql.org/October2021/#sec-Enum-Extensions
1997. https://spec.graphql.org/October2021/#sec-Input-Objects
1998. https://spec.graphql.org/October2021/#sec-Input-Object-Extensions
1999. https://spec.graphql.org/October2021/#sec-List
2000. https://spec.graphql.org/October2021/#sec-Non-Null
2001. https://spec.graphql.org/October2021/#sec-Combining-List-and-Non-Null
2002. https://spec.graphql.org/October2021/#sec-Type-System.Directives
2003. https://spec.graphql.org/October2021/#sec--skip
2004. https://spec.graphql.org/October2021/#sec--include
2005. https://spec.graphql.org/October2021/#sec--deprecated
2006. https://spec.graphql.org/October2021/#sec--specifiedBy
2007. https://spec.graphql.org/October2021/#sec-Introspection
2008. https://spec.graphql.org/October2021/#sec-Type-Name-Introspection
2009. https://spec.graphql.org/October2021/#sec-Schema-Introspection
2010. https://spec.graphql.org/October2021/#sec-The-__Schema-Type
2011. https://spec.graphql.org/October2021/#sec-The-__Type-Type
2012. https://spec.graphql.org/October2021/#sec-The-__Field-Type
2013. https://spec.graphql.org/October2021/#sec-The-__InputValue-Type
2014. https://spec.graphql.org/October2021/#sec-The-__EnumValue-Type
2015. https://spec.graphql.org/October2021/#sec-The-__Directive-Type
2016. https://spec.graphql.org/October2021/#sec-Validation
2017. https://spec.graphql.org/October2021/#sec-Documents
2018. https://spec.graphql.org/October2021/#sec-Executable-Definitions
2019. https://spec.graphql.org/October2021/#sec-Validation.Operations
2020. https://spec.graphql.org/October2021/#sec-Named-Operation-Definitions
2021. https://spec.graphql.org/October2021/#sec-Operation-Name-Uniqueness
2022. https://spec.graphql.org/October2021/#sec-Anonymous-Operation-Definitions
2023. https://spec.graphql.org/October2021/#sec-Lone-Anonymous-Operation
2024. https://spec.graphql.org/October2021/#sec-Subscription-Operation-Definitions
2025. https://spec.graphql.org/October2021/#sec-Single-root-field
2026. https://spec.graphql.org/October2021/#sec-Validation.Fields
2027. https://spec.graphql.org/October2021/#sec-Field-Selections
2028. https://spec.graphql.org/October2021/#sec-Field-Selection-Merging
2029. https://spec.graphql.org/October2021/#sec-Leaf-Field-Selections
2030. https://spec.graphql.org/October2021/#sec-Validation.Arguments
2031. https://spec.graphql.org/October2021/#sec-Argument-Names
2032. https://spec.graphql.org/October2021/#sec-Argument-Uniqueness
2033. https://spec.graphql.org/October2021/#sec-Required-Arguments
2034. https://spec.graphql.org/October2021/#sec-Validation.Fragments
2035. https://spec.graphql.org/October2021/#sec-Fragment-Declarations
2036. https://spec.graphql.org/October2021/#sec-Fragment-Name-Uniqueness
2037. https://spec.graphql.org/October2021/#sec-Fragment-Spread-Type-Existence
2038. https://spec.graphql.org/October2021/#sec-Fragments-On-Composite-Types
2039. https://spec.graphql.org/October2021/#sec-Fragments-Must-Be-Used
2040. https://spec.graphql.org/October2021/#sec-Fragment-Spreads
2041. https://spec.graphql.org/October2021/#sec-Fragment-spread-target-defined
2042. https://spec.graphql.org/October2021/#sec-Fragment-spreads-must-not-form-cycles
2043. https://spec.graphql.org/October2021/#sec-Fragment-spread-is-possible
2044. https://spec.graphql.org/October2021/#sec-Object-Spreads-In-Object-Scope
2045. https://spec.graphql.org/October2021/#sec-Abstract-Spreads-in-Object-Scope
2046. https://spec.graphql.org/October2021/#sec-Object-Spreads-In-Abstract-Scope
2047. https://spec.graphql.org/October2021/#sec-Abstract-Spreads-in-Abstract-Scope
2048. https://spec.graphql.org/October2021/#sec-Values
2049. https://spec.graphql.org/October2021/#sec-Values-of-Correct-Type
2050. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Names
2051. https://spec.graphql.org/October2021/#sec-Input-Object-Field-Uniqueness
2052. https://spec.graphql.org/October2021/#sec-Input-Object-Required-Fields
2053. https://spec.graphql.org/October2021/#sec-Validation.Directives
2054. https://spec.graphql.org/October2021/#sec-Directives-Are-Defined
2055. https://spec.graphql.org/October2021/#sec-Directives-Are-In-Valid-Locations
2056. https://spec.graphql.org/October2021/#sec-Directives-Are-Unique-Per-Location
2057. https://spec.graphql.org/October2021/#sec-Validation.Variables
2058. https://spec.graphql.org/October2021/#sec-Variable-Uniqueness
2059. https://spec.graphql.org/October2021/#sec-Variables-Are-Input-Types
2060. https://spec.graphql.org/October2021/#sec-All-Variable-Uses-Defined
2061. https://spec.graphql.org/October2021/#sec-All-Variables-Used
2062. https://spec.graphql.org/October2021/#sec-All-Variable-Usages-are-Allowed
2063. https://spec.graphql.org/October2021/#sec-Execution
2064. https://spec.graphql.org/October2021/#sec-Executing-Requests
2065. https://spec.graphql.org/October2021/#sec-Validating-Requests
2066. https://spec.graphql.org/October2021/#sec-Coercing-Variable-Values
2067. https://spec.graphql.org/October2021/#sec-Executing-Operations
2068. https://spec.graphql.org/October2021/#sec-Query
2069. https://spec.graphql.org/October2021/#sec-Mutation
2070. https://spec.graphql.org/October2021/#sec-Subscription
2071. https://spec.graphql.org/October2021/#sec-Source-Stream
2072. https://spec.graphql.org/October2021/#sec-Response-Stream
2073. https://spec.graphql.org/October2021/#sec-Unsubscribe
2074. https://spec.graphql.org/October2021/#sec-Executing-Selection-Sets
2075. https://spec.graphql.org/October2021/#sec-Normal-and-Serial-Execution
2076. https://spec.graphql.org/October2021/#sec-Field-Collection
2077. https://spec.graphql.org/October2021/#sec-Executing-Fields
2078. https://spec.graphql.org/October2021/#sec-Coercing-Field-Arguments
2079. https://spec.graphql.org/October2021/#sec-Value-Resolution
2080. https://spec.graphql.org/October2021/#sec-Value-Completion
2081. https://spec.graphql.org/October2021/#sec-Handling-Field-Errors
2082. https://spec.graphql.org/October2021/#sec-Response
2083. https://spec.graphql.org/October2021/#sec-Response-Format
2084. https://spec.graphql.org/October2021/#sec-Data
2085. https://spec.graphql.org/October2021/#sec-Errors
2086. https://spec.graphql.org/October2021/#sec-Serialization-Format
2087. https://spec.graphql.org/October2021/#sec-JSON-Serialization
2088. https://spec.graphql.org/October2021/#sec-Serialized-Map-Ordering
2089. https://spec.graphql.org/October2021/#sec-Appendix-Notation-Conventions
2090. https://spec.graphql.org/October2021/#sec-Context-Free-Grammar
2091. https://spec.graphql.org/October2021/#sec-Lexical-and-Syntactical-Grammar
2092. https://spec.graphql.org/October2021/#sec-Grammar-Notation
2093. https://spec.graphql.org/October2021/#sec-Grammar-Semantics
2094. https://spec.graphql.org/October2021/#sec-Algorithms
2095. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary
2096. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Source-Text
2097. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Ignored-Tokens
2098. https://spec.graphql.org/October2021/#sec-Appendix-Grammar-Summary.Lexical-Tokens
2099. https://spec.graphql.org/October2021/#sec-Document-Syntax
2100. https://spec.graphql.org/October2021/#index
